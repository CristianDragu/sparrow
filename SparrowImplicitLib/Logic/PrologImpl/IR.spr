import Token;
import Nodes;
import LType;

public using allowNativeCodeGen = true;

public class[ct] SparrowPrologSystem
{
    public var predicates: Vector(SparrowPredicate);
    public var loc: LLocation;

    public fun ctor(program: @PrologProgramPtr)
    {
        this.predicates ctor;
        this.loc ctor program.get().loc;

        // Handle all predicate clauses
        for ( pptr: @PredicateClausePtr = program.get().predicates.all() )
        {
            var p: @PredicateClause = pptr.get();
            var name: @String = p.name;
            var arity: UInt = p.args.size();

            // Search for an existing predicate with same name and same arity
            var r = findIf(predicates.all(),
                (fun.{name,arity} (sp: @SparrowPredicate) = sp.name == name && sp.arity == arity));

            // Id the predicate does not exist add it; otherwise add a clause to it
            if ( r.isEmpty() )
                predicates.pushBack(SparrowPredicate(pptr));
            else
                r.front().addClause(p);
        }
    }

    public fun semanticCheck
    {
        for ( pred: @SparrowPredicate = predicates.all() )
            pred.semanticCheck();
    }
}

public class[ct] Parameter
{
    public var expr: ExpressionPtr;
    public var isRead, isInput, isOutput: Bool;

    public fun ctor
    {
        expr ctor;
        isRead ctor false;
        isInput ctor false;
        isOutput ctor false;
    }
    public fun ctor(e: ExpressionPtr)
    {
        expr ctor e;
        isRead ctor false;
        isInput ctor false;
        isOutput ctor false;
    }
}

public class[ct] SparrowPredicate
{
    public var name: String;
    public var arity: UInt;
    public var firstClause: PredicateClausePtr;
    public var paramVars: Vector(Parameter);
    public var localVars: Vector(ExpressionPtr);
    public var clauses: Vector(PredicateClausePtr);
    public var typeSets: Vector(LTypeSet);
    public var canBeNative: Bool;

    public fun ctor(firstClause: @PredicateClausePtr)
    {
        this.name ctor firstClause.get().name;
        this.arity ctor UInt(firstClause.get().args.size());
        this.firstClause ctor firstClause;
        this.paramVars ctor;
        this.localVars ctor;
        this.clauses ctor;
        this.typeSets ctor;
        this.canBeNative ctor false;

        addClause(firstClause);
        paramVars.resize(arity);
    }

    public fun addClause(clause: @PredicateClausePtr)
    {
        assert(clause.get().args.size() == arity);
        clauses.pushBack(clause);
    }

    public fun semanticCheck
    {
        // Update the variables from all the clauses
        // Compute the types of the expressions and variables
        for ( i = 0..clauses.size() )
            checkClause(clauses(i).get(), Int(i));

        // Check if we can generate this natively
        if ( allowNativeCodeGen )
            checkNative();
    }

    private fun checkClause(clause: @PredicateClause, clauseIdx: Int)
    {
        // Assign type sets for bound args
        for ( i = 0..clause.args.size() )
        {
            var arg: @ExpressionPtr = clause.args(i);
            arg.get().paramIdx = Int(i);

            var paramVar: @Parameter = paramVars(i);
            if ( paramVar.expr isNull )
                paramVar = Parameter(arg);
            else
                mergeTypeSets(paramVar.expr, arg);
            checkExpr(clause, clauseIdx, arg.get());
        }

        // Check conditions
        for ( c = clause.conditions.all() )
            checkCondition(clause, clauseIdx, c.get());
    }
    private fun checkCondition(clause: @PredicateClause, clauseIdx: Int, cond: @Condition)
    {
        if ( cond.kind == ckPredCall )
        {
            for ( arg = cond.args.all() )
                checkExpr(clause, clauseIdx, arg);
        }
        else
        {
            checkExpr(clause, clauseIdx, cond.args(0));
            checkExpr(clause, clauseIdx, cond.args(1));

            // The two expressions must have the same type
            mergeTypeSets(cond.args(0), cond.args(1));
        }
    }
    private fun checkExpr(clause: @PredicateClause, clauseIdx: Int, exprPtr: @ExpressionPtr)
    {
        var typeSet: @LTypeSet = getCreateTypeSet(exprPtr);

        var expr: @Expression = exprPtr.get();
        if ( expr.kind == ekAtom )
        {
            typeSet.setAtomOnly(expr.loc);
        }
        else if ( expr.kind == ekNumber )
        {
            typeSet.setNumberOnly(expr.loc);
        }
        else if ( expr.kind == ekVar )
        {
            var newName: String;

            // Is this variable referring to a predicate parameter?
            var idx = expr.paramIdx;
            if ( idx < 0 )
                idx = Int(indexOfIf(clause.args.all(), (fun.{expr} a = a.get().data == expr.data)));
            if ( idx != -1 )
            {
                newName = String("p_") + intToString(Int(idx+1));
                var paramVar: @Parameter = paramVars(idx);
                if ( paramVar.expr isNull )
                    paramVar = Parameter(expr);
                else
                    mergeTypeSets(paramVar.expr, exprPtr);

                expr.paramIdx = Int(idx);
            }
            else
            {
                newName = String("l") + intToString(clauseIdx) + "_" + expr.data;

                // Add this to the local vars if it does not exist
                var idx = indexOfIf(localVars.all(), (fun.{newName} v = v.get().data == newName));
                if ( idx == SizeType(DiffType(-1)) )
                    localVars.pushBack(exprPtr);
                else
                    mergeTypeSets(localVars(idx), exprPtr);

            }
            expr.data = newName;
        }
        else if ( expr.kind == ekOpPlus || expr.kind == ekOpMinus || expr.kind == ekOpMul || expr.kind == ekOpDiv )
        {
            typeSet.setNumberOnly(expr.loc);
            if ( expr.left isNull )
                Meta.report("Invalid binary expression: no left part", expr.loc.asMetaLocation());
            if ( expr.right isNull )
                Meta.report("Invalid binary expression: no right part", expr.loc.asMetaLocation());

            checkExpr(clause, clauseIdx, expr.left);
            checkExpr(clause, clauseIdx, expr.right);

            mergeTypeSets(expr.left, exprPtr);
            mergeTypeSets(expr.right, exprPtr);

            // If left of right are parameters, mark them as input parameters
            if ( expr.left.get().paramIdx >= 0 )
            {
                var param: @Parameter = paramVars(expr.left.get().paramIdx);
                param.isRead = true;
                param.isInput = true;
            }
            if ( expr.right.get().paramIdx >= 0 )
            {
                var param: @Parameter = paramVars(expr.right.get().paramIdx);
                param.isRead = true;
                param.isInput = true;
            }
        }
    }

    private fun checkNative
    {
        // Rules:
        // - input parameters:
        //      - at least once present in a binary operations, where they require a value
        //      - never be in an 'is' condition
        // - output parameters:
        //      - never read from them (part of a binary expression)
        //      - only once in an 'is' condition
        // - local variables:
        //      - only once in an 'is' condition
        // - all the parameters are either input or output
        // - the right part of every 'is' condition is a value
        // - there are no calls to other predicates other than the current one

        canBeNative = true;

        var isVars: Vector(String);
        isVars.reserve(arity + localVars.size());

        for ( clause: @PredicateClausePtr = clauses.all() )
        {
            for ( c: @ConditionPtr = clause.get().conditions.all() )
            {
                var cond: @Condition = c.get();
                if ( cond.kind == ckIsExpr )
                {
                    var left: @Expression = cond.args(0).get();
                    var right: @Expression = cond.args(1).get();

                    // Right should always be a value
                    if ( !isValue(right) )
                    {
                        canBeNative = false;
                        return;
                    }

                    // A name (param / local var) cannot be twice in an 'is' condition
                    var varName: @String = left.data;
                    var idx: DiffType = indexOf(isVars.all(), left.data);
                    if ( idx >= 0 )
                    {
                        canBeNative = false;
                        return;
                    }
                    else
                    {
                        isVars.pushBack(left.data);
                    }

                    // Input parameters cannot be part in 'is' conditions
                    assert(left.kind == ekVar);
                    if ( left.paramIdx >= 0 )
                    {
                        var param: @Parameter = paramVars(left.paramIdx);
                        param.isInput = false;
                        // If this is not an input parameter, it must be an output
                        if ( param.isRead )
                        {
                            canBeNative = false;
                            return;
                        }
                        param.isOutput = true;
                    }
                }
                else
                {
                    if ( cond.predName != name )
                    {
                        canBeNative = false;
                        return;
                    }
                }
            }
        }

        // This can be native if all the parameter are wither input or output
        canBeNative = true;
        for ( param: @Parameter = paramVars.all() )
        {
            if ( !param.isInput && !param.isOutput )
            {
                canBeNative = false;
                return;
            }
        }
    }    

    private fun isValue(expr: @Expression): Bool
    {
        // Anything except a variable is a value
        return expr.kind != ekVar;
    }

    private fun checkCreateTypeSet(exp: @ExpressionPtr)
    {
        if ( exp.get().typeSetIdx < 0 )
        {
            // Create a new type set
            var idx = Int(typeSets.size());
            typeSets.pushBack(LTypeSet(idx, LType()));
            var res: @LTypeSet = typeSets(idx);
            res.addExpression(exp);
        }
    }

    private fun getCreateTypeSet(exp: @ExpressionPtr): @LTypeSet
    {
        checkCreateTypeSet(exp);
        return typeSets(exp.get().typeSetIdx);
    }

    private fun mergeTypeSets(exp1, exp2: @ExpressionPtr)
    {
        checkCreateTypeSet(exp1);
        checkCreateTypeSet(exp2);
        typeSets(exp1.get().typeSetIdx).mergeWith(typeSets(exp2.get().typeSetIdx), exp2.get().loc);
    }
}
