package Math;

import SprCore.NumericOper;

fun[native("llvm.sqrt.f32"), rtct] sqrt(x: Float): Float;
fun[native("llvm.sin.f32"), rtct] sin(x: Float): Float;
fun[native("llvm.cos.f32"), rtct] cos(x: Float): Float;
fun[native("llvm.powi.f32"), rtct] powi(x: Float, y: Int): Float;
fun[native("llvm.pow.f32"), rtct] pow(x, y: Float): Float;
fun[native("llvm.exp.f32"), rtct] exp(x: Float): Float;
fun[native("llvm.exp2.f32"), rtct] exp2(x: Float): Float;
fun[native("llvm.log.f32"), rtct] log(x: Float): Float;
fun[native("llvm.log10.f32"), rtct] log10(x: Float): Float;
fun[native("llvm.log2.f32"), rtct] log2(x: Float): Float;
fun[native("llvm.fabs.f32"), rtct] fabs(x: Float): Float;
fun[native("llvm.floor.f32"), rtct] floor(x: Float): Float;
fun[native("llvm.ceil.f32"), rtct] ceil(x: Float): Float;
fun[native("llvm.truc.f32"), rtct] truc(x: Float): Float;
fun[native("llvm.rint.f32"), rtct] rint(x: Float): Float;
fun[native("llvm.rint.f32"), rtct] nearbyint(x: Float): Float;

fun[native("llvm.sqrt.f64"), rtct] sqrt(x: Double): Double;
fun[native("llvm.sin.f64"), rtct] sin(x: Double): Double;
fun[native("llvm.cos.f64"), rtct] cos(x: Double): Double;
fun[native("llvm.powi.f64"), rtct] powi(x: Double, y: Int): Double;
fun[native("llvm.pow.f64"), rtct] pow(x, y: Double): Double;
fun[native("llvm.exp.f64"), rtct] exp(x: Double): Double;
fun[native("llvm.exp2.f64"), rtct] exp2(x: Double): Double;
fun[native("llvm.log.f64"), rtct] log(x: Double): Double;
fun[native("llvm.log10.f64"), rtct] log10(x: Double): Double;
fun[native("llvm.log2.f64"), rtct] log2(x: Double): Double;
fun[native("llvm.fabs.f64"), rtct] fabs(x: Double): Double;
fun[native("llvm.floor.f64"), rtct] floor(x: Double): Double;
fun[native("llvm.ceil.f64"), rtct] ceil(x: Double): Double;
fun[native("llvm.truc.f64"), rtct] truc(x: Double): Double;
fun[native("llvm.rint.f64"), rtct] rint(x: Double): Double;
fun[native("llvm.rint.f64"), rtct] nearbyint(x: Double): Double;

fun[rtct] abs(x: Integer) = ife(x<0, -x, x);
