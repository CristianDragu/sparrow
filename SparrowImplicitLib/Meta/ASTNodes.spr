package Meta;

import Meta.Location;

using modeUnspecified = 0;
using modeRt = 1;
using modeCt = 2;
using modeRtCt = 3;

/// Taking an AST node, this will evaluate the node and produce the corresponding 
fun[ct, native("$Meta.astEval")] astEval(node: AstNode): AstNode;

/// Given any Sparrow node as parameter, this will transform it into an AST node
//fun[ct, native("$Meta.lift")] lift(): AstNode;



class[ct] CompilationContext
{
    fun[static, native("$Meta.CompilationContext.current")] current(): CompilationContext;

    fun[native("$Meta.CompilationContext.evalMode")] evalMode: Int;
    fun[native("$Meta.CompilationContext.sourceCode")] sourceCode: SourceCode;

    fun ctor
    {
        impl := null;
    }
    private fun ctor(impl: @Int)
    {
        this.impl := impl;
    }
    private var impl: @Int;
}

class[ct] AstType
{
    fun[native("$Meta.AstType.typeKind")] typeKind: Int;
    fun[native("$Meta.AstType.toString")] toString: StringRef;

    fun[native("$Meta.AstType.hasStorage")] hasStorage: Bool;
    fun[native("$Meta.AstType.numReferences")] numReferences: Int;
    fun[native("$Meta.AstType.mode")] mode: Int;
    fun[native("$Meta.AstType.canBeUsedAtCt")] canBeUsedAtCt: Bool;
    fun[native("$Meta.AstType.canBeUsedAtRt")] canBeUsedAtRt: Bool;

    fun ctor
    {
        impl := null;
    }
    private var impl: @Int;
}

class[ct] AstNode
{
    fun isNull: Bool = impl === null;
    fun isSet: Bool = impl !== null;

    fun[native("$Meta.AstNode.clone")] clone: AstNode;
    fun[native("$Meta.AstNode.nodeKind")] nodeKind: Int;
    fun[native("$Meta.AstNode.nodeKindName")] nodeKindName: StringRef;
    fun[native("$Meta.AstNode.toString")] toString: StringRef;
    fun[native("$Meta.AstNode.toStringExt")] toStringExt: StringRef;

    // Node properties

    fun[native("$Meta.AstNode.location")] location: Location;

    if[ct] ( isValid(Vector(AstNode)) )
        fun[native("$Meta.AstNode.children")] children: Vector(AstNode);    // TODO: fix this
    fun[native("$Meta.AstNode.getChild")] getChild(n: Int): AstNode;
    if[ct] ( isValid(Vector(AstNode)) )
        fun[native("$Meta.AstNode.referredNodes")] referredNodes: Vector(AstNode);

    fun[native("$Meta.AstNode.hasProperty")] hasProperty(name: StringRef): Bool;
    fun[native("$Meta.AstNode.getPropertyString")] getPropertyString(name: StringRef, value: @StringRef): Bool;
    fun[native("$Meta.AstNode.getPropertyInt")] getPropertyInt(name: StringRef, value: @Int): Bool;
    fun[native("$Meta.AstNode.getPropertyNode")] getPropertyNode(name: StringRef, value: @AstNode): Bool;
    fun[native("$Meta.AstNode.getPropertyType")] getPropertyType(name: StringRef, value: @AstType): Bool;
    fun[native("$Meta.AstNode.setProperty")] setProperty(name: StringRef, value: StringRef);
    fun[native("$Meta.AstNode.setProperty")] setProperty(name: StringRef, value: Int);
    fun[native("$Meta.AstNode.setProperty")] setProperty(name: StringRef, value: AstNode);
    fun[native("$Meta.AstNode.setProperty")] setProperty(name: StringRef, value: AstType);

    // Compilation processes

    fun[native("$Meta.AstNode.setContext")] setContext(context: CompilationContext);
    fun[native("$Meta.AstNode.computeType")] computeType;
    fun[native("$Meta.AstNode.semanticCheck")] semanticCheck;
    fun[native("$Meta.AstNode.clearCompilationState")] clearCompilationState;

    fun[native("$Meta.AstNode.context")] context: CompilationContext;

    fun[native("$Meta.AstNode.hasError")] hasError: Bool;
    fun[native("$Meta.AstNode.isSemanticallyChecked")] isSemanticallyChecked: Bool;

    fun[native("$Meta.AstNode.type")] type: AstType;

    fun[native("$Meta.AstNode.isExplained")] isExplained: Bool;
    fun[native("$Meta.AstNode.explanation")] explanation: AstNode;
    fun[native("$Meta.AstNode.curExplanation")] curExplanation: AstNode;

    // Private stuff

    private fun ctor
    {
        impl := null;
    }
    private fun ctor(impl: @Int)
    {
        this.impl := impl;
    }
    private var impl: @Int;
}

package Feather
{
    // TODO: AST interface is not consistent
    fun[ct] mkNodeList(loc: @Location): AstNode = Impl.mkNodeList(loc, null, null, false);
    fun[ct] mkNodeList(loc: @Location, voidResult: Bool): AstNode = Impl.mkNodeList(loc, null, null, voidResult);
    fun[ct] mkNodeList(loc: @Location, childrenBegin, childrenEnd: @AstNode) = Impl.mkNodeList(loc, childrenBegin, childrenEnd, false);
    fun[ct] mkNodeList(loc: @Location, childrenBegin, childrenEnd: @AstNode, voidResult: Bool) = Impl.mkNodeList(loc, childrenBegin, childrenEnd, voidResult);
    if[ct] ( isValid(Vector(AstNode)) )
        fun[ct] mkNodeList(loc: @Location, children: @Vector(AstNode)): AstNode = Impl.mkNodeList(loc, children.begin.value(), children.end.value(), false);
    if[ct] ( isValid(Vector(AstNode)) )
        fun[ct] mkNodeList(loc: @Location, children: @Vector(AstNode), voidResult: Bool): AstNode = Impl.mkNodeList(loc, children.begin.value(), children.end.value(), voidResult);
    fun[ct, native("$Meta.Feather.addToNodeList")] addToNodeList(list, newNode: AstNode): AstNode;
    fun[ct, native("$Meta.Feather.appendNodeList")] appendNodeList(main, newList: AstNode): AstNode;

    fun[ct, native("$Meta.Feather.mkNop")] mkNop(loc: Location): AstNode;
    fun[ct, native("$Meta.Feather.mkTypeNode")] mkTypeNode(loc: @Location, type: AstType): AstNode;
    fun[ct, native("$Meta.Feather.mkBackendCode")] mkBackendCode(loc: @Location, code: StringRef, mode: Int): AstNode;
    fun[ct, native("$Meta.Feather.mkLocalSpace")] mkLocalSpace(loc: @Location, childrenBegin, childrenEnd: @AstNode): AstNode;
    //if[ct] ( isValid(Vector(AstNode)) )
    //    fun[ct] mkLocalSpace(loc: @Location, children: @Vector(AstNode)): AstNode = Impl.mkLocalSpace(loc, children.begin.value(), children.end.value());
    fun[ct, native("$Meta.Feather.mkGlobalConstructAction")] mkGlobalConstructAction(loc: @Location, action: AstNode): AstNode;
    fun[ct, native("$Meta.Feather.mkGlobalDestructAction")] mkGlobalDestructAction(loc: @Location, action: AstNode): AstNode;
    fun[ct, native("$Meta.Feather.mkScopeDestructAction")] mkScopeDestructAction(loc: @Location, action: AstNode): AstNode;
    fun[ct, native("$Meta.Feather.mkTempDestructAction")] mkTempDestructAction(loc: @Location, action: AstNode): AstNode;

    if[ct] ( isValid(Vector(AstNode)) )
        fun[ct] mkFunction(loc: @Location, name: StringRef, resType: AstNode, params: @Vector(AstNode), body: AstNode, mode: Int): AstNode = Impl.mkFunction(loc, name, resType, params.begin.value(), params.end.value(), body, mode);
    if[ct] ( isValid(Vector(AstNode)) )
        fun[ct] mkClass(loc: @Location, name: StringRef, fields: @Vector(AstNode), mode: Int): AstNode = Impl.mkClass(loc, name, fields.begin.value(), fields.end.value(), mode);
    if[ct] ( isValid(Vector(AstNode)) )
        fun[ct, native("$Meta.Feather.mkVar")] mkVar(loc: @Location, name: StringRef, type: AstNode, mode: Int): AstNode;

    fun[ct, native("$Meta.Feather.mkCtValue")] mkCtValue(loc: @Location, type: AstType, data: StringRef): AstNode;
    fun[ct, native("$Meta.Feather.mkNull")] mkNull(loc: @Location, typeNode: AstNode): AstNode;
    fun[ct, native("$Meta.Feather.mkStackAlloc")] mkStackAlloc(loc: @Location, typeNode: AstNode, numElements: Int): AstNode;
    fun[ct, native("$Meta.Feather.mkVarRef")] mkVarRef(loc: @Location, varDecl: AstNode): AstNode;
    fun[ct, native("$Meta.Feather.mkFieldRef")] mkFieldRef(loc: @Location, obj, fieldDecl: AstNode): AstNode;
    fun[ct, native("$Meta.Feather.mkFunRef")] mkFunRef(loc: @Location, funDecl: AstNode, resType: AstNode): AstNode;
    if[ct] ( isValid(Vector(AstNode)) )
        fun[ct] mkFunCall(loc: @Location, funDecl: AstNode, args: @Vector(AstNode)): AstNode = Impl.mkFunCall(loc, funDecl, args.begin.value(), args.end.value());
    fun[ct, native("$Meta.Feather.mkMemLoad")] mkMemLoad(loc: @Location, exp: AstNode): AstNode;
    fun[ct, native("$Meta.Feather.mkMemStore")] mkMemStore(loc: @Location, value, address: AstNode): AstNode;
    fun[ct, native("$Meta.Feather.mkBitcast")] mkBitcast(loc: @Location, destType: AstNode, node: AstNode): AstNode;
    fun[ct, native("$Meta.Feather.mkConditional")] mkConditional(loc: @Location, condition, alt1, alt2: AstNode): AstNode;

    fun[ct, native("$Meta.Feather.mkIf")] mkIf(loc: @Location, condition, thenClause, elseClause: AstNode): AstNode;
    fun[ct, native("$Meta.Feather.mkIf")] mkIf(loc: @Location, condition, thenClause, elseClause: AstNode, isCt: Bool): AstNode;
    fun[ct, native("$Meta.Feather.mkWhile")] mkWhile(loc: @Location, condition, body, step: AstNode): AstNode;
    fun[ct, native("$Meta.Feather.mkWhile")] mkWhile(loc: @Location, condition, body, step: AstNode, isCt: Bool): AstNode;
    fun[ct, native("$Meta.Feather.mkBreak")] mkBreak(loc: Location): AstNode;
    fun[ct, native("$Meta.Feather.mkContinue")] mkContinue(loc: Location): AstNode;
    fun[ct, native("$Meta.Feather.mkReturn")] mkReturn(loc: Location): AstNode;
    fun[ct, native("$Meta.Feather.mkReturn")] mkReturn(loc: @Location, exp: AstNode): AstNode;

    package Impl
    {
        fun[ct, native("$Meta.Feather.mkNodeList")] mkNodeList(loc: @Location, childrenBegin, childrenEnd: @AstNode, voidResult: Bool): AstNode;
        fun[ct, native("$Meta.Feather.mkLocalSpace")] mkLocalSpace(loc: @Location, childrenBegin, childrenEnd: @AstNode): AstNode;
        fun[ct, native("$Meta.Feather.mkFunction")] mkFunction(loc: @Location, name: StringRef, resType: AstNode, paramsBegin, paramsEnd: @AstNode, body: AstNode, mode: Int): AstNode;
        fun[ct, native("$Meta.Feather.mkClass")] mkClass(loc: @Location, name: StringRef, fieldBegin, fieldEnd: @AstNode, mode: Int): AstNode;
        fun[ct, native("$Meta.Feather.mkFunCall")] mkFunCall(loc: @Location, funDecl: AstNode, argsBegin, argsEnd: @AstNode): AstNode;
    }
}

package SprFrontend
{
    fun[ct, native("$Meta.Sparrow.mkModifiers")] mkModifiers(loc: @Location, main, mods: AstNode): AstNode;

    fun[ct, native("$Meta.Sparrow.mkSprCompilationUnit")] mkSprCompilationUnit(loc: @Location, packageName, imports, declarations: AstNode): AstNode;
    fun[ct, native("$Meta.Sparrow.mkSprUsing")] mkSprUsing(loc: @Location, alias: StringRef, usingNode: AstNode): AstNode;
    fun[ct, native("$Meta.Sparrow.mkSprPackage")] mkSprPackage(loc: @Location, name: StringRef, children: AstNode): AstNode;
    fun[ct, native("$Meta.Sparrow.mkSprVariable")] mkSprVariable(loc: @Location, name: StringRef, typeNode, init: AstNode): AstNode;
    fun[ct, native("$Meta.Sparrow.mkSprClass")] mkSprClass(loc: @Location, name: StringRef, parameters, baseClasses, ifClause, children: AstNode): AstNode;

    fun[ct, native("$Meta.Sparrow.mkSprConcept")] mkSprConcept(loc: @Location, name: StringRef, paramName: StringRef, baseConcept, ifClause: AstNode): AstNode;

    fun[ct, native("$Meta.Sparrow.mkSprFunction")] mkSprFunction(loc: @Location, name: StringRef, parmeters, returnType, body, ifClause: AstNode): AstNode;
    fun[ct, native("$Meta.Sparrow.mkSprFunctionExp")] mkSprFunctionExp(loc: @Location, name: StringRef, parameters, returnType, bodyExp, ifClause: AstNode): AstNode;
    fun[ct, native("$Meta.Sparrow.mkSprParameter")] mkSprParameter(loc: @Location, name: StringRef, typeNode, init: AstNode): AstNode;
    fun[ct, native("$Meta.Sparrow.mkSprAutoParameter")] mkSprAutoParameter(loc: @Location, name: StringRef): AstNode;

    fun[ct, native("$Meta.Sparrow.mkIdentifier")] mkIdentifier(loc: @Location, id: StringRef): AstNode;
    fun[ct, native("$Meta.Sparrow.mkCompoundExp")] mkCompoundExp(loc: @Location, base: AstNode, id: StringRef): AstNode;
    fun[ct, native("$Meta.Sparrow.mkStarExp")] mkStarExp(loc: @Location, base: AstNode, operName: StringRef): AstNode;
    fun[ct, native("$Meta.Sparrow.mkPostfixOp")] mkPostfixOp(loc: @Location, op: StringRef, base: AstNode): AstNode;
    fun[ct, native("$Meta.Sparrow.mkInfixOp")] mkInfixOp(loc: @Location, op: StringRef, arg1, arg2: AstNode): AstNode;
    fun[ct, native("$Meta.Sparrow.mkPrefixOp")] mkPrefixOp(loc: @Location, op: StringRef, base: AstNode): AstNode;
    fun[ct, native("$Meta.Sparrow.mkFunApplication")] mkFunApplication(loc: @Location, base, arguments: AstNode): AstNode;
    fun[ct, native("$Meta.Sparrow.mkOperatorCall")] mkOperatorCall(loc: @Location, arg1: AstNode, op: StringRef, arg2: AstNode): AstNode;

    fun[ct, native("$Meta.Sparrow.mkConditionalExp")] mkConditionalExp(loc: @Location, cond, alt1, alt2: AstNode): AstNode;
    fun[ct, native("$Meta.Sparrow.mkThisExp")] mkThisExp(loc: Location): AstNode;
    fun[ct, native("$Meta.Sparrow.mkParenthesisExp")] mkParenthesisExp(loc: @Location, exp: AstNode): AstNode;
    fun[ct, native("$Meta.Sparrow.mkIntLiteral")] mkIntLiteral(loc: @Location, value: Int): AstNode;
    fun[ct, native("$Meta.Sparrow.mkUIntLiteral")] mkUIntLiteral(loc: @Location, value: UInt): AstNode;
    fun[ct, native("$Meta.Sparrow.mkLongLiteral")] mkLongLiteral(loc: @Location, value: Long): AstNode;
    fun[ct, native("$Meta.Sparrow.mkULongLiteral")] mkULongLiteral(loc: @Location, value: ULong): AstNode;
    fun[ct, native("$Meta.Sparrow.mkFloatLiteral")] mkFloatLiteral(loc: @Location, value: Float): AstNode;
    fun[ct, native("$Meta.Sparrow.mkDoubleLiteral")] mkDoubleLiteral(loc: @Location, value: Double): AstNode;
    fun[ct, native("$Meta.Sparrow.mkCharLiteral")] mkCharLiteral(loc: @Location, value: Char): AstNode;
    fun[ct, native("$Meta.Sparrow.mkStringLiteral")] mkStringLiteral(loc: @Location, value: StringRef): AstNode;
    fun[ct, native("$Meta.Sparrow.mkNullLiteral")] mkNullLiteral(loc: Location): AstNode;
    fun[ct, native("$Meta.Sparrow.mkBoolLiteral")] mkBoolLiteral(loc: @Location, value: Bool): AstNode;
    fun[ct, native("$Meta.Sparrow.mkLambdaExp")] mkLambdaExp(loc: @Location, parameters, returnType, body, bodyExp, closureParams: AstNode): AstNode;
    
    fun[ct, native("$Meta.Sparrow.mkExpressionStmt")] mkExpressionStmt(loc: @Location, exp: AstNode): AstNode;
    fun[ct, native("$Meta.Sparrow.mkBlockStmt")] mkBlockStmt(loc: @Location, statements: AstNode): AstNode;
    fun[ct, native("$Meta.Sparrow.mkIfStmt")] mkIfStmt(loc: @Location, cond, thenClause, elseClause: AstNode): AstNode;
    fun[ct, native("$Meta.Sparrow.mkForStmt")] mkForStmt(loc: @Location, name: StringRef, type, range, action: AstNode): AstNode;
    fun[ct, native("$Meta.Sparrow.mkWhileStmt")] mkWhileStmt(loc: @Location, cond, step, action: AstNode): AstNode;
    fun[ct, native("$Meta.Sparrow.mkBreakStmt")] mkBreakStmt(loc: Location): AstNode;
    fun[ct, native("$Meta.Sparrow.mkContinueStmt")] mkContinueStmt(loc: Location): AstNode;
    fun[ct, native("$Meta.Sparrow.mkReturnStmt")] mkReturnStmt(loc: @Location, exp: AstNode): AstNode;
}

package Util
{
    fun[ct, native("$Meta.Util.getParentDecl")] getParentDecl(ctx: CompilationContext): AstNode;
    fun[ct, native("$Meta.Util.getParentFun")] getParentFun(ctx: CompilationContext): AstNode;
    fun[ct, native("$Meta.Util.getParentClass")] getParentClass(ctx: CompilationContext): AstNode;
    fun[ct, native("$Meta.Util.getParentLoop")] getParentLoop(ctx: CompilationContext): AstNode;
    fun[ct, native("$Meta.Util.getSymTabContext")] getSymTabContext(ctx: CompilationContext): CompilationContext;
}

package Compiler
{
    fun[ct, native("$Meta.Compiler.registerFrontendFun")] registerFrontendFun(ext, funName: StringRef): Bool;
    fun[ct, native("$Meta.Compiler.parseSprExpression")] parseSprExpression(loc: @Location, exp: StringRef): AstNode;
}

package Kinds
{
    using nkFeatherNop = 1;
    using nkFeatherTypeNode = 2;
    using nkFeatherBackendCode = 3;
    using nkFeatherNodeList = 4;
    using nkFeatherLocalSpace = 5;
    using nkFeatherGlobalConstructAction = 6;
    using nkFeatherGlobalDestructAction = 7;
    using nkFeatherScopeDestructAction = 8;
    using nkFeatherTempDestructAction = 9;
    
    using nkFeatherDeclFunction = 10;
    using nkFeatherDeclClass = 11;
    using nkFeatherDeclVar = 12;
    
    using nkFeatherExpCtValue = 13;
    using nkFeatherExpNull = 14;
    using nkFeatherExpStackAlloc = 15;
    using nkFeatherExpVarRef = 16;
    using nkFeatherExpFieldRef = 17;
    using nkFeatherExpFunRef = 18;
    using nkFeatherExpFunCall = 19;
    using nkFeatherExpMemLoad = 20;
    using nkFeatherExpMemStore = 21;
    using nkFeatherExpBitcast = 22;
    using nkFeatherExpConditional = 23;
    using nkFeatherExpChangeMode = 24;
    
    using nkFeatherStmtIf = 25;
    using nkFeatherStmtWhile = 26;
    using nkFeatherStmtBreak = 27;
    using nkFeatherStmtContinue = 28;
    using nkFeatherStmtReturn = 29;

    using nkSparrowModifiersNode = 30;
    
    using nkSparrowDeclSprCompilationUnit = 31;
    using nkSparrowDeclPackage = 32;
    using nkSparrowDeclSprClass = 33;
    using nkSparrowDeclSprFunction = 34;
    using nkSparrowDeclSprParameter = 35;
    using nkSparrowDeclSprVariable = 36;
    using nkSparrowDeclSprConcept = 37;
    using nkSparrowDeclGenericClass = 38;
    using nkSparrowDeclGenericFunction = 39;
    using nkSparrowDeclFriend = 40;
    using nkSparrowDeclUsing = 41;
    
    using nkSparrowExpLiteral = 42;
    using nkSparrowExpThis = 43;
    using nkSparrowExpIdentifier = 44;
    using nkSparrowExpCompoundExp = 45;
    using nkSparrowExpSprVarRef = 46;
    using nkSparrowExpFunApplication = 47;
    using nkSparrowExpOperatorCall = 48;
    using nkSparrowExpInfixExp = 49;
    using nkSparrowExpLambdaClosure = 50;
    using nkSparrowExpLambdaFunction = 51;
    using nkSparrowExpSprConditional = 52;
    using nkSparrowExpParenthesisExp = 53;
    using nkSparrowExpDeclExp = 53;
    using nkSparrowExpStarExp = 55;
    
    using nkSparrowStmtFor = 56;
    using nkSparrowStmtSprReturn = 57;
}
