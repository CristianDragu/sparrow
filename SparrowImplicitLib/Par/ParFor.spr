package Par;

import Par.Tasks;
import SL.Ranges;
import BitOper;

public concept Partitioner(x)
    if isValid(x.RangeType)
    && isValid(x.partStart())
    && isValid(x.partition(valueOfType(x.RangeType), 0))
    ;

public fun parFor(r: Range, f: AnyType) if isValid(f(r.front()))
    { parFor(r, f, DefaultPartitioner(typeOf(r))()); }

public fun parFor(r: Range, f: AnyType, part: @Partitioner)
    if isValid(f(r.front()))
{
    // Tell the partitioner that we are starting work
    part partStart;

    // Create a root task and wait until it's executed
    var range: part.RangeType = r;
    Par.spawnRootAndWait(Impl.ParForTask(range, f, part, 0));
}

class DefaultPartitioner(rangeType: Type) {
    public using RangeType = BoundedRange(rangeType);

    private var maxDepth: Int;

    public fun partStart {
        var p: Int = Par.getAvailableCoresNum;
        var depth = 1;
        while ( 2 !<<! depth < p )
            ++depth;

        maxDepth = 1 + depth;
    }

    public fun partition(r: Range, depth: Int) : RangeType * RangeType
    {
        var splitIdx = 0;
        var sz: Int = r rangeSize;
        if ( depth <= maxDepth ) {
            splitIdx = (sz+1) / 2;  // split in half
        }
        var r1 = RangeType(r, 0, splitIdx);
        var r2 = RangeType(r, splitIdx, sz-splitIdx);

        return r1 ~ r2;
    }
}

class BoundedRange(baseRangeType: Type) {
    private var baseRange: baseRangeType;
    private var count: SizeType;

    public using RetType = baseRangeType.RetType;

    public fun ctor(r: @baseRangeType) {
        baseRange ctor r;
        count = (baseRange rangeSize);
    }

    public fun ctor(r: @BoundedRange, nSkip, nTake: SizeType) {
        baseRange ctor r.baseRange;
        baseRange advance nSkip;
        count ctor nTake;
    }

    public fun isEmpty                     = count == 0 || baseRange.isEmpty();
    public fun front: RetType              = baseRange.front();
    public fun popFront                    { baseRange.popFront(); --count; }
}

package Impl {
    class ParForTask(rangeType, funcType, partType: Type) {
        var prefix: Par.TaskPrefix;
        var range: rangeType;
        var func: funcType;
        var part: @partType;
        var depth: Int;

        using RangeType = rangeType;

        fun ctor(r: rangeType, f: funcType, part: @partType, depth: Int) {
            this.range ctor r;
            this.func ctor f;
            this.part := part;
            this.depth ctor depth;
        }
        
        fun execute {
            // Check if we need to split the range
            var split = part.partition(range, depth);

            // Do we have a split?
            var splitValid = !(split._1 isEmpty) && !(split._2 isEmpty);

            if ( splitValid ) {
                // Create two new tasks for the splits
                var cont: @EmptyTask = new(EmptyTask);
                Par.setContinuation(this, cont);
                var t1: @ParForTask = allocParForTask(split._1, func, part, depth+1);
                var t2: @ParForTask = allocParForTask(split._2, func, part, depth+1);
                Par.spawn(cont, t1, t2);
            } else {
                // No more splitting; execute the function serially
                for ( val: rangeType.RetType = range ) {
                    func(val);
                }
            }
        }
    }

    public fun ParForTask(r: Range, f: AnyType, part: @Partitioner, depth: Int)
        = ParForTask(typeOf(r), typeOf(f), -@typeOf(part))(r, f, part, depth);
    public fun allocParForTask(r: Range, f: AnyType, part: @Partitioner, depth: Int)
        = new(ParForTask(typeOf(r), typeOf(f), -@typeOf(part)), r, f, part, depth);
}
