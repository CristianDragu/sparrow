package Par.TasksImpl;

import TaskPrefixOpers;
import Worker;
import Debug;
import Par.Tls;

///////////////////////////////////////////////////////////////////////////////
// Main scheduler interface

fun schedSpawn(task: TaskPtr) {
    var curDepth = task.get().depth-1;
    if[ct] ( isValidAndTrue(traceCalls) )
        cout << Depth(curDepth) << "schedSpawn(" << task.get() << ")" << endl;
    task.get() assertValid;

    // Push the task at the front of the local work queue
    (task.get() worker).work pushFront task.get();
}
fun schedWaitForAll(parent: TaskPtr, child: TaskPtr) {
    var curDepth = parent.get().depth;
    if[ct] ( isValidAndTrue(traceCalls) )
        cout << Depth(curDepth) << "schedWaitForAll(" << parent.get() << ", " << child.get() << ")" << endl;
    if ( child isSet )
        child.get() assertValid;
    parent.get() assertValid;

    schedDoWait(child, parent);
}
fun schedSpawnRootAndWait(task: TaskPtr) {
    if[ct] ( isValidAndTrue(traceCalls) )
        cout << "schedSpawnRootAndWait(" << task.get() << ")" << endl;
    task.get() assertValid;

    // Execute the root task
    executeTask(task.get());
}
fun schedEnqueue(task: TaskPtr) {
    var curDepth = task.get().depth-1;
    if[ct] ( isValidAndTrue(traceCalls) )
        cout << Depth(curDepth) << "schedEnqueue(" << task.get() << ")" << endl;
    task.get() assertValid;
}


///////////////////////////////////////////////////////////////////////////////
// Task execution logic

fun schedDoWait(toExecute, waitingTask: TaskPtr) {
    var worker: @Worker = waitingTask.get() worker;

    var curDepth = waitingTask.get().depth;
    if[ct] ( isValidAndTrue(traceCalls) )
        cout << Depth(curDepth) << "executing from queue: " << TasksPrinter(toExecute, worker.work) << endl;

    // TODO
    if ( toExecute isSet )
        worker.work pushFront toExecute.get();

    /* extract policy:
        - if given a task, execute it
        - extract tasks from the local queue (until our waitingTask is met)
        - extract tasks from the shared queue
        - steal tasks from other local queues
    */

    // Extract and execute from the queue
    while ( !(worker.work empty) ) {
        // Extract the top of the queue
        var t: TaskPtr = worker.work popFront;
        var task: @TaskPrefix = t.get();

        // Execute this task
        executeTask(task);

        // Check if we executed all the children for our waiting task
        if ( (waitingTask.get() refCount) == 1 ) {
            if[ct] ( isValidAndTrue(traceCalls) )
                cout << Depth(curDepth) << "task " << waitingTask.get() << " can continue" << endl;
            waitingTask.get() setRefCount 0;
            break;
        }
    }
    if[ct] ( isValidAndTrue(traceCalls) )
        cout << Depth(curDepth) << "remaining queue: " << TasksPrinter(TaskPtr(), worker.work) << endl;
}

// TODO
var myInnermostRunningTask: @TaskPrefix = null;

fun executeTask(task: @TaskPrefix) {
    var curDepth = task.depth-1;

    // TODO: what is this?
    //myInnermostRunningTask := task;


    // TODO: check cancellation
    if ( false ) {
        return;
    }

    // Execute the task
    if[ct] ( isValidAndTrue(traceCalls) )
        cout << Depth(curDepth) << "executing task " << task << endl;
    task.executeFn(task);

    var parent: @TaskPrefix = task.parent.get();
    if ( parent !== null ) {
        // TODO
        //tallyCompletionOfPredecesor(parent, null);
        parent decrementRefCount;
    }
}
