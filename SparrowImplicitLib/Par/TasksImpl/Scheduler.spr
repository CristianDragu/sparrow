package Par.TasksImpl;

import TaskPrefixOpers;
import Worker;
import Debug;
import Par.Tls;

///////////////////////////////////////////////////////////////////////////////
// Main scheduler interface

fun schedSpawn(task: TaskPtr) {
    var worker: @Worker = task.get() worker;

    if[ct] ( isValidAndTrue(traceCalls) )
        Tracer(worker) << "schedSpawn(" << task.get() << ")" << endl;
    task.get() assertValid;

    // Announce new work in the task system
    worker.taskSystem onTaskAvailable;

    // Push the task at the front of the local work queue
    worker.work pushFront task.get();
}
fun schedWaitForAll(parent: TaskPtr, child: TaskPtr) {
    var worker: @Worker = parent.get() worker;

    if[ct] ( isValidAndTrue(traceCalls) )
        Tracer(worker) << "schedWaitForAll(" << parent.get() << ", " << child.get() << ")" << endl;
    if ( child isSet )
        child.get() assertValid;
    parent.get() assertValid;

    // Ensure the right depth is set in the worker
    var oldDepth = worker.curDepth;
    worker.curDepth = parent.get().depth;

    parent.get() setWaitingWorker worker;

    schedDoWait(worker, child, parent);

    // Restore the old depth
    worker.curDepth = oldDepth;
}
fun schedSpawnRootAndWait(task: TaskPtr) {
    var worker: @Worker = task.get() worker;

    if[ct] ( isValidAndTrue(traceCalls) )
        Tracer(worker) << "schedSpawnRootAndWait(" << task.get() << ")" << endl;
    task.get() assertValid;

    // Ensure the right depth is set in the worker
    var oldDepth = worker.curDepth;
    worker.curDepth = 0;

    task.get() setWaitingWorker worker;

    // Execute the root task
    executeTask(task.get());

    // Restore the old depth
    worker.curDepth = oldDepth;
}
fun schedEnqueue(task: TaskPtr) {
    var worker: @Worker = task.get() worker;

    if[ct] ( isValidAndTrue(traceCalls) )
        Tracer(worker) << "schedEnqueue(" << task.get() << ")" << endl;
    task.get() assertValid;

    // Announce new work in the task system
    worker.taskSystem onTaskAvailable;

    // Enqueue the task
    worker.taskSystem.globalQueue pushFront task.get();
}


///////////////////////////////////////////////////////////////////////////////
// Task execution logic

fun schedDoWait(worker: @Worker, toExecute, waitingTask: TaskPtr) {
    if[ct] ( isValidAndTrue(traceCalls) )
        Tracer(worker)<< "work: " << TasksPrinter(toExecute, worker.work) << endl;

    using maxRetriesBeforeGoingIdle = 1;
    var numRetries = maxRetriesBeforeGoingIdle;

    /* execution policy:
        - if given a task, execute it
        - extract tasks from the local queue (from front)
        - extract tasks from the shared queue (from back)
        - steal tasks from other local queues (from back)

        - stop when our waitingTask refCount reaches 1.
    */

    while ( true ) {
        // If we don't have something to execute,
        // extract something from our local queue
        if ( toExecute isNull ) {
            // Get item from the front: most recent
            toExecute = (worker.work popFront);
        }

        // Try stealing something from global queue
        if ( toExecute isNull ) {
            // Get item from the back: FIFO style
            toExecute = (worker.taskSystem.globalQueue popBack);
            if[ct] ( isValidAndTrue(traceCalls) )
                if ( toExecute isSet )
                    Tracer(worker)<< "Found task in global queue\n";
        }
        
        // Steal work from other queues
        if ( toExecute isNull ) {
            // Try different queues until we find one we can steal from
            var numStealAttempts = 2*(worker.taskSystem numAvailableWorkers);
            for ( i = 1..numStealAttempts ) {
                // Get a queue from another worker; chose it randomly
                var otherQueue: @TaskQueue = (worker.taskSystem getRandomTaskQueue);
                // Get item from the back: try to take as much work as possible
                toExecute = (otherQueue popBack);
                if ( toExecute isSet ) {
                    // Change the worker for the stolen task
                    toExecute.get().worker = reinterpretCast(@Byte, worker);

                    if[ct] ( isValidAndTrue(traceCalls) )
                        Tracer(worker)<< "************************* Task stolen: " << toExecute.get() << "\n\n\n";

                    // Stop trying to steal
                    break;
                }
            }
        }

        // Try to execute what we've selected
        if ( toExecute isSet ) {
            toExecute.get() executeTask;
            numRetries = maxRetriesBeforeGoingIdle;
        }

        // Check if we executed all the children for our waiting task
        // This is our terminating condition
        if ( (waitingTask isSet) && (waitingTask.get() refCount) == 1 ) {
            waitingTask.get() setRefCount 0;
            break;
        }

        if ( toExecute isNull ) {
            // Nothing to execute
            if ( numRetries == 0 ) {
                worker goIdle;
                numRetries = maxRetriesBeforeGoingIdle;
            }
            else {
                // Try several times to steal tasks
                // Going to sleep is more expensive
                Par.sleep(0);
            }
        } else {
            toExecute.reset;
            --numRetries;            
        }
    }

    // Trace remaining work
    if[ct] ( isValidAndTrue(traceCalls) )
        Tracer(worker) << "task " << waitingTask.get() << " can continue; remaining work: " << TasksPrinter(TaskPtr(), worker.work) << endl;
}

fun executeTask(task: @TaskPrefix) {
    var worker: @Worker = task worker;

    // TODO: check cancellation
    if ( false ) {
        return;
    }

    // Execute the task
    if[ct] ( isValidAndTrue(traceCalls) )
        Tracer(worker) << "executing task " << task << endl;
    task.executeFn(task);

    var parent: @TaskPrefix = task.parent.get();
    if ( parent !== null ) {
        var cnt = parent decrementRefCount;

        // If the reference count reaches zero, make sure the parent task is awake
        if ( cnt == 0 ) {
            var ww: @Worker = parent waitingWorker;
            if ( ww != worker && ww !== null ) {
                ww tryWakeUp;
            }
        }
    }
}
