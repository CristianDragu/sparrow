module Par.TasksImpl.TaskPrefix;

import Par.Atomic;
import SL.Ptr;

using TaskPtr = TaskPrefix Ptr;

class TaskPrefix {
    //! The function to be called to execute the task (along with its 'this' offset)
    private var executeFn: FunctionPtr(Null rt, @TaskPrefix);
    private var taskOffset: DiffType;

    //! The parent task of this task; null for root tasks
    private var parent: TaskPrefix Ptr;
    //! The number of children + waits for this task
    private var refCount: Int Atomic;
    //! The continuation of this task
    private var cont: TaskPrefix Ptr;

    //! The worker that this task belongs to
    //! Use casts to avoid direct dependency
    private var worker: Byte Ptr;

    //! The worker that waits for this task to finish
    //! Use casts to avoid direct dependency
    private var waitingWorker: Byte Ptr;

    //! Used for chaining the tasks in the task queue
    private var prev: TaskPrefix Ptr;
    private var next: TaskPrefix Ptr;

    //! Used for debugging
    private var desc: String;
    private var depth: Int;
}

fun >>(t: @TaskPrefix, os: @OutStream) {
    if ( t === null )
        os << "<null>";
    else {
        if ( !(t.desc isEmpty) ) {
            os << '"' << t.desc << '"';
        }
        os << '<' << mkStreamRefWrapper(t) << ", " << (t.depth) << "," << (t.refCount load) << '>';
    }
}
