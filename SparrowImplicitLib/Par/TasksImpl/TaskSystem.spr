package Par.TasksImpl;

import InternalWorkerThread;
import Par.Thread;
import SL.Ptr;
import SL.Vector;
import Assert;

class TaskSystem {
    fun ctor {
    }

    fun dtor {
    }

    var globalQueue: TaskQueue;
    var workers: (Worker Ptr) Vector;

    private var threads: (Par.Thread Ptr) Vector;
}

var globalTaskSystem: TaskSystem Ptr;

fun initTaskSystem(numWorkers: UInt = 0) {
    // Create the task system object
    assert(globalTaskSystem isNull);
    globalTaskSystem = new(TaskSystem);

    // Create the required threads
    if ( numWorkers == 0 )
        numWorkers = getAvailableCoresNum();
    numWorkers = 7;
    for ( i=0..numWorkers ) {
        var worker = globalTaskSystem.get() createWorker;
        var p: Par.Thread Ptr = new(Par.Thread, InternalWorkerThread(worker));
        globalTaskSystem.get().threads.pushBack(p);

        // Just to keep the console clean
        // TODO: remove this
        Par.sleep(1);
    }
}

fun getInitTaskSystem: TaskSystem Ptr {
    // TODO: Make sure this is initialized only once
    if ( globalTaskSystem isNull )
        initTaskSystem;
    return globalTaskSystem;
}

fun createWorker(ts: TaskSystem Ptr): Worker Ptr {
    var id: Int = ts.get().workers size;
    var p: Worker Ptr = new(Worker, ts.get(), id);
    ts.get().workers.pushBack(p);
    return p;
}

// TODO: make it random
var cnt: Int = 0;

fun getRandomTaskQueue(ts: @TaskSystem): @TaskQueue {
    // TODO: make the selection truly random
    var worker: Worker Ptr = ts.workers(++cnt % (ts.workers size));
    return worker.get().work;
}
