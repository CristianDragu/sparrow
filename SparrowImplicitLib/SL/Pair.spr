class[rtct] Pair(firstType: Type, secondType: Type)
{
    using FirstType = firstType;
    using SecondType = secondType;

    var first: FirstType;
    var second: SecondType;

    fun _1 = first;
    fun _2 = second;

    fun ctor(fst: FirstType, snd: SecondType)
    {
        this.first ctor fst;
        this.second ctor snd;
    }
    fun ctor(other: AnyType) // Conversion ctor
    {
        this.first ctor other._1;
        this.second ctor other._2;
    }

    fun >> (os: @OutStream)
    {
        os << '(' << first << ", " << second << ')';
    }
    if[ct] ( isValid(#$FirstType < #$FirstType) && isValid(#$SecondType < #$SecondType) )
    fun <(other: @Pair): Bool
    {
        if ( other.first < first )
            return false;
        if ( first < other.first )
            return true;
        if ( second < other.second )
            return true;
        return false;
    }
}

fun[rtct] mkPair(f, s: AnyType) = Pair(typeOf(f), typeOf(s))(f, s);

class[rtct] MakePair(firstType: Type, secondType: Type)
{
    fun ()(fst: firstType, snd: secondType): Pair(firstType, secondType)
    {
        return Pair(firstType, secondType)(fst, snd);
    }
}

class[rtct] PairFirst(pairType: Type)
{
    fun ()(pair: @pairType): @typeOf(pair.first)
    {
        return pair.first;
    }
}

class[rtct] PairSecond(pairType: Type)
{
    fun ()(pair: @pairType): @typeOf(pair.second)
    {
        return pair.second;
    }
}

fun[ctGeneric] *(t1, t2: Type): Type = Pair(t1, t2);
fun ~(a,b: AnyType) = mkPair(a,b);

