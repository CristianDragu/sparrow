import NewDelete;
import Meta.ASTNodes;

public class[rtct] Ptr(type: Type)
{
    public using ValueType = type;
    
    public fun ctor                    = ptr := null;
    public fun ctor(other: Ptr)        = ptr := other.ptr;
    public fun[convert] ctor(ref: @ValueType)   = ptr := ref;

    public fun get: @ValueType         = ptr;
    public fun isNull                  = ptr === null;
    public fun isSet                   = ptr !== null;
    
    public fun reset                   = ptr := null;
    public fun reset(ref: @ValueType)  = ptr := ref;
    public fun release                 { delete(ptr); }
    
    public fun swap(other: @Ptr)
    {
        var t: @ValueType = ptr;
        ptr := other.ptr;
        other.ptr := t;
    }
    
    public fun =(other: Ptr)           = ptr := other.ptr;
    public fun =(ref: @ValueType)      = ptr := ref;
    
    public fun ==(other: Ptr)          = ptr === other.ptr;
    public fun < (other: Ptr)          = ptrDiff(reinterpretCast(@Byte, this.ptr), reinterpretCast(@Byte, other.ptr)) < DiffType(0);

    public fun >>(os: @OutStream) if isValid(os << #$ValueType)
    {
        if ( ptr !== null )
            os << "Ptr(" << ptr << ")";
        else
            os << "Ptr(null)";
        os << flush;
    }

    private var ptr: @ValueType;
}

public fun[rtct] reinterpretPtr(t: Type, ptr: AnyType): Ptr(t) //if isValid(p.isNull()) && isValid(p.get())
{
    return Ptr(t)(reinterpretCast(@t, ptr.get()));
}


public fun[rtct, macro] ->(base, id: Meta.AstNode): Meta.AstNode
{
    using Meta.*;
    using Meta.SprFrontend.*;
    using Meta.Feather.*;

    // Expand to: <base>.get().<id>
    var loc = base.location();
    var dotGet = mkInfixOp(loc, "__dot__", base, mkIdentifier(loc, "get"));
    var getCall = mkInfixOp(loc, "__fapp__", dotGet, mkNodeList(loc));
    return mkInfixOp(loc, "__dot__", getCall, id);
}
public using oper_precedence_-> = oper_precedence___dot__;
