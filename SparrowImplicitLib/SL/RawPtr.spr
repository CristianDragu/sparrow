public class[rtct] RawPtr(valueType: Type)
{
    public using ValueType = valueType;

    public fun[static] fromRef(ptr: @ValueType): RawPtr
    {
        var res: RawPtr;
        res.ptr := ptr;
        return res;
    }

    public fun[static] fromBytePtr(ptr: @Byte): RawPtr
    {
        var res: RawPtr;
        res.ptr := reinterpretCast(@ValueType, ptr);
        return res;
    }

    public fun[static] alloc(num: SizeType): RawPtr
    {
        var res: RawPtr;
        res.ptr := reinterpretCast(@ValueType, malloc(num * sizeOf(ValueType)));
        return res;
    }

    public fun value: @ValueType               = ptr;
    public fun advance: RawPtr                 = RawPtr.fromBytePtr(ptrAdd(bytePtr(), sizeOf(ValueType)));
    public fun advance(n: DiffType): RawPtr    = RawPtr.fromBytePtr(ptrAdd(bytePtr(), n * DiffType(sizeOf(ValueType))));
    public fun diff(other: RawPtr): DiffType   = DiffType(ptrDiff(bytePtr(), other.bytePtr()) / DiffType(sizeOf(ValueType)));

    public fun isNull: Bool            = ptr === null;
    public fun isSet                   = ptr !== null;

    public fun bytePtr: @Byte          = reinterpretCast(@Byte, ptr);

    public fun reallocPtr(n: SizeType)
    {
        ptr := reinterpretCast(@ValueType, realloc(bytePtr(), n * sizeOf(ValueType)));
    }

    public fun freePtr
    {
        if ( isSet() )
            free(bytePtr());
    }

    public fun swap(other: @RawPtr)
    {
        var t: @ValueType = ptr;
        ptr := other.ptr;
        other.ptr := t;
    }
    
    public fun =(other: RawPtr)        { ptr := other.ptr; }
    
    public fun ==(other: RawPtr)       = ptr === other.ptr;
    public fun < (other: RawPtr)       = ptrDiff(this.bytePtr(), other.bytePtr()) < DiffType(0);

    public fun >>(os: @OutStream)
    {
        os << "RawPtr(" << mkStreamRefWrapper(bytePtr()) << ")";
    }

    private var ptr: @ValueType;
}
