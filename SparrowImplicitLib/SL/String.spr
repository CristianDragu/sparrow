import SprCore.StringRef;
import Vector;  // For Range definition
import ContiguousMemoryRange;
import RawPtr;
import Algorithms;

// TODO: Make sure that we have the same performance for Strings that we would have for basic char arrays
// TODO: Can we implement this in terms of Vector?
// TODO: Can we implement a VectorDetail(Type, InnerSpace), and implement fun Vector(type) = VectorBase(type, 0)

/// String class that has ownership of the characters
public class[rtct] String
{
    public using ValueType = Char;
    public using ValuePassType = Char;
    public using RangeType = ContiguousMemoryRange(Char);

    public fun ctor
    {
        begin.ctor();
        end.ctor();
        endOfStore.ctor();
    }
    public fun ctor(size: SizeType)
    {
        begin       ctor PtrType.alloc(size+1);
        end         ctor begin.advance(DiffType(size));
        endOfStore  ctor end;
        end.value() = Char(0);
    }
    public fun ctor(count: SizeType, ch: Char)
    {
        ctor(count);
        memset(begin.bytePtr(), reinterpretCast(@Byte, ch), count);
    }
    public fun ctor(other: @String)
    {
        var size = other size;
        ctor(size);
        memcpy(begin.bytePtr(), other.begin.bytePtr(), size);
    }
    public fun[convert] ctor(other: @StringRef)
    {
        var size = other size;
        ctor(size);
        memcpy(begin.bytePtr(), other.begin, size);
    }
    public fun ctor(begin, end: PtrType)
    {
        var size = end.diff(begin);
        ctor(size);
        memcpy(this.begin.bytePtr(), begin.bytePtr(), size);
    }
    public fun ctor(range: Range) if typeOf(range) != String
    {
        ctor(rangeSize(range));
        var i=0;
        for ( ch = range )
        {
            begin.advance(DiffType(i++)).value() = ch;
        }
    }

    public fun[rt] ctorFromCt(src: String ct)
    {
        this.ctor(src.asStringRef());
    }

    public fun dtor
    {
        begin.freePtr();
    }

    public fun swap(other: @String)
    {
        this.begin      swap    other.begin;
        this.end        swap    other.end;
        this.endOfStore swap    other.endOfStore;
    }

    public fun asStringRef             = StringRef(begin.bytePtr(), end.bytePtr());


    public fun size: SizeType        = end.diff(begin);
    public fun isEmpty                 = begin == end;
    public fun capacity: SizeType    = endOfStore.diff(begin);

    public fun at(index: SizeType)     = begin.advance(DiffType(index)).value();
    public fun ()(index: SizeType)     = begin.advance(DiffType(index)).value();
    public fun front                   = begin.value();
    public fun back                    = end.advance(-1).value();
    public fun all                     = RangeType(begin, end);
    public fun subrange(index: SizeType, num: SizeType): RangeType
                                = RangeType(begin.advance(DiffType(index)), begin.advance(DiffType(index + num)));

    public fun pushBack(value: Char)
    {
        if ( end == endOfStore )
        {
            var t = 2 * capacity();

            if ( t < 2 )
                t = 2;
            reserve(t);
        }
        end.value().ctor(value);
        end = end.advance();
    }
    public fun +=(value: Char) { pushBack(value); }

    public fun popBack()
    {
        end = end advance -1;
        end.value() dtor;
    }

    public fun resize(n: SizeType)
    {
        var oldSize = size();

        if ( n == oldSize )
            return;

        if ( n < oldSize )
        {
            var newEnd = begin.advance(DiffType(n));

            while ( end != newEnd )
            {
                end = end.advance(-1);
                end.value().dtor();
            }
        }
        else
        {
            reserve(n);

            var newEnd = begin.advance(DiffType(n));

            while ( end != newEnd )
            {
                end.value().ctor();
                end = end.advance();
            }
        }
    }

    public fun reserve(n: SizeType)
    {
        var curCapacity = capacity();

        if ( n <= curCapacity )
            return;

        if ( n < initialCapacity )
            n = initialCapacity;
        if ( n <growthFactor*curCapacity )
            n = SizeType(growthFactor*curCapacity);

        var curSize = size();

        begin.reallocPtr(n);
        end = begin.advance(DiffType(curSize));
        endOfStore = begin.advance(DiffType(n));
    }

    public fun clear()
    {
        remove(RangeType(begin, end));
    }

    public fun insertBefore(value: ValuePassType, pos: RangeType)
    {
        var posCount = pos.frontPtr().diff(begin);

        reserve(size() + 1);

        var p = end.advance(-1);
        var q = begin.advance(posCount - DiffType(1));

        while ( p != q ; p = p.advance(-1) )
        {
            p.advance().value().ctor(p.value());
            p.value().dtor();
        }
        p.advance().value().ctor(value);
        end = end.advance();
    }

    public fun insertBefore(range: Range, pos: RangeType)
    {
        var n = range.size();
        var index = pos.frontPtr().diff(begin);

        reserve(size() + n);

        var p = end.advance(-1);
        var q = begin.advance(index - DiffType(1));

        while ( p != q ; p = p.advance(-1) )
        {
            p.advance(DiffType(n)).value().ctor(p.value());
            p.value().dtor();
        }
        p = p.advance();
        while ( !range.isEmpty() )
        {
            p.value().ctor(range.front());
            p = p.advance();
            range.popFront();
        }
        end = end.advance(DiffType(n));
    }

    public fun insertAfter(value: ValuePassType, pos: RangeType)
    {
        insertBefore(value, RangeType(pos.backPtr(), end));
    }

    public fun insertAfter(range: Range, pos: RangeType)
    {
        insertBefore(range, RangeType(pos.backPtr(), end));
    }

    public fun append(range: Range)
    {
        insertBefore(range, RangeType(end, end));
    }
    public fun append(value: ValuePassType)
    {
        insertBefore(value, RangeType(end, end));
    }

    public fun remove(range: RangeType)
    {
        var rSize = range.size();
        var rBegin = range.frontPtr();
        var rEnd = rBegin.advance(DiffType(rSize));

        while ( rEnd != end )
        {
            rBegin.value().dtor();
            rBegin.value().ctor(rEnd.value());
            rBegin = rBegin.advance();
            rEnd = rEnd.advance();
        }
        end = rBegin;
    }

    public fun remove(index: SizeType)
    {
        var r = all();

        r.popFront(index);
        r.popBack(size() - index - 1);
        remove(r);
    }

    public fun =(other: @String): @String
    {
        var tmp = other;
        tmp.swap(this);
        return this;
    }

    public fun ==(other: @String): Bool
    {
        if ( size() != other.size() )
            return false;

        var i: SizeType = 0;
        var s = size();

        while ( i < s ; i = i + 1 )
        {
            if ( at(i) != other.at(i) )
                return false;
        }
        return true;
    }

    public fun !=(other: @String): Bool = !(this == other);

    public fun assign(range: Range)
    {
        clear();
        for ( v = range )
            pushBack(v);
    }

    public fun >>(os: @OutStream)
    {
        os << asStringRef();
    }

    private var[ct,static] initialCapacity: SizeType = 16;
    private var[ct,static] growthFactor = 1.5;
    private using PtrType = RawPtr(Char);

    private var begin: PtrType;
    private var end: PtrType;
    private var endOfStore: PtrType;
}

// TODO
fun[autoCt] + (x,y: String): String
{
    var sz1 = x.size();
    var sz2 = y.size();
    var res: String = sz1 + sz2;
    memcpy(res.begin.bytePtr(), x.begin.bytePtr(), sz1);
    memcpy(res.begin.advance(sz1).bytePtr(), y.begin.bytePtr(), sz2);
    return res;
}

fun[autoCt] + (x: String, y: StringRef): String
{
    var sz1 = x.size();
    var sz2 = y.size();
    var res: String = sz1 + sz2;
    memcpy(res.begin.bytePtr(), x.begin.bytePtr(), sz1);
    memcpy(res.begin.advance(sz1).bytePtr(), y.begin, sz2);
    return res;
}

//fun[autoCt] + (x: String, y: Char): String
//{
//    var sz1 = x.size();
//    var sz2 = sizeOf(y);
//    var res: String = sz1 + sz2;
//    memcpy(res.begin, x.begin, sz1);
//    memcpy(ptrAdd(res.begin, sz1), reinterpretCast(@Byte, y), sz2);

//    return res;
//}


public fun[rtct] intToString(x: Int): String
{
    var buf: static_buffer(12);
    StringImpl.intToCString(x, reinterpretCast(@Char, buf));
    return String(StringRef.fromCString(reinterpretCast(@Char, buf)));
}
public fun[rtct] ulongToString(x: ULong): String
{
    var buf: static_buffer(16);
    StringImpl.ulongToCString(x, reinterpretCast(@Char, buf));
    return String(StringRef.fromCString(reinterpretCast(@Char, buf)));
}

// TODO

public class[rtct] StringOutputStream
{
    private var result: String;

    public fun <<<(s: @String)       { result.append(s.all()); }
    public fun <<<(s: @StringRef)    { result.append(ContiguousMemoryRange(Char)(RawPtr(Char).fromBytePtr(s.begin), RawPtr(Char).fromBytePtr(s.end))); }
    public fun <<<(x: Char)          { result.append(x); }
    public fun <<<(x: Int)           { result.append(intToString(x).all()); }
    public fun <<<(x: ULong)         { result.append(ulongToString(x).all()); }
    public fun <<<(x: Double)        { result.append(ulongToString(ULong(x)).all()); } // Not properly supported
}

package StringImpl
{
    fun[rtct, native("_Int_to_CString")] intToCString(x: Int, buffer: @Char);
    fun[rtct, native("_ULong_to_CString")] ulongToCString(x: ULong, buffer: @Char);
}
