import Externals;

/// String class that DOES NOT have ownership of the characters; it simply refers to another string
public class[rtct, native("StringRef")] StringRef
{
    public var begin: @Byte;
    public var end: @Byte;

    public fun ctor(size: SizeType)
    {
        begin := malloc(size + 1);
        end := ptrAdd(begin, size);
        end = Byte(0);
    }
    public fun ctor(other: StringRef)
    {
        begin := other.begin;
        end := other.end;
    }
    public fun ctor(begin, end: @Byte)
    {
        this.begin := begin;
        this.end := end;
    }
    public fun dtor {}

    public fun size: SizeType = ptrDiff(end, begin);
    public fun isEmpty: Bool = begin == end;

    public fun at(index: SizeType): Char   = reinterpretCast(@Char, ptrAdd(begin, index));
    public fun ()(index: SizeType): Char   = reinterpretCast(@Char, ptrAdd(begin, index));
    public fun front: Char                 = reinterpretCast(@Char, begin);
    public fun back: Char                  = reinterpretCast(@Char, ptrAdd(end, -1));

    public fun cStr(): @Char = reinterpretCast(@Char, begin);

    public fun[autoCt, static, native("_String_fromCString")] fromCString(s: @Char): StringRef
    {
        var len = cStringLen(s);
        var res: StringRef;
        res.begin := reinterpretCast(@Byte, s);
        res.end := ptrAdd(res.begin, len);
        return res;
    }

    private fun[static] cStringLen(s: @Char): SizeType
    {
        var p: @Byte;
        p := reinterpretCast(@Byte, s);
        var len: SizeType = 0;
        while ( p != Byte(0) ; p:=ptrAdd(p, 1) )
            len = len+1;
        return len;
    }
    
    public fun = (src: StringRef): @StringRef
    {
        begin := src.begin;
        end := src.end;

        return this;
    }

    public fun == (other: StringRef): Bool
    {
        var s = size();
        if ( s != other.size() ) return false;
        var i: SizeType = 0;
        while ( i<s ; i+=1 )
            if ( at(i) != other.at(i) ) return false;
        return true;

        //return 0 == strcmp(begin, other.begin);
    }
}

public fun[autoCt] + (x,y: StringRef): StringRef
{
    var sz1 = x.size();
    var sz2 = y.size();
    var res: StringRef = sz1 + sz2;
    memcpy(res.begin, x.begin, sz1);
    memcpy(ptrAdd(res.begin, sz1), y.begin, sz2);
    return res;
}

public fun[autoCt] + (x: StringRef, y: Char): StringRef
{
    var sz1 = x.size();
    var sz2 = 1;
    var res: StringRef = sz1 + sz2;
    memcpy(res.begin, x.begin, sz1);
    memcpy(ptrAdd(res.begin, sz1), reinterpretCast(@Byte, y), sz2);

    return res;
}
