
import Basic;

package TypeOp
{
    fun[ct, native("$typeDescription")] description(t: Type): StringRef;
    fun[ct, native("$typeHasStorage")] hasStorage(t: Type): Bool;
    fun[ct, native("$typeMode")] mode(t: Type): Int;    // 0=unspecified, 1=rt, 2=ct, 3=rtct
    fun[ct, native("$typeCanBeUsedAtCt")] canBeUsedAtCt(t: Type): Bool;
    fun[ct, native("$typeCanBeUsedAtRt")] canBeUsedAtRt(t: Type): Bool;
    fun[ct, native("$typeNumRef")] numRef(t: Type): Int;
    fun[ct, native("$typeChangeMode")] changeMode(t: Type, mode: Int): Type;
    fun[ct, native("$typeChangeRefCount")] changeRefCount(t: Type, numRef: Int): Type;

    fun[ctGeneric] isRef(t: Type) = 0<numRef(t);
    fun[ctGeneric] addRef(t: Type) = changeRefCount(t, numRef(t)+1);
    fun[ctGeneric] removeRef(t: Type) = ife(isRef(t), changeRefCount(t, numRef(t)-1), t);
    fun[ctGeneric] removeAllRef(t: Type) = changeRefCount(t, 0);
    fun[ctGeneric] atLeastOneRef(t: Type): Type = ife(isRef(t), t, addRef(t));
}

/// Add reference operator
fun[ct, native("$typeAddRef")] pre_@ (t: Type): Type;
//fun[ctGeneric] pre_@ (t: Type) = TypeOp.addRef(t);
/// Remove reference operator
fun[ctGeneric] pre_-@ (t: Type) = TypeOp.removeRef(t);
/// Operator to ensure at least one refenrence
fun[ctGeneric] pre_!@ (t: Type) = TypeOp.atLeastOneRef(t);

/// Comparison between types
fun[ct, native("$typeEQ")] == (x, y: Type): Bool;

fun[ct, native("$ct")] ct(t: Type): Type;
fun[ct, native("$rt")] rt(t: Type): Type;

fun[ct, native("$convertsTo")] convertsTo(src, dest: Type): Bool;
fun[ct, native("$staticBuffer")] static_buffer(n: SizeType): Type;
fun[ct, native("$commonType")] commonType(t, u: Type): Type;

/// Concept that is satisfied by any type
concept AnyType(x); // Always true

/// Gets an object of the given type
fun[rtct] valueOfType(t: Type): t;
fun[rtct] #$(t: Type): t;

