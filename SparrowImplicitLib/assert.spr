import os = os;
import meta.astNodes(AstNode, SprFrontend, Feather, astEval);

// using debugMode = true;

fun[rtct, macro] assert(cond: CompilerAstNode): CompilerAstNode
{
    using SprFrontend.*;
    using Feather.*;

    var cond2: AstNode = cond;
    if ( !isValidAndTrue(debugMode) )
        return Feather.mkNop(cond2.location()).asCompilerAstNode;

    var loc = cond2.location();
    var filename = loc.sourceCode.filename();
    var lineNum: Int = loc.startLineNo;
    var args = mkNodeList(loc);
    addToNodeList(args, mkStringLiteral(loc, loc.getCorrespondingCode()));
    addToNodeList(args, mkStringLiteral(loc, filename));
    addToNodeList(args, mkIntLiteral(loc, lineNum));
    var failureCall = mkFunApplication(loc, mkIdentifier(loc, "assertionFailure"), args);
    var res = mkIf(loc, mkPrefixOp(loc, "!", mkParenthesisExp(loc, cond2)), failureCall, AstNode());
    return res.asCompilerAstNode;
}

fun[rtct, macro] verify(cond: CompilerAstNode): CompilerAstNode
{
    using SprFrontend.*;
    using Feather.*;

    if ( !isValidAndTrue(debugMode) )
        return cond;

    var cond2: AstNode = cond;
    var loc = cond2.location();
    var filename = loc.sourceCode.filename();
    var lineNum: Int = loc.startLineNo;
    var args = mkNodeList(loc);
    addToNodeList(args, mkStringLiteral(loc, loc.getCorrespondingCode()));
    addToNodeList(args, mkStringLiteral(loc, filename));
    addToNodeList(args, mkIntLiteral(loc, lineNum));
    var failureCall = mkFunApplication(loc, mkIdentifier(loc, "assertionFailure"), args);
    return mkIf(loc, mkPrefixOp(loc, "!", mkParenthesisExp(loc, cond2)), failureCall, AstNode()).asCompilerAstNode;
}

fun[rtct] assertionFailure(message: StringRef, filename: StringRef, lineNum: UInt)
{
    cout << "Assertion failure: " << message << endl;
    if ( !filename.isEmpty() )
    {
        cout << "at " << filename << " line " << lineNum;
    }
    cout << flush << endl;
    os.exit(-1);
}

