import meta.featherNodes, meta.sparrowNodes, meta.nodeKinds;
import std.vector, std.algorithms, std.string;

/**
 * Helper used to check a pre-/post- condition in debug environment
 *
 * This will check if the given expression is false, and if so, will generate
 * an error message and continue. This will only happen if DEBUG is defined and
 * true. Otherwise, it will expand to nothing.
 *
 * If DEBUG is not set, this will not evaluate the expression.
 *
 * @param cond      The condition we need to test
 * @param message   Optional message to be displayed if the check fails
 */
fun[rtct, macro] assert(cond: AstNode, message: AstNode = AstNode()): AstNode
{
    if ( !isValidAndTrue(DEBUG) )
        return mkNop(cond location);

    return assertMacroBody(cond, message);
}

/**
 * Helper used to check a pre-/post- condition in debug environment
 *
 * This is similar to assert, but it will evaluate the expression even if DEBUG
 * is not set. If DEBUG is not set, will will not check the expression.
 *
 * @param cond      The condition we need to test
 * @param message   Optional message to be displayed if the check fails
 */
fun[rtct, macro] verify(cond: AstNode, message: AstNode = AstNode()): AstNode
{
    if ( !isValidAndTrue(DEBUG) )
        return cond;
    return assertMacroBody(cond, message);
}

private fun[ct] nodeCompare(l,r: AstNode) = (l location) < (r location);

/// Macro that creates the expansion of the assert/verify
private fun[ct] assertMacroBody(cond, message: AstNode): AstNode {
    // Extract information about the assert condition
    var loc = cond location;
    var filename = loc.sourceCode filename;
    var lineNum: Int = loc.start.line;

    // Extract the list of variables directly appearing the the expression
    var varsList: Vector(AstNode);
    extractVars(cond, varsList);

    // Sort all the variables by location
    sort(varsList.all, \nodeCompare);

    // Now start creating the print body, in case the expression check fails
    var prints: Vector(AstNode);
    addPrint(loc, prints, mkStringLiteral(loc, filename));
    addPrint(loc, prints, mkCharLiteral(loc, '('));
    addPrint(loc, prints, mkIntLiteral(loc, lineNum));
    addPrint(loc, prints, mkStringLiteral(loc, "): assertion failure: check "));

    // Build the annotated expression string
    // Walk over the list of variables, and if possible add the var value
    // Print all the expression string in between
    var expr: String = loc getCorrespondingCode;
    var lastIdx = 0;
    for ( i = 0..varsList.size ) {
        var v = varsList(i);
        var vl = v location;
        if ( vl.end.line != loc.start.line )
            break;  // Stop expanding variables when we are going on another line

        var endPos = vl.end.col - loc.start.col;
        if ( endPos != lastIdx ) {
            // Print the expression sting up until (and containing) the var
            var exprPart = expr.subrange(lastIdx, endPos-lastIdx);
            addPrint(loc, prints, mkStringLiteral(loc, exprPart));

            // Add a block for printing the value of the write
            // Ensure that this is printable
            var argsToEval = mkNodeList(loc);
            addToNodeList(argsToEval, mkInfixOp(loc, "<<", mkIdentifier(loc, "cout"), v clone));
            var cond = mkFunApplication(loc, mkIdentifier(loc, "isValid"), argsToEval);
            // if body
            var varPrints: AstNode Vector;
            addPrint(loc, varPrints, mkStringLiteral(loc, "[="));
            addPrint(loc, varPrints, v clone);
            addPrint(loc, varPrints, mkCharLiteral(loc, ']'));
            var varPrintsBlock = mkLocalSpace(loc, varPrints.all);
            // if statement
            prints += mkIf(loc, cond, varPrintsBlock, AstNode(), true);
        }
        lastIdx = Int(endPos);
    }
    // Write the last part of the expression (if any)
    var sz = expr size;
    if ( lastIdx < sz ) {
        var exprPart = expr.subrange(lastIdx, sz-lastIdx);
        addPrint(loc, prints, mkStringLiteral(loc, exprPart));
    }

    // Now, the last part of the printing
    addPrint(loc, prints, mkStringLiteral(loc, " has failed"));
    if ( message isSet ) {
        addPrint(loc, prints, mkStringLiteral(loc, ": "));
        addPrint(loc, prints, message);
    }
    addPrint(loc, prints, mkStringLiteral(loc, "\n"));

    var printsBlock = mkLocalSpace(loc, prints.all);

    // Build the resulting code:
    // if ( !cond ) <printsBlock>
    var args = mkNodeList(loc);
    addToNodeList(args, mkStringLiteral(loc, loc getCorrespondingCode));
    addToNodeList(args, mkStringLiteral(loc, filename));
    addToNodeList(args, mkIntLiteral(loc, lineNum));
    if ( message isSet )
        addToNodeList(args, message);
    var res = mkIf(loc, mkPrefixOp(loc, "!", mkParenthesisExp(loc, cond)), printsBlock, AstNode());
    return res;
}

/// Adds a print statement node to the destination vector
private fun[ct] addPrint(loc: Location, dest: @Vector(AstNode), toPrint: AstNode) {
    dest += mkInfixOp(loc, "<<", mkIdentifier(loc, "cout"), toPrint);
}

/// Extract all the variables from the given node
private fun[ct] extractVars(node: AstNode, varsList: @Vector(AstNode)) {
    var nk = node nodeKind;
    if ( nk == nkSparrowExpIdentifier ) {
        var exp = node explanation;
        if ( (exp isSet) && (exp nodeKind) == nkFeatherExpVarRef ) {
            varsList += node;
        }
    }
    else {
        for ( child = node children )
            if ( child isSet )
                extractVars(child, varsList);
    }
}
