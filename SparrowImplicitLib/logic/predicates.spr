module logic.predicates;

import[public] lRef;
import std.function;

/// Concept describing the type of a predicate: anything that can be called and evaluates to Bool
concept PredicateType(x)
    if typeOf(x()) == Bool;

/// Basic implementation of a predicate with type erasure
/// We store the actual predicate function as a Function object that takes no parameters and returns Bool
/// Provides implicit conversion from any predicate
class Predicate
{
    using arity = 0;

    fun[convert] ctor(pred: @PredicateType)
    {
        predObj ctor pred;
    }
    fun isNull = predObj.isNull();
    fun isSet = predObj.isSet();

    fun (): Bool = predObj();

    fun >>(os: @OutStream) { os << "Pred-"<<predObj; }
    var predObj: Function(Bool);
}


/// Logic equality: equality test + inference
fun eq(l, r: @AnyType) = Impl.mkEq(mkValOrRef(l), mkValOrRef(r));
fun /=/(l, r: @AnyType) = Impl.mkEq(mkValOrRef(l), mkValOrRef(r));

// Assignment: used for native functions instead of unification
fun =/(out: @AnyType, in: AnyType): Bool if -@typeOf(out) == -@typeOf(in)
{
    out = in;
    return true;
}

using oper_precedence_/=/ = oper_precedence_== + 1;
using oper_precedence_=/ = oper_precedence_== + 1;
//setOperPrecedence("/=/", getOperPrecedence("==") + 1);
//setOperPrecedence("=/", getOperPrecedence("==") + 1);



/// Logic Disjunction
fun[rtct] ||(l, r: @PredicateType) = OrRelation(-@typeOf(l), -@typeOf(r))(l, r);

/// Logic Conjunction
fun[rtct] &&(l, r: @PredicateType) = AndRelation(-@typeOf(l), -@typeOf(r))(l, r);

/// Relation that always returns false
fun mkFalse = LFalse();
/// Relation that always returns true
fun mkTrue = LTrue();


class UnifyLR(leftType, rightType: Type) if ValWrapper(#$leftType) && ValWrapper(#$rightType)
{
    using ValueType = Bool;
    using ValuePassType = Bool;

    fun ctor(l: @leftType, r: @rightType)
    {
        this._leftVal ctor l;
        this._rightVal ctor r;
        _coEntryPt ctor 0;
        if[ct] ( isValid(logicDebug) )
            cout << "UnifyLR.ctor: " << this << "\n";
    }

    fun ctor(other: @UnifyLR)
    {
        this._leftVal ctor other._leftVal;
        this._rightVal ctor other._rightVal;
        this._coEntryPt ctor other._coEntryPt;
        if[ct] ( isValid(logicDebug) )
            cout << "UnifyLR.copy ctor: " << this << "\n";
    }

    fun dtor
    {
        if[ct] ( isValid(logicDebug) )
            cout << "UnifyLR.dtor: " << this << "\n";
    }

    fun (): Bool
    {
        //cout << "UnifyLR.(): ltype=" << TypeOp.description(leftType) << ", rtype=" << TypeOp.description(rightType) << "\n" << flush;
        if[ct] ( isValid(logicDebug) )
            cout << "UnifyLR.(): " << this << "\n";
        if ( _coEntryPt == 0 )   // Never called before
        {
            if ( _leftVal.isNull() && _rightVal.isNull() )
            {
                // Cannot unify two undefined references
                _coEntryPt = -1;
                return false;
            }
            if ( _leftVal isSet )
            {
                if ( _rightVal isSet )
                {
                    _coEntryPt = -1; // Nothing more to do here
                    if[ct] ( isValid(logicDebug) )
                        cout << "UnifyLR.(), checking equality: " << _leftVal << "==" << _rightVal << "\n";
                    var res = _leftVal.get() == _rightVal.get();
                    return res;
                }
                if[ct] ( LRefType(#$rightType) && isValid(_rightVal = _leftVal.get()) )
                {
                    _rightVal = _leftVal.get();
                    _coEntryPt = 1;
                    if[ct] ( isValid(logicDebug) )
                        cout << "Unify, assigning " << _leftVal.get() << " to right side => " << this << endl;
                    return true;
                }
                _coEntryPt = -1;
                return false;
            }
            else
            {
                if[ct] ( LRefType(#$leftType) && isValid(_leftVal = _rightVal.get()) )
                {
                    _leftVal = _rightVal.get();
                    _coEntryPt = 2;
                    if[ct] ( isValid(logicDebug) )
                        cout << "Unify, assigning " << _rightVal.get() << " to left side => " << this << endl;
                    return true;
                }
                _coEntryPt = -1;
                return false;
            }
        }
        else if ( _coEntryPt == 1 )  // After we write into the right value
        {
            if[ct] ( isValid(logicDebug) )
                cout << "Unify, no more values (after right side assign)\n";
            if[ct] ( LRefType(#$rightType) )
                _rightVal reset;
            _coEntryPt = -1;  // Nothing more to do here
            return false;
        }
        else if ( _coEntryPt == 2 )  // After we write into the left value
        {
            if[ct] ( isValid(logicDebug) )
                cout << "Unify, no more values (after left side assign)\n";
            if[ct] ( LRefType(#$leftType) )
                _leftVal reset;
            _coEntryPt = -1;  // Nothing more to do here
            return false;
        }
        else
        {
            if[ct] ( isValid(logicDebug) )
                cout << "Unify, done\n";
            return false;
        }
    }

    fun >>(os: @OutStream)
    {
        os << "UnifyLR(left=" << _leftVal << ", right=" << _rightVal << ", " << _coEntryPt << ")" << flush;
    }

    var _coEntryPt: Int;
    var _leftVal: leftType;
    var _rightVal: rightType;
}

class[rtct] OrRelation(leftPredicateType, rightPredicateType: Type)
{
    using ValueType = Bool;
    using ValuePassType = Bool;

    fun ctor(l: @leftPredicateType, r: @rightPredicateType)
    {
        this._left ctor l;
        this._right ctor r;
        _coEntryPt ctor 0;
        if[ct] ( isValid(logicDebug) )
            cout << "OrRelation.ctor: " << this << "\n";
    }

    fun dtor
    {
        if[ct] ( isValid(logicDebug) )
            cout << "OrRelation.dtor: " << this << "\n";
    }

    fun (): Bool
    {
        if[ct] ( isValid(logicDebug) )
            cout << "OrRelation.(): " << this << "\n";
        if ( _coEntryPt == 0 )   // Never called before, or left is returning true
        {
            // While left returns true, stay in the same state and return true
            if ( _left() )
                return true;

            // Left is not false, check right
            if ( _right() )
            {
                // If the right is true, go to state 1 and return true
                _coEntryPt = 1;
                return true;
            }
            _coEntryPt = -1;
            return false;
        }
        else if ( _coEntryPt == 1 )  // Right is returning true
        {
            // While right returns true, stay in the same state and return true
            if ( _right() )
                return true;

            // Right is false, nothing to do anymore
            _coEntryPt = -1; // Done here
        }
        return false;
    }

    fun >>(os: @OutStream)
    {
        os << "OrRelation(left=" << _left << ", right=" << _right << ", " << _coEntryPt << ")" << flush;
    }

    var _coEntryPt: Int;
    var _left: leftPredicateType;
    var _right: rightPredicateType;
}

class[rtct] AndRelation(leftPredicateType, rightPredicateType: Type)
{
    using ValueType = Bool;
    using ValuePassType = Bool;

    fun ctor(l: leftPredicateType, r: rightPredicateType)
    {
        this._left ctor l;
        this._right ctor r;
        this._rightBegin ctor r;
        _coEntryPt ctor 0;
        if[ct] ( isValid(logicDebug) )
            cout << "AndRelation.ctor: " << this << "\n";
    }

    fun (): Bool
    {
        if[ct] ( isValid(logicDebug) )
            cout << "AndRelation.(): " << this << "\n";
        if ( _coEntryPt == 0 || _coEntryPt == 1 )   // Never called before; stay here until we have a positive result
        {
            var skipEvalLeft = _coEntryPt == 1;
            while ( skipEvalLeft || _left() )
            {
                // Left is (still) true; check if right is also true
                if ( _right() )
                {
                    // Both left and right are true
                    _coEntryPt = 1;
                    return true;
                }

                // Right is false now; reset right and check left for new values
                _right = _rightBegin;
                skipEvalLeft = false;
            }

            // Left is now false, bail out
            _coEntryPt = -1;
            return false;
        }
        return false;
    }

    fun >>(os: @OutStream)
    {
        os << "AndRelation(left=" << _left << ", right=" << _right << ", " << _coEntryPt << ")" << flush;
    }

    var _coEntryPt: Int;
    var _left: leftPredicateType;
    var _right, _rightBegin: rightPredicateType;
}

class LFalse
{
    fun () = false;

    fun >>(os: @OutStream)
    {
        os << "LFalse" << flush;
    }
}

class LTrue
{
    fun () = true;

    fun >>(os: @OutStream)
    {
        os << "LTrue" << flush;
    }
}

package Impl
{
    fun mkEq(l, r: @ValWrapper) = UnifyLR(-@typeOf(l), -@typeOf(r))(l, r);
}

