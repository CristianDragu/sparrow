import charRange;
import token;
import std.algorithms;
import meta = meta.compilerCore;
import os = os;

[rtct] class ConsoleErrorReporter(sourceType: Type) if CharRange(#$sourceType)
{
    fun ctor(source: @sourceType)
    {
        this._source ctor source;
    }

    fun raiseError(loc: Location, message: StringRef)
    {
        cout << message << flush;
        _printLocation(cout, loc);
        cout << flush;
        os.exit(-1);
    }

    fun _printLocation(os: @OutStream, loc: Location)
    {
        var line = _getLineAtLocation(loc);
        //os << "(" << loc.start.line << ":" << loc.start.col << " - " << loc.end.line << ":" << loc.end.col << ")\n";
        os << '>' << line << '\n';

        os << '>';
        var endCol = loc.end.col;
        if ( loc.start.line != loc.end.line )
            endCol = UInt(line.size()+1);
        if ( loc.start.col == endCol )
            ++endCol;
        for i = 1..loc.start.col
            os << ' ';
        for i = loc.start.col..endCol
            os << '~';
        os << '\n';
    }

    fun _getLineAtLocation(loc: Location): String
    {
        var sourceCopy = _source;

        // Skip until our line
        var curLine = 1;
        while curLine < loc.start.line
            sourceCopy = find(sourceCopy, '\n'.char);
            sourceCopy.popFront();
            ++curLine;

        var len = indexOf(sourceCopy, '\n'.char);
        return String(take(sourceCopy, len));
    }

    var _source: sourceType;
}
[rtct] fun mkConsoleErrorReporter(source: @CharRange) = ConsoleErrorReporter(-@typeOf(source))(source);

[ct] class CompilerErrorReporter
{
    fun raiseError(loc: Location, message: StringRef)
    {
        meta.report(meta.diagError, loc, message);
        meta.raise;
    }
}
