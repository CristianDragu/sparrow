import charRange;
import token;
import std.algorithms;
import meta = meta.compilerCore;
import os = os;

class[rtct] ConsoleErrorReporter(sourceType: Type) if CharRange(#$sourceType)
{
    fun ctor(source: @sourceType)
    {
        this.source ctor source;
    }

    fun raiseError(loc: Location, message: StringRef)
    {
        cout << message << flush;
        printLocation(cout, loc);
        cout << flush;
        os.exit(-1);
    }

    private fun printLocation(os: @OutStream, loc: Location)
    {
        var line = getLineAtLocation(loc);
        //os << "(" << loc.start.line << ":" << loc.start.col << " - " << loc.end.line << ":" << loc.end.col << ")\n";
        os << '>' << line << '\n';

        os << '>';
        var endCol = loc.end.col;
        if ( loc.start.line != loc.end.line )
            endCol = UInt(line.size()+1);
        if ( loc.start.col == endCol )
            ++endCol;
        for ( i = 1..loc.start.col )
            os << ' ';
        for ( i = loc.start.col..endCol )
            os << '~';
        os << '\n';
    }

    private fun getLineAtLocation(loc: Location): String
    {
        var sourceCopy = source;

        // Skip until our line
        var curLine = 1;
        while ( curLine < loc.start.line )
        {
            sourceCopy = find(sourceCopy, '\n');
            sourceCopy.popFront();
            ++curLine;
        }

        var len = indexOf(sourceCopy, '\n');
        return String(take(sourceCopy, len));
    }

    private var source: sourceType;
}
fun[rtct] mkConsoleErrorReporter(source: @CharRange) = ConsoleErrorReporter(-@typeOf(source))(source);

class[ct] CompilerErrorReporter
{
    fun raiseError(loc: Location, message: StringRef)
    {
        meta.report(meta.diagError, loc, message);
        meta.raise;
    }
}
