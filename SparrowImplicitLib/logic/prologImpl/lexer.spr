import token;
import errorReporter;

[rtct] class Lexer(sourceType, errorReporterType: Type) if CharRange(#$sourceType)
{
    using TokenType = Token;
    using RetType = TokenType;

    fun ctor(source: @sourceType, errorReporter: @errorReporterType)
    {
        var startLoc: Location;
        startLoc setOne;
        this.ctor(source, errorReporter, startLoc);
    }

    fun ctor(source: @sourceType, errorReporter: @errorReporterType, startLoc: Location)
    {
        this._source ctor source;
        this._errorReporter ctor errorReporter;
        this._curToken ctor;
        this._curLocation ctor startLoc;

        _curLocation setAsStartOf _curLocation;

        // Read the first token
        this._curToken = _getNextToken();
    }

    fun isEmpty             = _source.isEmpty();
    fun front               = _curToken;
    fun ()                  = _curToken;

    fun popFront            { _curToken = _getNextToken(); }
    fun pre_++ : RetType    { popFront(); return _curToken; }
    fun post_++ : RetType   { var res = _curToken; popFront(); return res; }

    fun _getNextToken: Token
    {
        // The current location starts where the last one ended
        _curLocation stepOver;

        // First check if the source is empty; if so, return an EOF token
        if ( _source.isEmpty() )
            return Token(_curLocation, tkEof);

        // Get the first character in the source
        var ch = _source();

        // Check for whitespace
        if ( isSpace(ch) )
        {
            _consumeWhiteSpace();    // Just drop it
            return _getNextToken();  // Get the next token
        }

        // Check for comments
        if ( ch == '%'.char )
        {
            _consumeLineComment();   // Just drop all characters until the end of line
            return _getNextToken();  // Get the next token
        }


        if ( isAlnum(ch) )
        {
            // Check for numbers, variables and string atoms
            if ( isDigit(ch) )
            {
                var data = _consumeNumber();
                return Token(_curLocation, tkNumber, data);
            }
            else if ( isUpper(ch) )
            {
                var data = _consumeIdentifier();
                return Token(_curLocation, tkVar, data);
            }
            else
            {
                var data = _consumeIdentifier();
                if ( data == String("is") )
                    return Token(_curLocation, tkIs, data);
                return Token(_curLocation, tkAtom, data);
            }
        }
        else if ( ch == '$'.char )
        {
            var data = _consumeAntiQuote();
            return Token(_curLocation, tkAntiQuote, data);
        }
        else
        {
            var chNext = _advanceSource();
            if ( ch == '('.char )
                return Token(_curLocation, tkLParen);
            else if ( ch == ')'.char )
                return Token(_curLocation, tkRParen);
            else if ( ch == '['.char )
                return Token(_curLocation, tkLBracket);
            else if ( ch == ']'.char )
                return Token(_curLocation, tkRBracket);
            else if ( ch == '.'.char )
                return Token(_curLocation, tkDot);
            else if ( ch == ','.char )
                return Token(_curLocation, tkComma);
            else if ( ch == '+'.char )
                return Token(_curLocation, tkOpPlus);
            else if ( ch == '-'.char )
                return Token(_curLocation, tkOpMinus);
            else if ( ch == '*'.char )
                return Token(_curLocation, tkOpMul);
            else if ( ch == '/'.char )
                return Token(_curLocation, tkOpDiv);
            else if ( ch == ':'.char && chNext == '-'.char )
            {
                _advanceSource();
                return Token(_curLocation, tkClause);
            }

        }

        var errMsg: String = "Invalid character found while parsing Prolog code: ";
        errMsg.append(ch);
        _errorReporter.raiseError(_curLocation, errMsg.asStringRef());
        return Token(_curLocation, tkEof);
    }

    fun _consumeWhiteSpace
    {
        var ch = _source();
        while !_source.isEmpty() && isSpace(ch)
            ch = _advanceSource();
    }
    fun _consumeLineComment
    {
        var ch = _source();
        while !_source.isEmpty() && ch != '\n'.char
            ch = _advanceSource();
        if ( !_source.isEmpty() )
            _advanceSource();
    }
    fun _consumeNumber: String
    {
        var res: String;
        var ch = _source();
        while !_source.isEmpty() && isDigit(ch)
        {
            res.pushBack(ch);
            ch = _advanceSource();
        }
        return res;
    }
    fun _consumeIdentifier: String
    {
        var res: String;
        var ch = _source();
        while !_source.isEmpty() && isAlnum(ch)
        {
            res.pushBack(ch);
            ch = _advanceSource();
        }
        return res;
    }
    fun _consumeAntiQuote: String
    {
        var ch = _advanceSource();
        if ( ch == '{'.char )
        {
            var res: String;
            var braces = 1;
            ch = _advanceSource();
            _curLocation stepOver;
            while !_source.isEmpty()
            {
                if ( _source.isEmpty() )
                    _errorReporter.raiseError(_curLocation, "End of stream found inside anti-quotation");
                if ( ch == '}'.char )
                {
                    if ( --braces == 0 )
                    {
                        ch = _advanceSource();
                        break;
                    }
                }

                res.pushBack(ch);

                if ( ch == '{'.char )
                    ++braces;
                ch = _advanceSource();
            }
            return res;
        }
        else
        {
            _curLocation stepOver;
            return _consumeIdentifier();
        }
    }

    fun _advanceSource: Char
    {
        if ( _source() == '\n'.char )
            _curLocation addLines 1;
        else
            _curLocation addColumns 1;
        _source popFront;
        return _source front;
    }

    var _source: sourceType;
    var _errorReporter: errorReporterType;
    var _curToken: Token;
    var _curLocation: Location;
}

[rtct] fun mkLexer(source: @CharRange, errorReporter: @AnyType) = Lexer(-@typeOf(source), -@typeOf(errorReporter))(source, errorReporter);
[rtct] fun mkLexer(source: @CharRange, errorReporter: @AnyType, startLoc: Location) = Lexer(-@typeOf(source), -@typeOf(errorReporter))(source, errorReporter, startLoc);
