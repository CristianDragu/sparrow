module meta.astNodes;

import meta.location(Location, SourceCode);

using modeUnspecified = 0;
using modeRt = 1;
using modeCt = 2;
using modeRtCt = 3;

/// Taking an AST node, this will evaluate the node and produce the corresponding
fun[ct, native("$meta.astEval")] astEval(node: AstNode): AstNode;

/// Given any Sparrow node as parameter, this will transform it into an AST node
//fun[ct, native("$meta.lift")] lift(): AstNode;



class[ct] CompilationContext
{
    fun[static, native("$meta.CompilationContext.current")] current(): CompilationContext;

    fun[native("$meta.CompilationContext.evalMode")] evalMode: Int;
    fun[native("$meta.CompilationContext.sourceCode")] sourceCode: SourceCode;

    fun ctor
    {
        impl := null;
    }
    private fun ctor(impl: @Int)
    {
        this.impl := impl;
    }
    private var impl: @Int;
}

class[ct] AstType
{
    fun[native("$meta.AstType.typeKind")] typeKind: Int;
    fun[native("$meta.AstType.toString")] toString: StringRef;

    fun[native("$meta.AstType.hasStorage")] hasStorage: Bool;
    fun[native("$meta.AstType.numReferences")] numReferences: Int;
    fun[native("$meta.AstType.mode")] mode: Int;
    fun[native("$meta.AstType.canBeUsedAtCt")] canBeUsedAtCt: Bool;
    fun[native("$meta.AstType.canBeUsedAtRt")] canBeUsedAtRt: Bool;

    fun ctor
    {
        impl := null;
    }
    private var impl: @Int;
}

class[ct] AstNode
{
    fun isNull: Bool = impl === null;
    fun isSet: Bool = impl !== null;

    fun[native("$meta.AstNode.clone")] clone: AstNode;
    fun[native("$meta.AstNode.nodeKind")] nodeKind: Int;
    fun[native("$meta.AstNode.nodeKindName")] nodeKindName: StringRef;
    fun[native("$meta.AstNode.toString")] toString: StringRef;
    fun[native("$meta.AstNode.toStringExt")] toStringExt: StringRef;

    // Node properties

    fun[native("$meta.AstNode.location")] location: Location;

    if[ct] ( isValid(Vector(AstNode)) )
        fun[native("$meta.AstNode.children")] children: Vector(AstNode);    // TODO: fix this
    fun[native("$meta.AstNode.getChild")] getChild(n: Int): AstNode;
    if[ct] ( isValid(Vector(AstNode)) )
        fun[native("$meta.AstNode.referredNodes")] referredNodes: Vector(AstNode);

    fun[native("$meta.AstNode.hasProperty")] hasProperty(name: StringRef): Bool;
    fun[native("$meta.AstNode.getPropertyString")] getPropertyString(name: StringRef, value: @StringRef): Bool;
    fun[native("$meta.AstNode.getPropertyInt")] getPropertyInt(name: StringRef, value: @Int): Bool;
    fun[native("$meta.AstNode.getPropertyNode")] getPropertyNode(name: StringRef, value: @AstNode): Bool;
    fun[native("$meta.AstNode.getPropertyType")] getPropertyType(name: StringRef, value: @AstType): Bool;
    fun[native("$meta.AstNode.setProperty")] setProperty(name: StringRef, value: StringRef);
    fun[native("$meta.AstNode.setProperty")] setProperty(name: StringRef, value: Int);
    fun[native("$meta.AstNode.setProperty")] setProperty(name: StringRef, value: AstNode);
    fun[native("$meta.AstNode.setProperty")] setProperty(name: StringRef, value: AstType);

    // Compilation processes

    fun[native("$meta.AstNode.setContext")] setContext(context: CompilationContext);
    fun[native("$meta.AstNode.computeType")] computeType;
    fun[native("$meta.AstNode.semanticCheck")] semanticCheck;
    fun[native("$meta.AstNode.clearCompilationState")] clearCompilationState;

    fun[native("$meta.AstNode.context")] context: CompilationContext;

    fun[native("$meta.AstNode.hasError")] hasError: Bool;
    fun[native("$meta.AstNode.isSemanticallyChecked")] isSemanticallyChecked: Bool;

    fun[native("$meta.AstNode.type")] type: AstType;

    fun[native("$meta.AstNode.isExplained")] isExplained: Bool;
    fun[native("$meta.AstNode.explanation")] explanation: AstNode;
    fun[native("$meta.AstNode.curExplanation")] curExplanation: AstNode;

    // Private stuff

    /*private*/ fun ctor
    {
        impl := null;
    }
    private fun ctor(impl: @Int)
    {
        this.impl := impl;
    }
    var impl: @Int;
}

package Feather
{
    // TODO: AST interface is not consistent
    fun[ct] mkNodeList(loc: @Location): AstNode = Impl.mkNodeList(loc, null, null, false);
    fun[ct] mkNodeList(loc: @Location, voidResult: Bool): AstNode = Impl.mkNodeList(loc, null, null, voidResult);
    fun[ct] mkNodeList(loc: @Location, childrenBegin, childrenEnd: @AstNode) = Impl.mkNodeList(loc, childrenBegin, childrenEnd, false);
    fun[ct] mkNodeList(loc: @Location, childrenBegin, childrenEnd: @AstNode, voidResult: Bool) = Impl.mkNodeList(loc, childrenBegin, childrenEnd, voidResult);
    if[ct] ( isValid(Vector(AstNode)) )
        fun[ct] mkNodeList(loc: @Location, children: @Vector(AstNode)): AstNode = Impl.mkNodeList(loc, children.begin.value(), children.end.value(), false);
    if[ct] ( isValid(Vector(AstNode)) )
        fun[ct] mkNodeList(loc: @Location, children: @Vector(AstNode), voidResult: Bool): AstNode = Impl.mkNodeList(loc, children.begin.value(), children.end.value(), voidResult);
    fun[ct, native("$meta.Feather.addToNodeList")] addToNodeList(list, newNode: AstNode): AstNode;
    fun[ct, native("$meta.Feather.appendNodeList")] appendNodeList(main, newList: AstNode): AstNode;

    fun[ct, native("$meta.Feather.mkNop")] mkNop(loc: Location): AstNode;
    fun[ct, native("$meta.Feather.mkTypeNode")] mkTypeNode(loc: @Location, type: AstType): AstNode;
    fun[ct, native("$meta.Feather.mkBackendCode")] mkBackendCode(loc: @Location, code: StringRef, mode: Int): AstNode;
    fun[ct, native("$meta.Feather.mkLocalSpace")] mkLocalSpace(loc: @Location, childrenBegin, childrenEnd: @AstNode): AstNode;
    //if[ct] ( isValid(Vector(AstNode)) )
    //    fun[ct] mkLocalSpace(loc: @Location, children: @Vector(AstNode)): AstNode = Impl.mkLocalSpace(loc, children.begin.value(), children.end.value());
    fun[ct, native("$meta.Feather.mkGlobalConstructAction")] mkGlobalConstructAction(loc: @Location, action: AstNode): AstNode;
    fun[ct, native("$meta.Feather.mkGlobalDestructAction")] mkGlobalDestructAction(loc: @Location, action: AstNode): AstNode;
    fun[ct, native("$meta.Feather.mkScopeDestructAction")] mkScopeDestructAction(loc: @Location, action: AstNode): AstNode;
    fun[ct, native("$meta.Feather.mkTempDestructAction")] mkTempDestructAction(loc: @Location, action: AstNode): AstNode;

    if[ct] ( isValid(Vector(AstNode)) )
        fun[ct] mkFunction(loc: @Location, name: StringRef, resType: AstNode, params: @Vector(AstNode), body: AstNode, mode: Int): AstNode = Impl.mkFunction(loc, name, resType, params.begin.value(), params.end.value(), body, mode);
    if[ct] ( isValid(Vector(AstNode)) )
        fun[ct] mkClass(loc: @Location, name: StringRef, fields: @Vector(AstNode), mode: Int): AstNode = Impl.mkClass(loc, name, fields.begin.value(), fields.end.value(), mode);
    if[ct] ( isValid(Vector(AstNode)) )
        fun[ct, native("$meta.Feather.mkVar")] mkVar(loc: @Location, name: StringRef, type: AstNode, mode: Int): AstNode;

    fun[ct, native("$meta.Feather.mkCtValue")] mkCtValue(loc: @Location, type: AstType, data: StringRef): AstNode;
    fun[ct, native("$meta.Feather.mkNull")] mkNull(loc: @Location, typeNode: AstNode): AstNode;
    fun[ct, native("$meta.Feather.mkVarRef")] mkVarRef(loc: @Location, varDecl: AstNode): AstNode;
    fun[ct, native("$meta.Feather.mkFieldRef")] mkFieldRef(loc: @Location, obj, fieldDecl: AstNode): AstNode;
    fun[ct, native("$meta.Feather.mkFunRef")] mkFunRef(loc: @Location, funDecl: AstNode, resType: AstNode): AstNode;
    if[ct] ( isValid(Vector(AstNode)) )
        fun[ct] mkFunCall(loc: @Location, funDecl: AstNode, args: @Vector(AstNode)): AstNode = Impl.mkFunCall(loc, funDecl, args.begin.value(), args.end.value());
    fun[ct, native("$meta.Feather.mkMemLoad")] mkMemLoad(loc: @Location, exp: AstNode): AstNode;
    fun[ct, native("$meta.Feather.mkMemStore")] mkMemStore(loc: @Location, value, address: AstNode): AstNode;
    fun[ct, native("$meta.Feather.mkBitcast")] mkBitcast(loc: @Location, destType: AstNode, node: AstNode): AstNode;
    fun[ct, native("$meta.Feather.mkConditional")] mkConditional(loc: @Location, condition, alt1, alt2: AstNode): AstNode;

    fun[ct, native("$meta.Feather.mkIf")] mkIf(loc: @Location, condition, thenClause, elseClause: AstNode, isCt: Bool = false): AstNode;
    fun[ct, native("$meta.Feather.mkWhile")] mkWhile(loc: @Location, condition, body, step: AstNode): AstNode;
    fun[ct, native("$meta.Feather.mkWhile")] mkWhile(loc: @Location, condition, body, step: AstNode, isCt: Bool): AstNode;
    fun[ct, native("$meta.Feather.mkBreak")] mkBreak(loc: Location): AstNode;
    fun[ct, native("$meta.Feather.mkContinue")] mkContinue(loc: Location): AstNode;
    fun[ct, native("$meta.Feather.mkReturn")] mkReturn(loc: Location): AstNode;
    fun[ct, native("$meta.Feather.mkReturn")] mkReturn(loc: @Location, exp: AstNode): AstNode;

    package Impl
    {
        fun[ct, native("$meta.Feather.mkNodeList")] mkNodeList(loc: @Location, childrenBegin, childrenEnd: @AstNode, voidResult: Bool): AstNode;
        fun[ct, native("$meta.Feather.mkLocalSpace")] mkLocalSpace(loc: @Location, childrenBegin, childrenEnd: @AstNode): AstNode;
        fun[ct, native("$meta.Feather.mkFunction")] mkFunction(loc: @Location, name: StringRef, resType: AstNode, paramsBegin, paramsEnd: @AstNode, body: AstNode, mode: Int): AstNode;
        fun[ct, native("$meta.Feather.mkClass")] mkClass(loc: @Location, name: StringRef, fieldBegin, fieldEnd: @AstNode, mode: Int): AstNode;
        fun[ct, native("$meta.Feather.mkFunCall")] mkFunCall(loc: @Location, funDecl: AstNode, argsBegin, argsEnd: @AstNode): AstNode;
    }
}

package SprFrontend
{
    fun[ct, native("$meta.Sparrow.mkModifiers")] mkModifiers(loc: @Location, main, mods: AstNode): AstNode;

    fun[ct, native("$meta.Sparrow.mkModule")] mkModule(loc: @Location, moduleName, declarations: AstNode): AstNode;
    fun[ct, native("$meta.Sparrow.mkSprUsing")] mkSprUsing(loc: @Location, alias: StringRef, usingNode: AstNode): AstNode;
    fun[ct, native("$meta.Sparrow.mkSprPackage")] mkSprPackage(loc: @Location, name: StringRef, children: AstNode): AstNode;
    fun[ct, native("$meta.Sparrow.mkSprVariable")] mkSprVariable(loc: @Location, name: StringRef, typeNode, init: AstNode): AstNode;
    fun[ct, native("$meta.Sparrow.mkSprClass")] mkSprClass(loc: @Location, name: StringRef, parameters, baseClasses, ifClause, children: AstNode): AstNode;

    fun[ct, native("$meta.Sparrow.mkSprConcept")] mkSprConcept(loc: @Location, name: StringRef, paramName: StringRef, baseConcept, ifClause: AstNode): AstNode;

    fun[ct, native("$meta.Sparrow.mkSprFunction")] mkSprFunction(loc: @Location, name: StringRef, parmeters, returnType, body, ifClause: AstNode): AstNode;
    fun[ct, native("$meta.Sparrow.mkSprFunctionExp")] mkSprFunctionExp(loc: @Location, name: StringRef, parameters, returnType, bodyExp, ifClause: AstNode): AstNode;
    fun[ct, native("$meta.Sparrow.mkSprParameter")] mkSprParameter(loc: @Location, name: StringRef, typeNode, init: AstNode): AstNode;
    fun[ct, native("$meta.Sparrow.mkSprAutoParameter")] mkSprAutoParameter(loc: @Location, name: StringRef): AstNode;

    fun[ct, native("$meta.Sparrow.mkIdentifier")] mkIdentifier(loc: @Location, id: StringRef): AstNode;
    fun[ct, native("$meta.Sparrow.mkCompoundExp")] mkCompoundExp(loc: @Location, base: AstNode, id: StringRef): AstNode;
    fun[ct, native("$meta.Sparrow.mkStarExp")] mkStarExp(loc: @Location, base: AstNode, operName: StringRef): AstNode;
    fun[ct, native("$meta.Sparrow.mkPostfixOp")] mkPostfixOp(loc: @Location, op: StringRef, base: AstNode): AstNode;
    fun[ct, native("$meta.Sparrow.mkInfixOp")] mkInfixOp(loc: @Location, op: StringRef, arg1, arg2: AstNode): AstNode;
    fun[ct, native("$meta.Sparrow.mkPrefixOp")] mkPrefixOp(loc: @Location, op: StringRef, base: AstNode): AstNode;
    fun[ct, native("$meta.Sparrow.mkFunApplication")] mkFunApplication(loc: @Location, base, arguments: AstNode): AstNode;
    fun[ct, native("$meta.Sparrow.mkOperatorCall")] mkOperatorCall(loc: @Location, arg1: AstNode, op: StringRef, arg2: AstNode): AstNode;

    fun[ct, native("$meta.Sparrow.mkConditionalExp")] mkConditionalExp(loc: @Location, cond, alt1, alt2: AstNode): AstNode;
    fun[ct, native("$meta.Sparrow.mkThisExp")] mkThisExp(loc: Location): AstNode;
    fun[ct, native("$meta.Sparrow.mkParenthesisExp")] mkParenthesisExp(loc: @Location, exp: AstNode): AstNode;
    fun[ct, native("$meta.Sparrow.mkIntLiteral")] mkIntLiteral(loc: @Location, value: Int): AstNode;
    fun[ct, native("$meta.Sparrow.mkUIntLiteral")] mkUIntLiteral(loc: @Location, value: UInt): AstNode;
    fun[ct, native("$meta.Sparrow.mkLongLiteral")] mkLongLiteral(loc: @Location, value: Long): AstNode;
    fun[ct, native("$meta.Sparrow.mkULongLiteral")] mkULongLiteral(loc: @Location, value: ULong): AstNode;
    fun[ct, native("$meta.Sparrow.mkFloatLiteral")] mkFloatLiteral(loc: @Location, value: Float): AstNode;
    fun[ct, native("$meta.Sparrow.mkDoubleLiteral")] mkDoubleLiteral(loc: @Location, value: Double): AstNode;
    fun[ct, native("$meta.Sparrow.mkCharLiteral")] mkCharLiteral(loc: @Location, value: Char): AstNode;
    fun[ct, native("$meta.Sparrow.mkStringLiteral")] mkStringLiteral(loc: @Location, value: StringRef): AstNode;
    fun[ct, native("$meta.Sparrow.mkNullLiteral")] mkNullLiteral(loc: Location): AstNode;
    fun[ct, native("$meta.Sparrow.mkBoolLiteral")] mkBoolLiteral(loc: @Location, value: Bool): AstNode;
    fun[ct, native("$meta.Sparrow.mkLambdaExp")] mkLambdaExp(loc: @Location, parameters, returnType, body, bodyExp, closureParams: AstNode): AstNode;

    fun[ct, native("$meta.Sparrow.mkExpressionStmt")] mkExpressionStmt(loc: @Location, exp: AstNode): AstNode;
    fun[ct, native("$meta.Sparrow.mkBlockStmt")] mkBlockStmt(loc: @Location, statements: AstNode): AstNode;
    fun[ct, native("$meta.Sparrow.mkIfStmt")] mkIfStmt(loc: @Location, cond, thenClause, elseClause: AstNode): AstNode;
    fun[ct, native("$meta.Sparrow.mkForStmt")] mkForStmt(loc: @Location, name: StringRef, type, range, action: AstNode): AstNode;
    fun[ct, native("$meta.Sparrow.mkWhileStmt")] mkWhileStmt(loc: @Location, cond, step, action: AstNode): AstNode;
    fun[ct, native("$meta.Sparrow.mkBreakStmt")] mkBreakStmt(loc: Location): AstNode;
    fun[ct, native("$meta.Sparrow.mkContinueStmt")] mkContinueStmt(loc: Location): AstNode;
    fun[ct, native("$meta.Sparrow.mkReturnStmt")] mkReturnStmt(loc: @Location, exp: AstNode): AstNode;
}

package Compiler
{
    fun[ct, native("$meta.Compiler.registerFrontendFun")] registerFrontendFun(ext, funName: StringRef): Bool;
    fun[ct, native("$meta.Compiler.parseSprExpression")] parseSprExpression(loc: @Location, exp: StringRef): AstNode;
}

package Kinds
{
    var[ct] iotaVar = 0;
    fun[ct] iotaReset { iotaVar = 0; }
    fun[ct] iota = iotaVar++;

    using nkFeatherNop = ctEval(iota);
    using nkFeatherTypeNode = ctEval(iota);
    using nkFeatherBackendCode = ctEval(iota);
    using nkFeatherNodeList = ctEval(iota);
    using nkFeatherLocalSpace = ctEval(iota);
    using nkFeatherGlobalConstructAction = ctEval(iota);
    using nkFeatherGlobalDestructAction = ctEval(iota);
    using nkFeatherScopeDestructAction = ctEval(iota);
    using nkFeatherTempDestructAction = ctEval(iota);

    using nkFeatherDeclFunction = ctEval(iota);
    using nkFeatherDeclClass = ctEval(iota);
    using nkFeatherDeclVar = ctEval(iota);

    using nkFeatherExpCtValue = ctEval(iota);
    using nkFeatherExpNull = ctEval(iota);
    using nkFeatherExpVarRef = ctEval(iota);
    using nkFeatherExpFieldRef = ctEval(iota);
    using nkFeatherExpFunRef = ctEval(iota);
    using nkFeatherExpFunCall = ctEval(iota);
    using nkFeatherExpMemLoad = ctEval(iota);
    using nkFeatherExpMemStore = ctEval(iota);
    using nkFeatherExpBitcast = ctEval(iota);
    using nkFeatherExpConditional = ctEval(iota);
    using nkFeatherExpChangeMode = ctEval(iota);

    using nkFeatherStmtIf = ctEval(iota);
    using nkFeatherStmtWhile = ctEval(iota);
    using nkFeatherStmtBreak = ctEval(iota);
    using nkFeatherStmtContinue = ctEval(iota);
    using nkFeatherStmtReturn = ctEval(iota);

    using nkSparrowModifiersNode = ctEval(iota);

    using nkSparrowDeclModule = ctEval(iota);
    using nkSparrowDeclImportName = ctEval(iota);
    using nkSparrowDeclPackage = ctEval(iota);
    using nkSparrowDeclSprClass = ctEval(iota);
    using nkSparrowDeclSprFunction = ctEval(iota);
    using nkSparrowDeclSprParameter = ctEval(iota);
    using nkSparrowDeclSprVariable = ctEval(iota);
    using nkSparrowDeclSprConcept = ctEval(iota);
    using nkSparrowDeclGenericClass = ctEval(iota);
    using nkSparrowDeclGenericFunction = ctEval(iota);
    using nkSparrowDeclUsing = ctEval(iota);

    using nkSparrowExpLiteral = ctEval(iota);
    using nkSparrowExpThis = ctEval(iota);
    using nkSparrowExpIdentifier = ctEval(iota);
    using nkSparrowExpCompoundExp = ctEval(iota);
    using nkSparrowExpFunApplication = ctEval(iota);
    using nkSparrowExpOperatorCall = ctEval(iota);
    using nkSparrowExpInfixExp = ctEval(iota);
    using nkSparrowExpLambdaFunction = ctEval(iota);
    using nkSparrowExpSprConditional = ctEval(iota);
    using nkSparrowExpDeclExp = ctEval(iota);
    using nkSparrowExpStarExp = ctEval(iota);

    using nkSparrowStmtFor = ctEval(iota);
    using nkSparrowStmtSprReturn = ctEval(iota);
}
