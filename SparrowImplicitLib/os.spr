module os;

import std.string(String);

fun[rtct, native("exit")] exit(code: Int);

fun[rtct] systemCall(cmd: StringRef): Int
{
    return OsImpl.system(cmd.cStr());
}

class[rtct] File
{
    fun ctor
    {
        handle := null;
    }

    fun ctor(handle: @Byte)
    {
        this.handle := handle;
    }

    fun ctor(filename: StringRef, mode: StringRef = "r")
    {
        this.handle := OsImpl.fopen(filename.cStr(), mode.cStr());
    }

    // Move ctor and assignment operator
    fun ctor(other: @File) {
        this.handle := other.handle;
        other.handle := null;
    }
    fun =(other: @File) {
        this.handle := other.handle;
        other.handle := null;
    }

    fun dtor
    {
        close();
    }

    fun[static] open(filename: StringRef, mode: StringRef = "r"): File
    {
        return File(OsImpl.fopen(filename.cStr(), mode.cStr()));
    }

    fun close
    {
        if ( isOpen() )
            OsImpl.fclose(handle);
        handle := null;
    }

    fun flush       = ife(isOpen(), OsImpl.fflush(handle), -1);

    fun isOpen      = handle !== null;
    fun isEof       = 0 != OsImpl.feof(handle);

    fun readChar: Char = Char(OsImpl.fgetc(handle));
    fun readLine: String
    {
        var res: String = 256;
        var cstr: @Char = OsImpl.fgets(res(0), 256, handle);
        if ( cstr === null )
            res.clear();
        else
            res.resize(StringRef.cStringLen(cstr));
        return res;
    }

    fun all = FileRange(this);

    private var handle: @Byte;
}

class[rtct] FileRange {
    using RetType = Char;

    private var file: @File;
    private var isEmpty: Bool;
    private var cur: Char;

    fun ctor(file: @File) {
        this.file := file;
        isEmpty = true;
        cur ctor;
        if ( !file.isEof ) {
            cur = file.readChar;
            isEmpty = false;
        }
    }
}

fun[rtct] isEmpty(s: @FileRange) = s.isEmpty;
fun[rtct] front(s: @FileRange)   = s.cur;
fun[rtct] popFront(s: @FileRange) {
    // Try reading a char; we don't know yet about eof, we need to check it afterwards
    s.cur = s.file.readChar;
    if ( s.file.isEof )
        s.isEmpty = true;
}


private package OsImpl
{
    fun[rtct, native("system")] system(x: @Char): Int;

    fun[rtct, native("fopen")] fopen(filename, mode: @Char): @Byte;
    fun[rtct, native("fclose")] fclose(handle: @Byte);
    fun[rtct, native("fflush")] fflush(handle: @Byte): Int;
    fun[rtct, native("feof")] feof(handle: @Byte): Int;
    fun[rtct, native("fgetc")] fgetc(handle: @Byte): Int;
    fun[rtct, native("fgets")] fgets(buffer: @Char, bufSize: Int, handle: @Byte): @Char;
    fun[rtct, native("fread")] fread(buffer: @Byte, size, count: UInt, handle: @Byte): UInt;
}

