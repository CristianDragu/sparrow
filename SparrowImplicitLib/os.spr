module os;

import std.string(String);

fun[rtct, native("exit")] exit(code: Int);

fun[rtct] systemCall(cmd: StringRef): Int
{
    return _OsImpl.system(cmd.cStr());
}

class[rtct] File
{
    fun ctor
    {
        _handle := null;
    }

    fun ctor(handle: @Byte)
    {
        this._handle := handle;
    }

    fun ctor(filename: StringRef, mode: StringRef = "r")
    {
        this._handle := _OsImpl.fopen(filename.cStr(), mode.cStr());
    }

    // Move ctor and assignment operator
    fun ctor(other: @File) {
        this._handle := other._handle;
        other._handle := null;
    }
    fun =(other: @File) {
        this._handle := other._handle;
        other._handle := null;
    }

    fun dtor
    {
        close();
    }

    fun[static] open(filename: StringRef, mode: StringRef = "r"): File
    {
        return File(_OsImpl.fopen(filename.cStr(), mode.cStr()));
    }

    fun close
    {
        if ( isOpen() )
            _OsImpl.fclose(_handle);
        _handle := null;
    }

    fun flush       = ife(isOpen(), _OsImpl.fflush(_handle), -1);

    fun isOpen      = _handle !== null;
    fun isEof       = 0 != _OsImpl.feof(_handle);

    fun readChar: Char = Char(_OsImpl.fgetc(_handle));
    fun readLine: String
    {
        var res: String = 256;
        var cstr: @Char = _OsImpl.fgets(res(0), 256, _handle);
        if ( cstr === null )
            res.clear();
        else
            res.resize(StringRef.cStringLen(cstr));
        return res;
    }

    fun all = FileRange(this);

    var _handle: @Byte;
}

class[rtct] FileRange {
    using RetType = Char;

    var _file: @File;
    var _isEmpty: Bool;
    var _cur: Char;

    fun ctor(file: @File) {
        this._file := file;
        _isEmpty = true;
        _cur ctor;
        if ( !_file.isEof ) {
            _cur = _file.readChar;
            _isEmpty = false;
        }
    }
}

fun[rtct] isEmpty(s: @FileRange) = s._isEmpty;
fun[rtct] front(s: @FileRange)   = s._cur;
fun[rtct] popFront(s: @FileRange) {
    // Try reading a char; we don't know yet about eof, we need to check it afterwards
    s._cur = s._file.readChar;
    if ( s._file.isEof )
        s._isEmpty = true;
}


package _OsImpl
{
    fun[rtct, native("system")] system(x: @Char): Int;

    fun[rtct, native("fopen")] fopen(filename, mode: @Char): @Byte;
    fun[rtct, native("fclose")] fclose(handle: @Byte);
    fun[rtct, native("fflush")] fflush(handle: @Byte): Int;
    fun[rtct, native("feof")] feof(handle: @Byte): Int;
    fun[rtct, native("fgetc")] fgetc(handle: @Byte): Int;
    fun[rtct, native("fgets")] fgets(buffer: @Char, bufSize: Int, handle: @Byte): @Char;
    fun[rtct, native("fread")] fread(buffer: @Byte, size, count: UInt, handle: @Byte): UInt;
}

