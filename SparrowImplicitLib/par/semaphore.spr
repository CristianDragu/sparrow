module par.semaphore

import std.compilerInfo
import config

datatype TimeSpecT
    tv_sec: Int
    tv_nsec: Long

//! Allows a limited numbers of threads to simultaneously "acquire" a resource
//! before releasing it.
//! Compared to the mutex, we can release the semaphore without acquiring it
datatype Semaphore
    _handle: _Impl.SemaphoreT

fun ctor(this: @Semaphore, startValue: UInt = 0)
    _handle ctor
    [ct] if platformName == "Darwin"
        var res = _Impl.semaphore_create(_Impl.mach_task_self(), _handle, _Impl.SYNC_POLICY_FIFO, Int(startValue))
    else
        var res = _Impl.sem_init(_handle, Int(0), UInt(startValue))

fun dtor(this: @Semaphore)
    [ct] if platformName == "Darwin"
        _Impl.semaphore_destroy(_Impl.mach_task_self(), _handle)
    else
        _Impl.sem_destroy(_handle)

//! Increments the counter of the semaphore
fun release(s: @Semaphore)
    [ct] if platformName == "Darwin"
        _Impl.semaphore_signal(s._handle)
    else
        _Impl.sem_post(s._handle)

//! Decrements the semaphore counter
//! If the counter reaches zero, the call blocks until somebody calls 'release'
fun acquire(s: @Semaphore)
    [ct] if platformName == "Darwin"
        while 0 != _Impl.semaphore_wait(s._handle)
            /* keep trying */;
    else
        while 0 != _Impl.sem_wait(s._handle)
            /* keep trying */;

package _Impl
    [ct] if platformName == "Darwin"
        using TaskT = Int
        using SYNC_POLICY_FIFO = 0

    using SemaphoreT = Int

    [ct] if platformName == "Linux"
        using ModeT = Int

    [ct] if platformName == "Darwin"
        [native("mach_task_self")] fun mach_task_self(): TaskT;
        [native("semaphore_create")] fun semaphore_create(task: TaskT, s: @SemaphoreT, policy, value: Int): Int;
        [native("semaphore_destroy")] fun semaphore_destroy(task: TaskT, s: SemaphoreT): Int;
        [native("semaphore_signal")] fun semaphore_signal(s: SemaphoreT): Int;
        [native("semaphore_wait")] fun semaphore_wait(s: SemaphoreT): Int;
    else
        [native("sem_init")]        fun sem_init(sem: @SemaphoreT, pshared: Int, value: UInt): Int
        [native("sem_destroy")]     fun sem_destroy(sem: @SemaphoreT): Int
        [native("sem_wait")]        fun sem_wait(sem: @SemaphoreT): Int
        [native("sem_trywait")]     fun sem_trywait(sem: @SemaphoreT): Int
        [native("sem_timedwait")]   fun sem_timedwait(sem: @SemaphoreT, timeout: @TimeSpecT): Int
        [native("sem_post")]        fun sem_post(sem: @SemaphoreT): Int
        [native("sem_getvalue")]    fun sem_getvalue(sem: @SemaphoreT, sval: @Int): Int
        [native("sem_close")]       fun sem_close(sem: @SemaphoreT): Int
        [native("sem_unlink")]      fun sem_unlink(name: @Char): Int
        [native("sem_open")]        fun sem_open(name: @Char, oflag: Int): @SemaphoreT
        [native("sem_open")]        fun sem_open(name: @Char, oflag: Int, mode: ModeT, value: UInt): @SemaphoreT
