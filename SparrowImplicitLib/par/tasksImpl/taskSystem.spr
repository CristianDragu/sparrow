module par.tasksImpl.taskSystem;

import internalWorkerThread;
import par.thread;
import std.ptr;
import std.vector;
import assert;

class TaskSystem {
    fun ctor {
    }

    fun dtor {
    }

    //! The global queue of tasks
    var globalQueue: TaskQueue;

    //! All the workers in the system
    var workers: (Worker Ptr) Vector;

    //! The internal threads that are doing all the work
    private var threads: (par.Thread Ptr) Vector;
    //! Object that counts the number of threads that are idle
    var idleCounter: IdleCounter;
}

var globalTaskSystem: TaskSystem Ptr;

fun initTaskSystem(numWorkers: UInt = 0) {
    // Create the task system object
    assert(globalTaskSystem isNull);
    globalTaskSystem = new(TaskSystem);

    // Create the required threads
    if ( numWorkers == 0 )
        numWorkers = getAvailableCoresNum();
    //numWorkers = 1;
    var ts: @TaskSystem = globalTaskSystem.get();
    for ( i=0..numWorkers ) {
        var worker = ts createWorker;
        var p: par.Thread Ptr = new(par.Thread, InternalWorkerThread(worker));
        ts.threads.pushBack(p);
    }
}

fun getInitTaskSystem: TaskSystem Ptr {
    // TODO: Make sure this is initialized only once
    if ( globalTaskSystem isNull )
        initTaskSystem;
    return globalTaskSystem;
}

fun createWorker(ts: TaskSystem Ptr): Worker Ptr {
    var id: Int = ts.get().workers size;
    var p: Worker Ptr = new(Worker, ts.get(), id, ts.get().idleCounter);
    ts.get().workers.pushBack(p);
    return p;
}

// TODO: make it random
var cnt: Int = 0;

fun getRandomTaskQueue(ts: @TaskSystem): @TaskQueue {
    // TODO: make the selection truly random
    var worker: Worker Ptr = ts.workers(++cnt % (ts.workers size));
    return worker.get().work;
}

fun onTaskAvailable(ts: @TaskSystem) {
    // Do something only if we have at least one idle worker
    if ( ts.idleCounter hasIdle ) {
        for ( w: Worker Ptr = ts.workers.all ) {
            // If we can wake up one worker, exit
            if ( w.get() tryWakeUp )
                return;
        }
    }
}

//! Get the number of currently available workers
fun numAvailableWorkers(ts: @TaskSystem) = (ts.workers size) - (ts.idleCounter numIdleWorkers);
