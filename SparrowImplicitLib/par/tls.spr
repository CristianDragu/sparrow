module par.tls;

import config;
import assert;
import std.newDelete;

//! A class that can hold some data into a thread-local storage
//! The size of the data must be less or equal to the size of a reference
//! For references, we would delete the pointer when the thread exits
class Tls(T: Type) if TypeOp.isRef(T) {
    var _tls: Impl.TlsCommon;

    using ValueType = T;

    fun ctor {
        _tls.ctor(\_destructPtr);
    }

    fun =(other: @Tls) {
        _tls setValue (other._tls getValue);
    }
    fun =(val: T) {
        _tls setValue reinterpretCast(@Byte, val);
    }


    fun get: T {
        return reinterpretCast(T, _tls getValue);
    }

    [static] fun _destructPtr(p: @Byte): Null {
        delete(reinterpretCast(T, p));
        return Null();
    }
}
class Tls(T: Type) if !TypeOp.isRef(T) && sizeOf(T) <= sizeOf(@Byte) {
    var _tls: Impl.TlsCommon;

    using ValueType = T;

    fun =(other: @Tls) {
        _tls setValue (other._tls getValue);
    }
    fun =(val: T) {
        _tls setValue reinterpretCast(@ @Byte, val);
    }

    fun get: T {
        return reinterpretCast(@ @T, _tls getValue);
    }
}


package Impl {
    using DtorFun = FunctionPtr(Null rt, @Byte rt);

    class TlsCommon {
        var key: KeyT;

        fun ctor {
            pthread_key_create(key, DtorFun());
        }
        fun ctor(dtorFun: DtorFun) {
            pthread_key_create(key, dtorFun);
        }

        fun dtor {
            pthread_key_delete(key);
        }
    }

    fun setValue(tls: @TlsCommon, val: @Byte) { pthread_setspecific(tls.key, val); }
    fun getValue(tls: @TlsCommon): @Byte = pthread_getspecific(tls.key);

    using KeyT = ULong;

    [native("pthread_key_create")] fun pthread_key_create(k: @KeyT, dtorFun: DtorFun): Int;
    [native("pthread_key_delete")] fun pthread_key_delete(k: KeyT): Int;
    [native("pthread_setspecific")] fun pthread_setspecific(k: KeyT, val: @Byte): Int;
    [native("pthread_getspecific")] fun pthread_getspecific(k: KeyT): @Byte;
}