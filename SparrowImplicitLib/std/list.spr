module std.list;

import rawPtr(RawPtr);
import array(Array);

class List(valueType: Type)
{
    using ValueType = valueType;
    using RangeType = ListRange;
    using RetType = @valueType;

    fun ctor()
    {
        listSize = 0;
        head.prev = headNode();
        head.next = headNode();
    }

    fun ctor(other: @List)
    {
        listSize = 0;
        head.prev = headNode();
        head.next = headNode();
        for ( v = other.all() )
            pushBack(v);
    }

    fun ctor(range: Range)
    {
        listSize = 0;
        head.prev = headNode();
        head.next = headNode();
        for ( v = range )
            pushBack(v);
    }

    fun dtor
    {
        var p = head.next;
        var hn = headNode();

        while ( p != hn )
        {
            var nextNode = p.value().next;

            p.value().data.dtor();
            p.freePtr();
            p = nextNode;
        }
    }

    fun size: SizeType          = listSize;
    fun isEmpty                 = listSize == 0;

    fun front: RetType          = head.next.value().data;
    fun back: RetType           = head.prev.value().data;

    fun all: RangeType          = RangeType(head.next, headNode());

    fun assign(range: Range)
    {
        clear();
        for ( v = range )
            pushBack(v);
    }

    fun swap(other: @List)
    {
        head.prev.swap(other.head.prev);
        head.next.swap(other.head.next);

        var tmpSize = listSize;
        listSize = other.listSize;
        other.listSize = tmpSize;

        if ( listSize == 0 )
        {
            head.prev = headNode();
            head.next = headNode();
        }
        else
        {
            head.prev.value().next = headNode();
            head.next.value().prev = headNode();
        }
        if ( other.listSize == 0 )
        {
            other.head.prev = other.headNode();
            other.head.next = other.headNode();
        }
        else
        {
            other.head.prev.value().next = other.headNode();
            other.head.next.value().prev = other.headNode();
        }
    }

    fun insertBefore(value: @ValueType, pos: RangeType)
    {
        var tmp = NodeTypePtr.alloc(1);

        tmp.value().data.ctor(value);
        tmp.value().next = pos.begin;
        tmp.value().prev = pos.begin.value().prev;
        pos.begin.value().prev.value().next = tmp;
        pos.begin.value().prev = tmp;
        ++listSize;
    }

    fun insertBefore(range: Range, pos: RangeType)
    {
        for ( v = range )
            insertBefore(v, pos);
    }

    fun insertAfter(value: @ValueType, pos: RangeType)
    {
        var tmp = NodeTypePtr.alloc(1);

        tmp.value().data.ctor(value);
        tmp.value().next = pos.end;
        tmp.value().prev = pos.end.value().prev;
        pos.end.value().prev.value().next = tmp;
        pos.end.value().prev = tmp;
        ++listSize;
    }

    fun insertAfter(range: Range, pos: RangeType)
    {
        for ( v = range )
            insertAfter(v, pos);
    }

    fun pushFront(value: @ValueType)
    {
        var tmp = NodeTypePtr.alloc(1);

        tmp.value().data.ctor(value);
        tmp.value().next = head.next;
        tmp.value().prev = headNode();
        head.next.value().prev = tmp;
        head.next = tmp;
        ++listSize;
    }

    fun popFront
    {
        var right = head.next.value().next;

        head.next.value().data.dtor();
        head.next.freePtr();
        head.next = right;
        right.value().prev = headNode();
        listSize = listSize - 1;
    }

    fun pushBack(value: @ValueType)
    {
        var tmp = NodeTypePtr.alloc(1);

        tmp.value().prev = head.prev;
        tmp.value().next = headNode();
        tmp.value().data.ctor(value);
        head.prev.value().next = tmp;
        head.prev = tmp;
        ++listSize;
    }
    fun +=(value: @ValueType) { pushBack(value); }

    fun popBack
    {
        var left = head.prev.value().prev;

        head.prev.value().data.dtor();
        head.prev.freePtr();
        head.prev = left;
        left.value().next = headNode();
        listSize = listSize - 1;
    }

    fun remove(value: @ValueType)
    {
        var p = head.next;
        var hn = headNode();

        while ( p != hn )
        {
            var tmp = p.value().next;

            if ( p.value().data == value )
            {
                p.value().prev.value().next = p.value().next;
                p.value().next.value().prev = p.value().prev;
                p.value().data.dtor();
                p.freePtr();
                listSize = listSize - 1;
            }
            p = tmp;
        }
    }

    fun removeIf(pred: AnyType)
    {
        var p = head.next;
        var hn = headNode();

        while ( p != hn )
        {
            var tmp = p.value().next;

            if ( pred(p.value().data) )
            {
                p.value().prev.value().next = p.value().next;
                p.value().next.value().prev = p.value().prev;
                p.value().data.dtor();
                p.freePtr();
                listSize = listSize - 1;
            }
            p = tmp;
        }
    }

    fun remove(range: RangeType)
    {
        var left = range.begin.value().prev;

        while ( !range.isEmpty() )
        {
            var tmp = range.begin.value().next;

            range.begin.value().data.dtor();
            range.begin.freePtr();
            listSize = listSize - 1;
            range.begin = tmp;
        }
        left.value().next = range.end;
        range.end.value().prev = left;
    }

    fun resize(n: SizeType)
    {
        if ( n == listSize )
            return;

        if ( n < listSize )
        {
            var p = head.prev;
            var t = listSize - n;

            listSize = listSize - t;
            while ( t > 0 ; t -= 1 )
            {
                var tmp = p.value().prev;

                p.value().data.dtor();
                p.freePtr();
                p = tmp;
            }
            p.value().next = headNode();
            head.prev = p;
        }
        else
        {
            // TODO: Find a proper way of doing this
            if[ct] ( isValid(pushBack(ValueType())) )
            {
                pushBack(ValueType());
                while ( n > listSize )
                    pushBack(ValueType());
            }
        }
    }

    fun clear
    {
        if ( listSize == 0 )
            return;

        var p = head.next;
        var hn = headNode();

        while ( p != hn )
        {
            var tmp = p.value().next;

            p.value().data.dtor();
            p.freePtr();
            p = tmp;
        }
        head.next = hn;
        head.prev = hn;
        listSize = 0;
    }

    fun unique
    {
        if ( listSize <= 1 )
            return;

        var p = head.next;
        var hn = headNode();

        while ( p != hn )
        {
            var q = p.value().next;

            while ( q != hn && p.value().data == q.value().data )
            {
                var tmp = q.value().next;

                q.value().data.dtor();
                q.freePtr();
                q = tmp;
                listSize = listSize - 1;
            }
            if ( p.value().next != q )
            {
                p.value().next = q;
                q.value().prev = p;
            }
            p = q;
        }
    }

    fun unique(pred: AnyType)
    {
        if ( listSize <= 1 )
            return;

        var p = head.next;
        var hn = headNode();

        while ( p != hn )
        {
            var q = p.value().next;

            while ( q != hn && pred(p.value().data, q.value().data) )
            {
                var tmp = q.value().next;

                q.value().data.dtor();
                q.freePtr();
                q = tmp;
                listSize = listSize - 1;
            }
            if ( p.value().next != q )
            {
                p.value().next = q;
                q.value().prev = p;
            }
            p = q;
        }
    }

    fun spliceBefore(pos: RangeType, other: @List)
    {
        if ( !other.isEmpty() )
        {
            transfer(pos.begin, other.head.next, other.headNode());
            listSize = listSize + other.listSize;
            other.listSize = 0;
        }
    }

    fun spliceBefore(pos: RangeType, other: @List, range: RangeType)
    {
        if ( !range.isEmpty() )
        {
            var tmp = range;

            if ( headNode() != other.headNode() )
            {
                var t = 0;

                while ( !tmp.isEmpty() )
                {
                    tmp.popFront();
                    ++t;
                }
                listSize += t;
                other.listSize -= t;
            }
            transfer(pos.begin, range.begin, range.end);
        }
    }

    fun spliceAfter(pos: RangeType, other: @List)
    {
        if ( !other.isEmpty() )
        {
            transfer(pos.end, other.head.next, other.headNode());
            listSize = listSize + other.listSize;
            other.listSize = 0;
        }
    }

    fun spliceAfter(pos: RangeType, other: @List, range: RangeType)
    {
        if ( !range.isEmpty() )
        {
            var tmp = range;

            if ( headNode() != other.headNode() )
            {
                var t = 0;

                while ( !tmp.isEmpty() )
                {
                    tmp.popFront();
                    t = t + 1;
                }
                listSize = listSize + t;
                other.listSize = other.listSize - t;
            }
            transfer(pos.end, range.begin, range.end);
        }
    }

    // fun sort()
    // {
        // if ( listSize < 2 )
            // return;

        // var carry: List;
        // var counter = Array(List)(64);
        // var fill = 0;

        // while ( !isEmpty() )
        // {
            // var r = all();

            // r.end = r.begin.value().next;
            // carry.spliceBefore(carry.all(), this, r);

            // var i = 0;

            // while ( i < fill && !counter(i).isEmpty() ; ++i )
            // {
                // counter(i).merge(carry);
                // carry.swap(counter(i));
            // }
            // carry.swap(counter(i));
            // if ( i == fill )
                // ++fill;
        // }

        // var i = 1;

        // while ( i < fill ; ++i )
            // counter(i).merge(counter(i - 1));
        // swap(counter(fill - 1));
    // }

    fun sort(pred: AnyType)
    {
        if ( listSize < 2 )
            return;

        var carry: List;
        var counter = Array(List)(64);
        var fill = 0;

        while ( !isEmpty() )
        {
            var r = all();

            r.end = r.begin.value().next;
            carry.spliceBefore(carry.all(), this, r);

            var i = 0;

            while ( i < fill && !counter(i).isEmpty() ; ++i )
            {
                counter(i).merge(carry, pred);
                carry.swap(counter(i));
            }
            carry.swap(counter(i));
            if ( i == fill )
                ++fill;
        }

        var i = 1;

        while ( i < fill ; ++i )
            counter(i).merge(counter(i - 1), pred);
        swap(counter(fill - 1));
    }

    // fun merge(other: @List)
    // {
        // var r1 = all();
        // var r2 = other.all();

        // while ( !r1.isEmpty() && !r2.isEmpty() )
        // {
            // if ( r2.front() < r1.front() )
            // {
                // var tmp = r2.begin.value().next;

                // transfer(r1.begin, r2.begin, tmp);
                // r2.begin = tmp;
            // }
            // else
                // r1.popFront();
        // }
        // if ( !r2.isEmpty() )
            // transfer(r1.end, r2.begin, r2.end);
        // listSize = listSize + other.listSize;
        // other.listSize = 0;
    // }

    fun merge(other: @List, pred: AnyType)
    {
        var r1 = all();
        var r2 = other.all();

        while ( !r1.isEmpty() && !r2.isEmpty() )
        {
            if ( pred(r2.front(), r1.front()) )
            {
                var tmp = r2.begin.value().next;

                transfer(r1.begin, r2.begin, tmp);
                r2.begin = tmp;
            }
            else
                r1.popFront();
        }
        if ( !r2.isEmpty() )
            transfer(r1.end, r2.begin, r2.end);
        listSize = listSize + other.listSize;
        other.listSize = 0;
    }

    fun reverse()
    {
        if ( listSize < 2 )
            return;

        var p = head.next;
        var hn = headNode();

        while ( p != hn )
        {
            var tmp = p.value().prev;

            p.value().prev = p.value().next;
            p.value().next = tmp;
            p = p.value().prev;
        }

        var tmp = head.prev;

        head.prev = head.next;
        head.next = tmp;
    }

    fun =(other: @List)
    {
        var tmp = other;
        swap(tmp);
    }

    fun ==(other: @List): Bool
    {
        if ( listSize != other.listSize )
            return false;

        var r1 = all();
        var r2 = other.all();

        while ( !r1.isEmpty() )
        {
            if ( !(r1.front() == r2.front()) )
                return false;

            r1.popFront();
            r2.popFront();
        }

        return true;
    }

    private using NodeTypePtr = RawPtr(NodeType);

    private var head: NodeLinks;
    private var listSize: SizeType;

    private fun headNode = NodeTypePtr.fromRef(reinterpretCast(@NodeType, head));

    private fun[static] transfer(pos, begin, end: NodeTypePtr)
    {
        end.value().prev.value().next = pos;
        begin.value().prev.value().next = end;
        pos.value().prev.value().next = begin;

        var tmp = pos.value().prev;

        pos.value().prev = end.value().prev;
        end.value().prev = begin.value().prev;
        begin.value().prev = tmp;
    }

    private class NodeLinks
    {
        var prev, next: RawPtr(NodeType);
    }

    private class NodeType
    {
        var prev, next: RawPtr(NodeType);
        var data: ValueType;
    }

    class[initCtor] ListRange
    {
        using RetType = @ValueType;

        fun isEmpty         = begin == end;

        fun front: RetType  = begin.value().data;
        fun back: RetType   = end.value().prev.value().data;

        fun popFront        { begin = begin.value().next; }
        fun popBack         { end = end.value().prev; }

        private var begin, end: NodeTypePtr;

        fun >>(os: @OutStream) if isValid(os << #$ValueType)
        {
            var first = true;
            var p = begin;
            while ( p != end ; p = p.value().next )
            {
                if ( first )
                    first = false;
                else
                    os << ", ";
                os << p.value().data;
            }
        }
    }
}
