module std.optional;

/// A container that may or may not store a value.
/// One can check whether the value is defined or not, and can access the value
class Optional(valueType: Type)
{
    using ValueType = valueType;

    [noDefault] fun ctor
    {
        _constructed ctor false;
        _value ctor Uninitialized();
    }
    [noDefault] fun ctor(other: @Optional)
    {
        _constructed ctor other._constructed;
        if ( other._constructed )
            _value ctor other._value;
    }
    [noDefault] fun ctor(val: @ValueType)
    {
        _constructed ctor true;
        _value ctor val;
    }
    [noDefault] fun dtor
    {
        reset();
    }

    fun isNull                                      = !_constructed;
    fun isSet                                       = _constructed;
    fun get: @ValueType                             = _value;
    fun getOrElse(default: @ValueType): @ValueType  = ife(_constructed, cast(@ValueType, _value), default);

    fun reset
    {
        if ( _constructed )
            _value dtor;
        _constructed = false;
    }
    fun reset(val: @ValueType)
    {
        if ( _constructed )
            _value dtor;
        _value ctor val;
        _constructed = true;
    }

    fun swap(other: @Optional)
    {
        var tmp = this;
        this = other;
        other = this;
    }

    fun =(other: @Optional)     { if ( other._constructed ) reset(other._value); else reset(); }
    fun =(val: @ValueType)      { reset(val); }

    fun ==(other: Optional)     = _constructed == other._constructed && (!_constructed || _value == other._value);

    fun >>(os: @OutStream) if isValid(os << #$ValueType)
    {
        if ( isSet() )
            os << "Optional(" << _value << ")";
        else
            os << "Optional(none)";
        os << flush;
    }

    var _value: ValueType;
    var _constructed: Bool;
}

fun some(x: @AnyType): -@typeOf(x) Optional = (-@typeOf(x) Optional)(x);
fun none(t: Type) = (t Optional)();

