module std.ptr;

import meta.sparrowNodes, meta.featherNodes;
import newDelete(delete);

class[rtct] Ptr(type: Type)
{
    using ValueType = type;

    fun ctor                    = _ptr := null;
    fun ctor(other: Ptr)        = _ptr := other._ptr;
    fun[convert] ctor(ref: @ValueType)   = _ptr := ref;

    fun get: @ValueType         = _ptr;
    fun isNull                  = _ptr === null;
    fun isSet                   = _ptr !== null;

    fun reset                   = _ptr := null;
    fun reset(ref: @ValueType)  = _ptr := ref;
    fun release                 { delete(_ptr); }

    fun swap(other: @Ptr)
    {
        var t: @ValueType = _ptr;
        _ptr := other._ptr;
        other._ptr := t;
    }

    fun =(other: Ptr)           = _ptr := other._ptr;
    fun =(ref: @ValueType)      = _ptr := ref;

    fun ==(other: Ptr)          = _ptr === other._ptr;
    fun < (other: Ptr)          = ptrDiff(reinterpretCast(@Byte, this._ptr), reinterpretCast(@Byte, other._ptr)) < DiffType(0);

    fun >>(os: @OutStream) if isValid(os << #$ValueType)
    {
        if ( _ptr !== null )
            os << "Ptr(" << _ptr << ")";
        else
            os << "Ptr(null)";
        os << flush;
    }

    var _ptr: @ValueType;
}

fun[rtct] reinterpretPtr(t: Type, ptr: AnyType): Ptr(t) //if isValid(p.isNull()) && isValid(p.get())
{
    return Ptr(t)(reinterpretCast(@t, ptr.get()));
}


fun[rtct, macro] ->(base, id: CompilerAstNode): CompilerAstNode
{
    // Expand to: <base>.get().<id>
    var loc = base location;
    var dotGet = mkInfixOp(loc, "__dot__", AstNode(base), mkIdentifier(loc, "get"));
    var getCall = mkInfixOp(loc, "__fapp__", dotGet, mkNodeList(loc));
    return mkInfixOp(loc, "__dot__", getCall, id);
}
using oper_precedence_-> = oper_precedence___dot__;
