module std.ptr

import meta.sparrowNodes, meta.featherNodes
import newDelete(delete)

[rtct]
    class Ptr(type: Type)
        using ValueType = type

        var _ptr: @ValueType

        fun ctor(this: @Ptr)                    = _ptr := null
        fun ctor(this: @Ptr, other: Ptr)        = _ptr := other._ptr
        [convert] fun ctor(this: @Ptr, ref: @ValueType)   = _ptr := ref

[rtct, protected]
    fun =(this, other: @Ptr)           = _ptr := other._ptr
    fun =(this: @Ptr, ref: @this.ValueType) = _ptr := ref

    fun ==(this, other: Ptr)          = _ptr === other._ptr
    fun < (this, other: Ptr)          = ptrDiff(reinterpretCast(@Byte, this._ptr), reinterpretCast(@Byte, other._ptr)) < DiffType(0)

    fun get(this: Ptr): @ValueType         = _ptr
    fun isNull(this: Ptr)                  = _ptr === null
    fun isSet(this: Ptr)                   = _ptr !== null

    fun reset(this: @Ptr)                  = _ptr := null
    fun reset(this: @Ptr, ref: @this.ValueType)  = _ptr := ref
    fun release(this: @Ptr)                { delete(_ptr); }

    fun swap(this: @Ptr, other: typeOf(this))
        var t: @ValueType = _ptr
        _ptr := other._ptr
        other._ptr := t

    fun >>(this: Ptr, os: @OutStream) if isValid(os << #$ValueType)
        if ( _ptr !== null )
            os << "Ptr(" << _ptr << ")"
        else
            os << "Ptr(null)"
        os << flush

[rtct]
    fun reinterpretPtr(t: Type, ptr: AnyType): Ptr(t) //if isValid(p.isNull()) && isValid(p.get())
        return Ptr(t)(reinterpretCast(@t, ptr.get()))

    [macro] fun ->(base, id: CompilerAstNode): CompilerAstNode
        // Expand to: <base>.get().<id>
        var loc = base location
        var dotGet = mkInfixOp(loc, "__dot__", AstNode(base), mkIdentifier(loc, "get"))
        var getCall = mkInfixOp(loc, "__fapp__", dotGet, mkNodeList(loc))
        return mkInfixOp(loc, "__dot__", getCall, id)

using oper_precedence_-> = oper_precedence___dot__
