import contiguousMemoryRange;
import math;
import tuple;
import staticArray;
import sprCore.numericLimits;

concept Range(x)
    if typeOf(x.RetType) == Type
    && typeOf(x.isEmpty()) == Bool
    && typeOf(x.front()) == x.RetType
    && isValid(x.popFront())
    ;

concept BidirRange(x: Range)
    if typeOf(x.back()) == x.RetType
    && isValid(x.popBack())
    ;

concept RandomAccessRange(x: BidirRange)
    if typeOf(x.size()) == SizeType
    && typeOf(x(0)) == x.RetType
    ;


// Pre and post ++/-- operators on Ranges
fun[rtct] pre_++(r: @Range): r.RetType
{
    r.popFront();
    return r.front();
}
fun[rtct] post_++(r: @Range): r.RetType
{
    var res = r.front();
    r.popFront();
    return res;
}
fun[rtct] pre_--(r: @BidirRange): r.RetType
{
    r.popBack();
    return r.back();
}
fun[rtct] post_--(r: @BidirRange): r.RetType
{
    var res = r.back();
    r.popBack();
    return res;
}
fun[rtct] pre_!(r: @Range) = r.isEmpty();
fun[rtct] pre_!!(r: @Range) = !r.isEmpty();
fun[rtct] pre_*(r: @Range): r.RetType = r.front();

// Call operator on range == range.front()
//fun post_()(r: @Range) = r.front();


fun[rtct] rangeSize(range: Range): SizeType
{
    var n: SizeType = 0;
    while ( !range.isEmpty(); range.popFront() )
        ++n;
    return n;
}

fun[rtct] rangeSize(range: RandomAccessRange): SizeType
{
    return range.size();
}


fun advance(range: @Range, n: SizeType)
{
    while ( n > 0 ; n -= 1 )
        range.popFront();
}

fun advanceIf(range: @Range, pred: AnyType)
{
    while ( !range.isEmpty() && pred(range.front()) )
        range.popFront();
}

fun retract(range: @BidirRange, n: SizeType)
{
    while ( n > 0 ; n -= 1 )
        range.popBack();
}

fun retractIf(range: @BidirRange, pred: AnyType)
{
    while ( !range.isEmpty() && pred(range.back) )
        range.popBack();
}



fun numericRange(start, end, step: Number) = NumericRangeWithStep(commonType(typeOf(start), typeOf(end)))(start, end, step);
fun numericRange(start, end: Number) = NumericRangeInc(commonType(typeOf(start), typeOf(end)))(start, end);

fun[rtct] ..(start, end: Number) = NumericRangeInc(commonType(typeOf(start), typeOf(end)))(start, end);
fun[rtct] ...(start, end: Number) = NumericRangeInc(commonType(typeOf(start), typeOf(end)))(start, end, true);
fun[rtct] post_..(start: Number) = NumericRangeInc(typeOf(start))(start, NumericLimits(typeOf(start)).maxValue);

// TODO (LucTeo): Make concepts out of generics
fun[rtct] ../(range: Range, step: Number) = NumericRangeWithStep(range.RetType)(range, step);


fun retro(range: BidirRange) = RetroRange(typeOf(range))(range);

fun[rtct] take(range: Range, count: SizeType) = TakeRange(typeOf(range))(range, count);

fun skip(range: Range, count: SizeType): typeOf(range) { advance(range, count); return range; }

fun takeWhile(range: Range, pred: AnyType) = TakeWhileRange(typeOf(range), typeOf(pred))(range, pred);
fun takeWhile(range: Range, pred: AnyType, count: SizeType) = take(takeWhile(range, pred), count);

fun takeUntil(range: Range, pred: AnyType) = TakeUntilRange(typeOf(range), typeOf(pred))(range, pred);
fun takeUntil(range: Range, pred: AnyType, count: SizeType) = take(takeUntil(range, pred), count);

fun filter(range: Range, pred: AnyType) = FilteredRange(typeOf(range), typeOf(pred))(range, pred);

fun[rtct] transform(range: Range, function: AnyType) = TransformedRange(typeOf(range), typeOf(function))(range, function);
fun map(range: Range, function: AnyType) = TransformedRange(typeOf(range), typeOf(function))(range, function);

fun repeat(value: AnyType) = RepeatRange(typeOf(value))(value);
fun repeat(value: AnyType, count: SizeType) = take(repeat(value), count);

fun chain(range1, range2: Range) = ChainRange(typeOf(range1), typeOf(range2))(range1, range2);
fun ++(range1, range2: Range) = ChainRange(typeOf(range1), typeOf(range2))(range1, range2);

fun stride(range: Range, strideStep: SizeType) = StridedRange(typeOf(range))(range, strideStep);

fun radial(range: Range, index: SizeType) = RadialRange(typeOf(range))(range, index);

fun cycle(range: Range) = CyclicRange(typeOf(range))(range);
fun cycle(range: Range, count: SizeType) = CyclicCountedRange(typeOf(range))(range, count);

fun generate(function: AnyType) = GeneratedRange(typeOf(function))(function);
fun generate(function: AnyType, count: SizeType) = take(generate(function), count);

fun generate1(start: AnyType, function: AnyType) = Generated1Range(typeOf(start), typeOf(function))(start, function);
fun generate1(start: AnyType, function: AnyType, count: SizeType) = take(generate1(start, function), count);

fun zip(range1, range2: Range, function: AnyType) = ZippedRange(typeOf(range1), typeOf(range2), typeOf(function))(range1, range2, function);
fun zip(range1, range2: Range) = zip(range1, range2, MakePair(-@typeOf(range1.front()), -@typeOf(range2.front()))());

fun scanLeft(acc: AnyType, range: Range, function: AnyType) = ScanLeftRange(typeOf(acc), typeOf(range), typeOf(function))(acc, range, function);


class[rtct] NumericRangeInc(valueType: Type) if Number(#$valueType)
{
    private var begin, end: valueType;
    private var closed: Bool;
    private using step = valueType(1);

    using RetType = valueType;

    fun ctor(start, end: valueType)
    {
        this.begin ctor start;
        this.end ctor end;
        this.closed ctor false;
    }

    fun ctor(start, end: valueType, closed: Bool)
    {
        this.begin ctor start;
        this.end ctor end;
        this.closed ctor closed;
    }

    fun isEmpty                     = ife(closed, begin > end, begin >= end);
    fun front: RetType              = begin;
    fun popFront                    { begin += step; }

    fun back: RetType               = begin + cvt(size()-1);
    fun popBack                     { end -= step; }

    fun size: SizeType              = SizeType(ife(closed, valueType(end-begin+1), end-begin));
    
    fun popFront(n: SizeType)       { begin += cvt(n); }
    fun popBack(n: SizeType)        { end -= cvt(n); }

    fun ()(n: SizeType): RetType    = begin + cvt(n);

    private fun cvt(n: AnyType): valueType
    {
        var res: valueType = n;
        return res;
    }
}

class[rtct] NumericRangeWithStep(valueType: Type) if Number(#$valueType)
{
    private var begin, end, step: valueType;
    private var closed: Bool;

    using RetType = valueType;

    fun ctor(other: @NumericRangeInc(valueType))
    {
        this.begin ctor other.begin;
        this.end ctor other.end;
        this.closed ctor other.closed;
        if ( begin <= end )
            step = valueType(1);
        else
            step = valueType(-1);
    }

    fun ctor(other: @NumericRangeInc(valueType), step: valueType)
    {
        this.begin ctor other.begin;
        this.end ctor other.end;
        this.closed ctor other.closed;
        this.step ctor step;
    }

    fun ctor(start, end: valueType)
    {
        this.begin ctor start;
        this.end ctor end;
        this.closed ctor false;
        if ( start <= end )
            step = valueType(1);
        else
            step = valueType(-1);
    }

    fun ctor(start, end: valueType, closed: Bool)
    {
        this.begin ctor start;
        this.end ctor end;
        this.closed ctor closed;
        if ( start <= end )
            step = valueType(1);
        else
            step = valueType(-1);
    }

    fun ctor(start, end, step: valueType)
    {
        this.begin ctor start;
        this.end ctor end;
        this.step ctor step;
        this.closed ctor false;
    }

    fun isEmpty: Bool
    {
        if ( closed )
            return ife(step < 0, begin < end, begin > end);
        else
            return ife(step < 0, begin <= end, begin >= end);
    }
    fun front: RetType              = begin;
    fun popFront                    { begin += step; }

    fun back: RetType               = begin + cvt(size()-1)*step;
    fun popBack                     { end -= step; }

    fun size: SizeType              = SizeType(math.floor(ife(closed, end-begin, end-begin+step)/step));
    
    fun popFront(n: SizeType)       { begin += cvt(n*step); }
    fun popBack(n: SizeType)        { end -= cvt(n*step); }

    fun ()(n: SizeType): RetType    = begin + cvt(n*step);

    private fun diff = end-begin;

    private fun cvt(n: AnyType): valueType
    {
        var res: valueType = n;
        return res;
    }
}

class[initCtor] RetroRange(rangeType: Type) if BidirRange(#$rangeType)
{    
    private var range: rangeType;    

    using RetType = rangeType.RetType;

    fun isEmpty                     = range.isEmpty();
    fun front: RetType              = range.back();
    fun popFront                    { range.popBack(); }

    fun back: RetType               = range.front();
    fun popBack                     { range.popFront(); }
}

class[rtct, initCtor] TakeRange(rangeType: Type) if Range(#$rangeType)
{
    private var range: rangeType;
    private var count: SizeType;

    using RetType = rangeType.RetType;

    fun isEmpty                     = count == 0 || range.isEmpty();
    fun front: RetType              = range.front();
    fun popFront                    { range.popFront(); --count; }
}

class[initCtor] TakeWhileRange(rangeType: Type, predType: Type) if Range(#$rangeType)
{
    private var range: rangeType;
    private var pred: predType;

    using RetType = rangeType.RetType;

    fun isEmpty                     = range.isEmpty() || !pred(range.front());
    fun front: RetType              = range.front();
    fun popFront                    { range.popFront(); }
}

class[initCtor] TakeUntilRange(rangeType: Type, predType: Type) if Range(#$rangeType)
{
    private var range: rangeType;
    private var pred: predType;
    private var shouldStop: Bool;

    using RetType = rangeType.RetType;

    fun ctor(range: rangeType, pred: predType)
    {
        this.range ctor range;
        this.pred ctor pred;
        shouldStop = false;
    }

    fun isEmpty                     = range.isEmpty() || shouldStop;
    fun front: RetType              = range.front();
    fun popFront
    {
        var lastVal = range.front();
        range.popFront();
        shouldStop = pred(lastVal);
    }
}

class FilteredRange(rangeType, predType: Type) if Range(#$rangeType) && typeOf((#$predType)(#$rangeType front)) == Bool
{
    private var range: rangeType; 
    private var pred: predType;
    private var lastVal: RetType;

    using RetType = -@rangeType.RetType;
    
    fun ctor(range: rangeType, pred: predType)
    {
        this.range ctor range;
        this.pred ctor pred;
        this.lastVal ctor;
        popUntilValid;
    }

    fun isEmpty                     = range.isEmpty();
    fun front: RetType              = lastVal;
    fun popFront                    { range.popFront(); popUntilValid; }

    private fun popUntilValid
    {
        while ( !range.isEmpty )
        {
            lastVal = range.front();
            if ( pred(lastVal) )
                break;
            range.popFront();
        }
    }
}

class[rtct] TransformedRange(rangeType, funType: Type) if Range(#$rangeType) && isValid((#$funType)(#$rangeType front))
{
    private var range: rangeType;
    private var function: funType;
    private var curVal: RetType;
    private var hasValue: Bool;

    using RetType = -@typeOf((#$funType)(#$rangeType front));

    fun ctor(range: rangeType, function: funType)
    {
        this.range ctor range;
        this.function ctor function;
        this.curVal ctor;
        this.hasValue ctor false;
    }

    fun isEmpty                     = range.isEmpty();
    fun front: RetType
    {
        if ( !hasValue )
        {
            curVal = function(range.front());
            hasValue = true;
        }
        return curVal;
    }
    fun popFront                    { range.popFront(); hasValue = false; }
}

class[initCtor] RepeatRange(valueType: Type)
{    
    private var value: valueType;   

    using RetType = valueType;

    fun isEmpty                     = false;
    fun front: RetType              = value;
    fun popFront                    {}
}

class[initCtor] ChainRange(rangeType1: Type, rangeType2: Type) if Range(#$rangeType1) && Range(#$rangeType2)
{
    private var range1: rangeType1;
    private var range2: rangeType2;

    using RetType = commonType(rangeType1.RetType, rangeType2.RetType);

    fun isEmpty                 = range1.isEmpty() && range2.isEmpty();
    fun front: RetType          = ife(range1.isEmpty(), range2.front(), range1.front());
    fun popFront
    {
        if ( range1.isEmpty() )
            range2.popFront();
        else
            range1.popFront();
    }
}

class[initCtor] StridedRange(rangeType: Type) if Range(#$rangeType)
{
    private var range: rangeType;
    private var strideStep: SizeType;

    using RetType = rangeType.RetType;

    fun isEmpty                     = range.isEmpty();
    fun front: RetType              = range.front();
    fun popFront
    {
        var s = strideStep;

        while ( !range.isEmpty() && s > 0 )
        {
            s = s - 1;
            range.popFront();
        }
    }
}

class RadialRange(rangeType: Type) if RandomAccessRange(#$rangeType)
{
    private var range: rangeType;   
    private var index, count: SizeType;
    private var step, sign: DiffType; 

    using RetType = rangeType.RetType;
    
    fun ctor(range: rangeType, index: SizeType)
    {
        this.range ctor range;
        this.index ctor index;
        this.step ctor 1;
        this.sign ctor 1;
        this.count ctor 0;
    }
        
    fun isEmpty                     = range.isEmpty() || count == range.size();
    fun front: RetType              = range(index);
    fun popFront
    {
        index = index + step * sign;
        step = step + 1;
        sign = -sign;
        count = count + 1;
        while ( (index < 0 || index >= range.size()) && count < range.size() )
        {
            index = index + step * sign;
            step = step + 1;
            sign = -sign;       
        }
    }
}

class CyclicRange(rangeType: Type) if Range(#$rangeType)
{   
    private var range, base: rangeType;

    using RetType = rangeType.RetType;
        
    fun ctor(range: rangeType)
    {
        this.range ctor range;
        this.base ctor range;
    }
    
    fun isEmpty                     = false;
    fun front: RetType              = range.front();
    fun popFront
    {
        range.popFront();
        if ( range.isEmpty() )
            range = base;
    }
}

class CyclicCountedRange(rangeType: Type) if Range(#$rangeType)
{
    private var range, base: rangeType;   
    private var count: SizeType;    

    using RetType = rangeType.RetType;

    fun ctor(range: rangeType, count: SizeType)
    {
        this.range ctor range;
        this.count ctor count;
        this.base ctor range;
    }
        
    fun isEmpty                     = count == 0;
    fun front: RetType              = range.front();
    fun popFront
    {
        range.popFront();
        if ( range.isEmpty() )
        {
            if ( count > 0 )
            {
                range = base;
                --count;
            }
        }
    }
}

class GeneratedRange(functionType: Type)
{
    private var function: functionType; 
    private var current: RetType; 

    using RetType = typeOf((#$functionType)());
    
    fun ctor(function: functionType)
    {
        this.function ctor function;
        this.current ctor this.function();
    }
        
    fun isEmpty                     = false;
    fun front: RetType              = current;
    fun popFront                    { current = function(); }
}

class Generated1Range(elType, functionType: Type) //if isValid(elType(#$functionType)(#$elType))
{
    private var function: functionType; 
    private var current: RetType; 

    using RetType = elType;
    
    fun ctor(initialValue: RetType, function: functionType)
    {
        this.function ctor function;
        this.current ctor initialValue;
    }
        
    fun isEmpty                     = false;
    fun front: RetType              = current;
    fun popFront                    { current = function(current); }
}

class[initCtor] ZippedRange(rangeType1, rangeType2: Type, functionType: Type) if Range(#$rangeType1) &&  Range(#$rangeType2)
{
    private var range1: rangeType1; 
    private var range2: rangeType2;
    private var function: functionType; 

    using RetType = typeOf((#$functionType)(#$rangeType1 front, #$rangeType2 front));
    
    fun isEmpty                     = range1.isEmpty() || range2.isEmpty();
    fun front: RetType              = function(range1.front(), range2.front());
    fun popFront                    { range1.popFront(); range2.popFront(); }
}

class ScanLeftRange(accType, rangeType: Type, functionType: Type) if Range(#$rangeType)
{
    private var acc: accType;
    private var range: rangeType; 
    private var function: functionType; 
    private var valComputed: Bool;

    using RetType = accType;

    fun ctor(acc: accType, range: rangeType, function: functionType)
    {
        this.acc ctor acc;
        this.range ctor range;
        this.function ctor function;
        this.valComputed ctor false;
    }
    
    fun isEmpty         = range.isEmpty();
    fun popFront        { range.popFront(); valComputed=false; }
    fun front: RetType
    {
        if ( !valComputed )
            acc = function(acc, range.front());
        valComputed=true;
        return acc;
    }
}

class ValuesRange(contType: Type) if isValid((#$contType)(1))
{
    private var values: contType;
    private var idx: SizeType;

    fun ctor(values: @contType)
    {
        this.values ctor values;
        idx = 0;
    }

    fun ctor(other: @ValuesRange)
    {
        this.values ctor other.values;
        this.idx ctor other.idx;
    }

    using RetType       = contType.ValueType;
    fun isEmpty         = idx >= values.size;
    fun popFront        { ++idx; }
    fun front: RetType  = values(idx);
}
fun mkValuesRange(cont: AnyType) = ValuesRange(typeOf(cont))(cont);


fun values(v0,v1: AnyType) = mkValuesRange(mkValues(v0,v1));
fun values(v0,v1,v2: AnyType) = mkValuesRange(mkValues(v0,v1,v2));
fun values(v0,v1,v2,v3: AnyType) = mkValuesRange(mkValues(v0,v1,v2,v3));
fun values(v0,v1,v2,v3,v4: AnyType) = mkValuesRange(mkValues(v0,v1,v2,v3,v4));
fun values(v0,v1,v2,v3,v4,v5: AnyType) = mkValuesRange(mkValues(v0,v1,v2,v3,v4,v5));
fun values(v0,v1,v2,v3,v4,v5,v6: AnyType) = mkValuesRange(mkValues(v0,v1,v2,v3,v4,v5,v6));
fun values(v0,v1,v2,v3,v4,v5,v6,v7: AnyType) = mkValuesRange(mkValues(v0,v1,v2,v3,v4,v5,v6,v7));
fun values(v0,v1,v2,v3,v4,v5,v6,v7,v8: AnyType) = mkValuesRange(mkValues(v0,v1,v2,v3,v4,v5,v6,v7,v8));
fun values(v0,v1,v2,v3,v4,v5,v6,v7,v8,v9: AnyType) = mkValuesRange(mkValues(v0,v1,v2,v3,v4,v5,v6,v7,v8,v9));
