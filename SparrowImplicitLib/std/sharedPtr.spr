module std.sharedPtr;

import newDelete(new, delete);

class[rtct] SharedPtr(type: Type)
{
    using ValueType = type;

    fun ctor
    {
        _ref := null;
        _count := null;
    }

    fun[convert] ctor(value: @ValueType)
    {
        if ( value === null )
        {
            this._ref := null;
            this._count := null;
        }
        else
        {
            var d: @_AllocData = new(_AllocData, value);
            this._ref := d.data;
            this._count := d._count;
        }
    }

    fun ctor(other: @SharedPtr)
    {
        _ref := other._ref;
        _count := other._count;
        if ( _count !== null )
            ++_count;
    }

    fun dtor
    {
        if ( _count !== null && --_count == 0 )
        {
            _ref.dtor();
            delete(_count);
        }
    }

    fun[static] create: SharedPtr
    {
        var res: SharedPtr;
        var d: @_AllocData = new(_AllocData);
        res._ref := d.data;
        res._count := d._count;
        return res;
    }
    fun[static] create(arg1: @AnyType): SharedPtr if isValid((#$ValueType).ctor(arg1))
    {
        var res: SharedPtr;
        var d: @_AllocData = new(_AllocData, arg1);
        res._ref := d.data;
        res._count := d._count;
        return res;
    }
    fun[static] create(arg1, arg2: @AnyType): SharedPtr if isValid((#$ValueType).ctor(arg1, arg2))
    {
        var res: SharedPtr;
        var d: @_AllocData = new(_AllocData, arg1, arg2);
        res._ref := d.data;
        res._count := d._count;
        return res;
    }
    fun[static] create(arg1, arg2, arg3: @AnyType): SharedPtr if isValid((#$ValueType).ctor(arg1, arg2, arg3))
    {
        var res: SharedPtr;
        var d: @_AllocData = new(_AllocData, arg1, arg2, arg3);
        res._ref := d.data;
        res._count := d._count;
        return res;
    }
    fun[static] create(arg1, arg2, arg3, arg4: @AnyType): SharedPtr if isValid((#$ValueType).ctor(arg1, arg2, arg3, arg4))
    {
        var res: SharedPtr;
        var d: @_AllocData = new(_AllocData, arg1, arg2, arg3, arg4);
        res._ref := d.data;
        res._count := d._count;
        return res;
    }

    fun =(other: @SharedPtr)                            { SharedPtr(other).swap(this); }
    fun =(value: @ValueType)                            { reset(value); }
    fun =(value: AnyType) if isValid(ValueType(value))  { reset(value); }

    fun get: @ValueType                                 = _ref;

    fun isUnique                                        = _count !== null && _count == 1;
    fun useCount: UInt                                  = ife(_count !== null, UInt(_count), UInt(0));

    fun isNull                                          = _ref === null;
    fun isSet                                           = _ref !== null;

    fun reset                                           { SharedPtr().swap(this); }
    fun reset(value: @ValueType)                        { SharedPtr(value).swap(this); }
    fun release                                         { reset(); }

    fun swap(other: @SharedPtr)
    {
        var tmpr: @ValueType = other._ref;
        other._ref := _ref;
        _ref := tmpr;

        var tmpc: @UInt = other._count;
        other._count := _count;
        _count := tmpc;
    }

    fun ==(other: @SharedPtr)                           = _ref === other._ref && _count === other._count;

    fun >>(os: @OutStream) if isValid(os << #$ValueType)
    {
        if ( _count !== null )
            os << "SharedPtr(" << _ref << ", " << _count << ")";
        else
            os << "SharedPtr(null)";
        os << flush;
    }

    var _ref: @ValueType;
    var _count: @UInt;

    class _AllocData
    {
        var _count: UInt;
        var data: type;

        fun ctor
        {
            _count ctor 1;
            data ctor;
        }

        fun ctor(arg1: @AnyType)
        {
            _count ctor 1;
            data ctor arg1;
        }

        fun ctor(arg1, arg2: @AnyType)
        {
            _count ctor 1;
            data.ctor(arg1, arg2);
        }

        fun ctor(arg1, arg2, arg3: @AnyType)
        {
            _count ctor 1;
            data.ctor(arg1, arg2, arg3);
        }

        fun ctor(arg1, arg2, arg3, arg4: @AnyType)
        {
            _count ctor 1;
            data.ctor(arg1, arg2, arg3, arg4);
        }
    }
}
