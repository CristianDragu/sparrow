module std.tuple;

[rtct, initCtor] class Tuple(t1, t2: Type) {
    using arity = 2;
    var v1: t1;
    var v2: t2;

    [convert] fun ctor(other: TupleType) if other.arity == 2 {
        this.v1 ctor other.v1;
        this.v2 ctor other.v2;
    }
}

[rtct, initCtor] class Tuple(t1, t2, t3: Type) {
    using arity = 3;
    var v1: t1;
    var v2: t2;
    var v3: t3;
}

[rtct, initCtor] class Tuple(t1, t2, t3, t4: Type) {
    using arity = 4;
    var v1: t1;
    var v2: t2;
    var v3: t3;
    var v4: t4;
}

[rtct, initCtor] class Tuple(t1, t2, t3, t4, t5: Type) {
    using arity = 5;
    var v1: t1;
    var v2: t2;
    var v3: t3;
    var v4: t4;
    var v5: t5;
}

[rtct, initCtor] class Tuple(t1, t2, t3, t4, t5, t6: Type) {
    using arity = 6;
    var v1: t1;
    var v2: t2;
    var v3: t3;
    var v4: t4;
    var v5: t5;
    var v6: t6;
}

[rtct, initCtor] class Tuple(t1, t2, t3, t4, t5, t6, t7: Type) {
    using arity = 7;
    var v1: t1;
    var v2: t2;
    var v3: t3;
    var v4: t4;
    var v5: t5;
    var v6: t6;
    var v7: t7;
}

[rtct, initCtor] class Tuple(t1, t2, t3, t4, t5, t6, t7, t8: Type) {
    using arity = 8;
    var v1: t1;
    var v2: t2;
    var v3: t3;
    var v4: t4;
    var v5: t5;
    var v6: t6;
    var v7: t7;
    var v8: t8;
}

[rtct, initCtor] class Tuple(t1, t2, t3, t4, t5, t6, t7, t8, t9: Type) {
    using arity = 9;
    var v1: t1;
    var v2: t2;
    var v3: t3;
    var v4: t4;
    var v5: t5;
    var v6: t6;
    var v7: t7;
    var v8: t8;
    var v9: t9;
}

[rtct, initCtor] class Tuple(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10: Type) {
    using arity = 10;
    var v1: t1;
    var v2: t2;
    var v3: t3;
    var v4: t4;
    var v5: t5;
    var v6: t6;
    var v7: t7;
    var v8: t8;
    var v9: t9;
    var v10: t10;
}

concept TupleType(x)
    if typeOf(x.arity) == Int
    && isValid(x.v1)
    && isValid(x.v2)
    ;

[rtct] fun mkTuple(v1,v2: AnyType) = Tuple(typeOf(v1), typeOf(v2))(v1,v2);
[rtct] fun mkTuple(v1,v2,v3: AnyType) = Tuple(typeOf(v1), typeOf(v2), typeOf(v3))(v1,v2,v3);
[rtct] fun mkTuple(v1,v2,v3,v4: AnyType) = Tuple(typeOf(v1), typeOf(v2), typeOf(v3), typeOf(v4))(v1,v2,v3,v4);
[rtct] fun mkTuple(v1,v2,v3,v4,v5: AnyType) = Tuple(typeOf(v1), typeOf(v2), typeOf(v3), typeOf(v4), typeOf(v5))(v1,v2,v3,v4,v5);
[rtct] fun mkTuple(v1,v2,v3,v4,v5,v6: AnyType) = Tuple(typeOf(v1), typeOf(v2), typeOf(v3), typeOf(v4), typeOf(v5), typeOf(v6))(v1,v2,v3,v4,v5,v6);
[rtct] fun mkTuple(v1,v2,v3,v4,v5,v6,v7: AnyType) = Tuple(typeOf(v1), typeOf(v2), typeOf(v3), typeOf(v4), typeOf(v5), typeOf(v6), typeOf(v7))(v1,v2,v3,v4,v5,v6,v7);
[rtct] fun mkTuple(v1,v2,v3,v4,v5,v6,v7,v8: AnyType) = Tuple(typeOf(v1), typeOf(v2), typeOf(v3), typeOf(v4), typeOf(v5), typeOf(v6), typeOf(v7), typeOf(v8))(v1,v2,v3,v4,v5,v6,v7,v8);
[rtct] fun mkTuple(v1,v2,v3,v4,v5,v6,v7,v8,v9: AnyType) = Tuple(typeOf(v1), typeOf(v2), typeOf(v3), typeOf(v4), typeOf(v5), typeOf(v6), typeOf(v7), typeOf(v8), typeOf(v9))(v1,v2,v3,v4,v5,v6,v7,v8,v9);
[rtct] fun mkTuple(v1,v2,v3,v4,v5,v6,v7,v8,v9,v10: AnyType) = Tuple(typeOf(v1), typeOf(v2), typeOf(v3), typeOf(v4), typeOf(v5), typeOf(v6), typeOf(v7), typeOf(v8), typeOf(v9), typeOf(v10))(v1,v2,v3,v4,v5,v6,v7,v8,v9,v10);

[rtct] fun ~(v1,v2: AnyType) = mkTuple(v1,v2) if !TupleType(v1);
[rtct] fun ~(t,ex: AnyType) = mkTuple(t.v1, t.v2, ex) if TupleType(t) && t.arity == 2;
[rtct] fun ~(t,ex: AnyType) = mkTuple(t.v1, t.v2, t.v3, ex) if TupleType(t) && t.arity == 3;
[rtct] fun ~(t,ex: AnyType) = mkTuple(t.v1, t.v2, t.v3, t.v4, ex) if TupleType(t) && t.arity == 4;
[rtct] fun ~(t,ex: AnyType) = mkTuple(t.v1, t.v2, t.v3, t.v4, t.v5, ex) if TupleType(t) && t.arity == 5;
[rtct] fun ~(t,ex: AnyType) = mkTuple(t.v1, t.v2, t.v3, t.v4, t.v5, t.v6, ex) if TupleType(t) && t.arity == 6;
[rtct] fun ~(t,ex: AnyType) = mkTuple(t.v1, t.v2, t.v3, t.v4, t.v5, t.v6, t.v7, ex) if TupleType(t) && t.arity == 7;
[rtct] fun ~(t,ex: AnyType) = mkTuple(t.v1, t.v2, t.v3, t.v4, t.v5, t.v6, t.v7, t.v8, ex) if TupleType(t) && t.arity == 8;
[rtct] fun ~(t,ex: AnyType) = mkTuple(t.v1, t.v2, t.v3, t.v4, t.v5, t.v6, t.v7, t.v8, t.v9, ex) if TupleType(t) && t.arity == 9;

using oper_precedence_~     = oper_precedence_*;

[ctGeneric] fun *(t1,t2: Type): Type = Tuple(t1, t2) ;//if !TupleType(#$t1);
//[ctGeneric] fun *(tt,tex: Type): Type = Tuple(typeOf(tt.v1), typeOf(tt.v2), tex) if TupleType(#$tt) && tt.arity == 2;


[rtct] fun first(t: @TupleType) = t.v1;
[rtct] fun second(t: @TupleType) = t.v2;

[rtct] fun tail(t: @TupleType) = mkTuple(t.v2, t.v3) if t.arity == 3;
[rtct] fun tail(t: @TupleType) = mkTuple(t.v2, t.v3, t.v4) if t.arity == 4;
[rtct] fun tail(t: @TupleType) = mkTuple(t.v2, t.v3, t.v4, t.v5) if t.arity == 5;
[rtct] fun tail(t: @TupleType) = mkTuple(t.v2, t.v3, t.v4, t.v5, t.v6) if t.arity == 6;
[rtct] fun tail(t: @TupleType) = mkTuple(t.v2, t.v3, t.v4, t.v5, t.v6, t.v7) if t.arity == 7;
[rtct] fun tail(t: @TupleType) = mkTuple(t.v2, t.v3, t.v4, t.v5, t.v6, t.v7, t.v8) if t.arity == 8;
[rtct] fun tail(t: @TupleType) = mkTuple(t.v2, t.v3, t.v4, t.v5, t.v6, t.v7, t.v8, t.v9) if t.arity == 9;
[rtct] fun tail(t: @TupleType) = mkTuple(t.v2, t.v3, t.v4, t.v5, t.v6, t.v7, t.v8, t.v9, t.v10) if t.arity == 10;

[rtct] fun <(lhs, rhs: TupleType) if typeOf(lhs) == typeOf(rhs) && lhs.arity == 2 {
    if ( lhs.v1 < rhs.v1 )      return true;
    else if ( rhs.v1 < lhs.v1 ) return false;
    else if ( lhs.v2 < rhs.v2 ) return true;
    return false;
}
[rtct] fun <(lhs, rhs: TupleType) if typeOf(lhs) == typeOf(rhs) && lhs.arity > 2 {
    if ( lhs.v1 < rhs.v1 )      return true;
    else if ( rhs.v1 < lhs.v1 ) return false;
    return tail(lhs) < tail(rhs);
}

[rtct] fun >>(t: @TupleType, os: @OutStream) {
    os << '(' << t.v1;
    TupleImpl.dumpTail(t, os);
    os << ')';
}

[rtct] class MakePair(firstType: Type, secondType: Type)
{
    fun ()(fst: firstType, snd: secondType): Tuple(firstType, secondType)
    {
        return Tuple(firstType, secondType)(fst, snd);
    }
}

[rtct] class PairFirst(pairType: Type)
{
    fun ()(pair: @pairType): @typeOf(pair.v1)
    {
        return pair.v1;
    }
}

[rtct] class PairSecond(pairType: Type)
{
    fun ()(pair: @pairType): @typeOf(pair.v2)
    {
        return pair.v2;
    }
}

package TupleImpl {
    fun dumpTail(t: @TupleType, os: @OutStream) if t.arity == 2 {
        os << ',' << t.v2;
    }
    fun dumpTail(t: @TupleType, os: @OutStream) if t.arity > 2 {
        os << ',' << t.v2;
        dumpTail(t tail, os);
    }
}
