Introduction
============

Mission
-------

To be a general-purpose programming language that integrates efficiency, flexibility and naturalness.


Vision and goals
----------------

Sparrow's vision is to help programmers enjoy the act of programming; the difficulty of a programming task should be *equal* to the difficulty of the problem. Not simpler, not harder. If programming is simpler than the problem itself, then the programmer loses control. And, on the long term, this has negative consequences on the programmers and their results.


General-purpose programming language
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A true general-purpose programming language is a language that is **good** at solving a large variety of programming problems. It shall be good at system programming, game programming, programming web servers and UIs. Moreover, it shall be able to adapt to new domains.

There are just a few programming languages that fit into this category. From the list of languages that are considered general-purpose, exclude all dynamic languages, all languages that use some kind of virtual-machine and all languages that have garbage collection.

Aside for the true general-purpose programming languages, we have a lot of languages that are somehow specialized in various domains (even if the languages are not domain-specific *per se*). Considering the high pace at which the domains of interest are changing in the IT industry, fundamental concepts of these programming languages are slowly becoming obsolete. Therefore, programmers will start using the wrong tools for the job.

Sparrow aims at being such a general-purpose programming language, that can be used to solve a large variety of software.

Efficiency
^^^^^^^^^^

Efficiency is a major concerns for most of the software systems, at least the large ones. We all have the frustrations of software being too slow; slower than it used to be. There are domain fields in which performance is crucial (e.g., games).

Programming languages shall allow the programmers to write efficient code. That is, they shall enable two things:

- allow programmers to write efficient code
- allow programmers to reason about how high-level code is translated into low-level constructs

For the first point, a programming language shall be able to generate code that is similar to the code generated by a C program. All the abstractions that the language uses by default shall have zero efficiency costs.

The second point is more important, and often overlooked. A programmer cannot write efficient code without being able to reason about the efficiency of the written code, even in the presence of multiple abstraction layers. Take for example C++ code written with a lot of STL and Boost templates. The user can dwell into each abstraction layer and reason about the performance impact of it. One good example is Boost.GIL; although there are a lot of abstraction layers, the compiler can generate efficient code and moreover, the user has the tools to reason about the performance of all these layers.

That is an important part of the Sparrow vision: let the programmer write high-level (natural) code, that would generate efficient binary code. Efficiency by default.

Naturalness
^^^^^^^^^^^

Programmers are the main bottleneck for software development. They have to understand the system and all its details. Pure complexity.

The main job of a programming language is to help the programmer deal with that complexity. It shall make it easier for the programmer to understand and reason about the code. The programmer shall have means for translating the software designs into code in a straight-forward way. To achieve this, programming languages must strive to provide the following:

- clean syntax
- conciseness
- coherence in its core concepts
- ability to express high-level concepts
- ability to use the appropriate programming paradigm

The items cover from the low-level machinery of writing the code, to the high-level mapping of design to code. Programming languages typically focus on the first bullets on this list, but they completely ignore the last ones. And those are the most important.

Making it easier to map design into code is one of the core goals for Sparrow. Making it possible to create (zero-cost) high-level abstractions and allowing the programmer to use the most appropriate programming paradigm are vital for this problem.

Most programming languages insist that ``if`` and ``for`` are the main tools of a programmer. They are wrong. A lot of problems can be far easier if we just use a different programming paradigm. Sometimes using a declarative approach is the easiest way to solve the problem; think for example of expressing a parser in an EBNF-like notation. Other times what makes more sense is using a query language directly.

Flexibility
^^^^^^^^^^^

Flexibility is the ability of a language to be well applied to a large variety of problems.

A flexible language shall **NOT** do the following:

- assume one programming paradigm is a silver bullet
- insist that there is a *canonical way* of solving all problems
- assume that the creator of the language knows the right tools that programmers will need in the future

Instead, a flexible programming language shall:

- be simple
- focus more on library features and less on core language features
- enable extending the language with new abstractions
- enable adding new programming paradigms to the language
- provide means of growing the programming language by its community.

Sparrow strongly believes in these principles. Sparrow aims at implementing new features and programming paradigms for the language as library extensions. This way, a small core language can be extended easily to move with the trends and best-practices in programming.

In this sense, Sparrow can be a core language that nests a lot of domain specific languages within it.

Metaprogramming
^^^^^^^^^^^^^^^

Sparrow relies on compile-time metaprogramming to improve on efficiency, naturalness and flexibility. For this vision to come true, we need a compile-time metaprogramming system that is flexible and easy to use.

We call it *hyper-metaprogramming*, and it has the following traits:

- metaprogramming is Turing complete
- metaprograms can be written with the same abstractions and constructs as traditional programs
- the syntax of metaprograms is identical to the syntax of regular programs
- semantics shall be the same
- a programmer can write data structures and algorithms that work both at compile-time and run-time without duplicating code

Sparrow has all these by default. Actually, all the code is compile-time ready, meaning that the user can invoke it during compilation. This provides an easy way of executing complex algorithms during the compilation.

This is the approach envisioned by Sparrow to be extremely flexible.

We also use metaprogramming to bridge the gap between naturalness and efficiency. We can allow the programmer to write high-level code that can be translated by the use of metaprogramming into low-level efficient code. The more information we have at compile-time, the more efficient the resulting code will be.

