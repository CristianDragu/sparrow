#pragma once

#include <Nest/Intermediate/NodeVector.h>
#include <Nest/Common/StringRef.h>

#include <boost/function.hpp>

FWD_STRUCT1(Nest, Node);
FWD_CLASS1(Nest, CompilationContext);


struct Nest_SourceCode {
    int kind;               ///< The kind of source code (parser)
    const char* url;        ///< The location of the source code
    Nest::Node* mainNode;   ///< The main node generated from this source code
    Nest::NodeVector additionalNodes; ///< Additional nodes generated for this source code
    void* additionalData;   ///< Additional data used bythe parser of the source code
};
typedef struct Nest_SourceCode Nest_SourceCode;
typedef struct Nest_SourceCode SourceCode;

/// Function that is capable to parse the given source code
void Nest_parseSourceCode(SourceCode* sourceCode, Nest::CompilationContext* ctx);

/// Function that gets a specific line from the source code
StringRef Nest_getSourceCodeLine(const SourceCode* sourceCode, int lineNum);

/// Function that translates a node from CT to RT for the given source code
Nest::Node* Nest_translateCtToRt(const SourceCode* sourceCode, Nest::Node* node);


// namespace Nest
// {
//     /// Base class for the source code classes of the compiler.
//     /// A code source object represents a file that contains source code. Such an object is able to parse the source
//     /// file and generate corresponding intermediate code and symbol table stack.
//     class DynSourceCode
//     {
//     public:
//         DynSourceCode(const string& filename);
//         virtual ~DynSourceCode();

//         /// Parse the source program and generate the intermediate code and the symbol table.
//         /// To be implemented by a language-specific parser subclass.
//         virtual void parse(CompilationContext* context) = 0;

//         /// Gets the source code line string corresponding to the given line no.
//         /// Return an empty string if the source-code class doesn't support getting the source code line.
//         virtual string getSourceCodeLine(int lineNo) const = 0;

//         /// Translates from a CT node to the corresponding RT node
//         virtual Node* translateCtToRt(Node* node) const;


//         /// Getter for the name of the file containing the source code
//         string filename() const { return sourceCode_.url; }

//         /// Getter for the intermediate code generated by this parser
//         Node* iCode() const { return sourceCode_.mainNode; }

//         /// Getter for the additional nodes generated during the compilation of this source code
//         const NodeVector& additionalNodes() const { return sourceCode_.additionalNodes; }

//         /// Adds an additional node to this source code
//         void addAdditionalNode(Node* node) { sourceCode_.additionalNodes.push_back(node); }

//     protected:
//         SourceCode sourceCode_;
//     };
// }
