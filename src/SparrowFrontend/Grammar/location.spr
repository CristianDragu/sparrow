module sparrowc.spr.grammar.location;

import untypedPtr;

/// A line + column pair, indicating a position in a file
datatype LineCol { line, col: UInt }

/// Type describing a source code; for now we just use an untyped Ptr
datatype SourceCode = UntypedPtr;

fun >>(s: @SourceCode, os: @OutStream) { os << s._data; }


/// Type that holds the location information: a source code and a range of chars into it
datatype Location { sourceCode: SourceCode, start, end: LineCol }

// TODO (functional): Make it possible to define ctors & dtors outside the class
//fun ctor(l: @Location) {
//    setOne(l);
//}

fun mkLocation: Location {
    var res: Location;
    setOne(res);
    return res;
}
fun mkLocation(sourceCode: SourceCode): Location {
    var res: Location;
    res.sourceCode = sourceCode;
    setOne(res);
    return res;
}

/// Set the location to (1,1,1,1), the first character in a stream
fun setOne(l: @Location) {
    l.start.line = 1;
    l.start.col = 1;
    l.end.line = 1;
    l.end.col = 1;
}

/// Make the start position to be the same as the end position
fun stepOver(l: @Location) {
    l.start = l.end;
}

/// Add the given number of columns to the end position; start position remains unchanged
fun addColumns(l: @Location, count: UInt) {
    l.end.col += count;
}

/// Add the given number of lines to the end position; start position remains unchanged
fun addLines(l: @Location, count: UInt) {
    l.end.line += count;
    l.end.col = 1;
}

/// Set the start position of this location to the start position of the given location; the end position remains unchanged
fun copyStart(l, other: @Location) {
    l.start = other.start;
}

/// Set the end position of this location to the end position of the given location; the start position remains unchanged
fun copyEnd(l, other: @Location) {
    l.end = other.end;
}

/// Set this location with both start and end to equal the start of the given location
fun setAsStartOf(l, other: @Location) {
    l.start = other.start;
    l.end = other.start;
}

/// Set this location with both start and end to equal the end of the given location
fun setAsEndOf(l, other: @Location) {
    l.start = other.end;
    l.end = other.end;
}

/// Computes a location that spans between the two given location
fun span(start, end: @Location): Location {
    var res = start;
    res copyEnd end;
    return res;
}

fun >>(l: @Location, os: @OutStream)
{
    os  << l.start.line << ':' << l.start.col << '-'
        << l.end.line << ':' << l.end.col
        << " @" << mkStreamRefWrapper(l.sourceCode._data._data)
        ;
}
