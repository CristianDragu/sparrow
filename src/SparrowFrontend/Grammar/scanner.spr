module sparrowc.spr.grammar.scanner

import parserDefs, rangeWithLookahead, token
import charType, std.ranges, std.vector

import os = os

// TODO (generics): Be able to generate a concept from a generic
// TODO (convert): Allow to test a range without an operator e.g., '!!'


/// Concept for modeling the source data for the scanner
/// It's basically a range of characters
concept CharRange(x: Range) if -@(x.RetType) == Char

package _ImplLSCR
    /// Helper class used to sync the location with the source range
    ///
    /// This also exposes a CharRange functionality, but it also modifiers an external
    /// location when iterating over the chars
    [initCtor]
    class LocationSyncCharRange(sourceType: Type) if CharRange(#$sourceType)
        using RetType = Char
        using IsLocationSyncCharRange = true

        var source: sourceType
        var location: @Location
    concept _This(t) if t.IsLocationSyncCharRange

    fun isEmpty(s: @_This) = s.source isEmpty
    fun front(s: @_This)   = s.source front
    fun popFront(s: @_This)
        if *s.source == '\n'.char
            s.location addLines 1
        else
            s.location addColumns 1
        s.source popFront


/// Our main scanner
///
/// This behaves just like a range transformation. Given the source range, this
/// will represent a range of tokens extracted from the source characters.
///
class SparrowScanner(sourceType, errorReporterType: Type) \
        if CharRange(#$sourceType) && ErrorReporter(#$errorReporterType)
    using RetType = Token
    using IsSparrowScanner = true

    fun ctor(source: sourceType, errorReporter: errorReporterType, iniLocation: @Location)
        this._curLocation ctor iniLocation
        this._src.ctor(RangeWithLookahead(sourceType)(source), _curLocation)
        this._curToken ctor
        this._tokenIsComputed ctor false
        this._atEnd ctor false
        this._errorReporter ctor errorReporter

    /// Location that we use to keep track of the source chars
    var _curLocation: Location
    /// The source stream of chars (and locations) we are going to use
    var _src: _ImplLSCR.LocationSyncCharRange(RangeWithLookahead(sourceType))
    /// The current token we look at. We will reuse this object for all the
    /// tokens that we parse from the source stream
    var _curToken: Token
    /// Indicates if '_curToken' is computed or not
    var _tokenIsComputed: Bool
    /// Indicates if '_curToken' is computed or not
    var _atEnd: Bool
    /// Object used to report errors
    var _errorReporter: errorReporterType
/// Concept that matches SparrowScanner above
concept _OurScanner(t) if t.IsSparrowScanner

fun isEmpty(s: @_OurScanner) = s._atEnd
fun front(s: @_OurScanner): Token
    if !s._tokenIsComputed
        s._tokenIsComputed = true
        s popFront
    return s._curToken
fun popFront(s: @_OurScanner)
    if (s._src isEmpty) && s._curToken.type == tkEND
        s._atEnd = true
    else
        s._curToken.type = _Impl.nextToken(s)
        s._curToken.loc = s._src.location
        // cout << s._curToken.loc << ": token: " << s._curToken.type._data << " - '" << s._curToken.data << "'" << endl

package _Impl

    fun reportError(s: @_OurScanner, msg: @String)
        s._errorReporter.reportError(s._src.location, msg)

    /// Peeks at the next char; we assume that at least the cur char is valid
    /// Returns Char(0) if no next char is available
    fun peekChar(s: @_OurScanner): Char
        return s._src.source peek 1

    fun peekChar(s: @_OurScanner, n: UInt): Char
        return s._src.source peek n

    /// Check if the source to has less than the given number of characters
    fun hasLessThan(s: @_OurScanner, n: UInt): Bool
        return s._src.source hasLessThan n

    /// Advances the input stream while the predicate matches
    /// Captures every character that matches
    fun advanceAndCapture(s: @_OurScanner, pred: AnyType)
        while !!s._src && pred(*s._src) ; s._src popFront
            s._curToken.data += *s._src

    /// Advances and captures 1 char
    fun advanceAndCapture1(s: @_OurScanner)
        s._curToken.data += *s._src
        s._src popFront

    /// Same as above, but do not capture '_'; we advance past it
    fun advanceAndCaptureDigit(s: @_OurScanner, pred: AnyType)
        while !!s._src && (pred(*s._src) || *s._src == '_'.char) ; s._src popFront
            if *s._src != '_'.char
                s._curToken.data += *s._src

    /// Computes the next token, for the current characters in the source stream.
    /// Stores the token in s._curToken
    fun nextToken(s: @_OurScanner): TokenType
        var loc: @Location = s._src.location


        // Check for a shebang line, and, if found, ignore it
        if loc.start.line == 1 && loc.start.col == 1
            var ch = *s._src
            var ch2 = s peekChar
            if ch == '#'.char && ch2 == '!'.char
                s._src popFront
                s._src advanceIf (fun c = c!='\n'.char)
                if !!s._src ; s._src popFront

        while true
            // The current location starts where the last one ended
            loc stepOver
            s._curToken.data clear

            // First check if the source is empty; if so, return an EOF token
            if s._src isEmpty
                return tkEND

            // Get the first character in the source
            var ch = *s._src
            var ch2 = s peekChar

            // Check for whitespace -- drop all the whitespace
            if ch == ' '.char
                s._src advanceIf (fun c = c==' '.char)
                continue

            // Check for tabs -- forbidden
            if ch == '\t'.char
                s reportError toString("Tabs are not valid characters")
                s._src advanceIf (fun c = c=='\t'.char)
                continue

            // Check for new lines
            if ch == '\n'.char
                s._src popFront
                return tkEOL

            // Check for line comments -- drop everything until the end of line (including eol)
            if ch == '/'.char && ch2 == '/'.char
                s._src popFront
                s._src advanceIf (fun c = c!='\n'.char)
                continue

            // Check for multi-line comments -- drop them
            if ch == '/'.char && ch2 == '*'.char
                s._src advance 2
                var c1 = 'a'.char
                var c2 = 'a'.char
                while !!s._src && (c1 != "*".char || c2 != "/".char)
                    c1 = c2
                    c2 = ++s._src
                if !s._src
                    s reportError "End of file found inside comment"
                    return tkEND
                s._src popFront     // move past '/'
                continue

            // Backslash followed by a new-line collapses
            if ch == '\\'.char && ch2 == '\n'.char
                s._src advance 2
                continue

            // Strings
            if ch == "'".char                     return parseString(s, "'".char)
            if ch == '"'.char                     return parseString(s, '"'.char)
            if ch == '<'.char && ch2 == '{'.char  return parseStringNE(s)

            // Symbols
            if ch == '{'.char  { s._src popFront; return tkLCURLY; }
            if ch == '{'.char  { s._src popFront; return tkLCURLY; }
            if ch == '}'.char  { s._src popFront; return tkRCURLY; }
            if ch == '['.char  { s._src popFront; return tkLBRACKET; }
            if ch == ']'.char  { s._src popFront; return tkRBRACKET; }
            if ch == '('.char  { s._src popFront; return tkLPAREN; }
            if ch == ')'.char  { s._src popFront; return tkRPAREN; }
            if ch == ';'.char  { s._src popFront; return tkSEMICOLON; }
            if ch == ','.char  { s._src popFront; return tkCOMMA; }
            if ch == '`'.char  { s._src popFront; return tkBACKSQUOTE; }

            // These two symbols can also be part of operators
            if ch == ':'.char && !isOpChar(s peekChar) { s._src popFront; return tkCOLON; }
            if ch == '='.char && !isOpChar(s peekChar) { s._src popFront; return tkEQUAL; }

            // Is this an operator?
            // If this is just a lonely dot, it will do nothing
            if isOpCharDot(ch)
                if parseOperator(s)
                    return tkOPERATOR

            // Check for dot -- dot followed by a digit is a floating point constant
            if ch == '.'.char && !isDigit(ch2) { s._src popFront; return tkDOT; }

            // Identifiers
            if isAlpha(ch) || ch == '_'.char return parseIdentifer(s)

            // Numeric literals
            if isDigit(ch) || ch == '.'.char return parseNumeric(s)

            s reportError toString("Invalid character found: '", ch, "' (", Int(ch), ')'.char)
            s._src popFront
            return tkEND


    fun isOpChar(c: Char): Bool
        return (
               c == '~'.char || c == '!'.char || c == '@'.char
            || c == '#'.char || c == '$'.char || c == '%'.char
            || c == '^'.char || c == '&'.char || c == '-'.char
            || c == '+'.char || c == '='.char || c == '|'.char
            || c == '\\'.char || c == ':'.char || c == '<'.char
            || c == '>'.char || c == '?'.char || c == '/'.char
            || c == '*'.char)
    fun isOpCharDot(c: Char) = c == '.'.char || isOpChar(c)

    fun isOctalDigit(c: Char) = '0'.char <= c && c <= '7'.char
    fun isBinDigit(c: Char) = c == '0'.char || c == '1'.char

    [native("tolower")]
    fun tolower(c: Int): Int
    fun toLower(c: Char) = Char(tolower(Int(c)))

    /// Parse an operator
    /// We know that the first char is an operator char or dot
    ///
    /// Returns true if this is actually an operator.
    /// If it is, this will capture all the chars in the symbol.
    /// If it's not, this will not consume the input
    ///
    /// If this is called to parse just a '.' without any follow-up operator chars,
    /// this will return false
    fun parseOperator(s: @_OurScanner): Bool
        var ch = *s._src

        // Operators
        if isOpChar(ch)
            s advanceAndCapture \isOpCharDot
            return true
        // If a dot is found in the first position, at least one other dot needs to be in the operators string
        // We need to look-ahead for the whole operator for this
        if ch == '.'.char
            var i = 1
            var c = s peekChar i
            while isOpChar(c)
                c = (s peekChar ++i)
            var hasOtherDot = c == '.'.char
            if hasOtherDot
                s advanceAndCapture \isOpCharDot
                return true

        // this is not an operator
        return false

    /// Parse an identifier; we know that we start with a letter or underscore
    /// Also checked for reserved keywords
    fun parseIdentifer(s: @_OurScanner): TokenType
        // Match the following:
        //      Identifier      {IdLetters} | {IdLettersOp}
        //      IdLetters       ({Letter} | '_') ({Letter} | '_' | {Digit})*
        //      IdLettersOp     {IdLetters}\_{Operator}
        // try to find an underscore; after underscore we can accept only operator chars
        // before underscore accept only alpha

        // Capture all the characters possible for the identifier
        var allowSymbolChars = false
        s._curToken.data += *s._src
        s._src popFront     // Skip the first char, we know it matches
        var firstDot = true
        while !!s._src ; s._src popFront
            var ch = *s._src

            // Check for characters allowed in the identifier
            // At this point we only accept alpha-numeric and underscore
            if !isAlpha(ch) && ch != '_'.char && !isDigit(ch)
                break

            s._curToken.data += ch

            // At underscores we may start accepting symbol characters
            // If that's the case, we need to have symbol until the end
            if ch == '_'.char && isOpCharDot(s peekChar)
                s._src popFront
                if parseOperator(s)
                    return tkIDENTIFIER


        var data: @StringRef = s._curToken.data.asStringRef

        // Check for reserved words
        if      data == "break"     return tkBREAK
        else if data == "catch"     return tkCATCH
        else if data == "class"     return tkCLASS
        else if data == "concept"   return tkCONCEPT
        else if data == "continue"  return tkCONTINUE
        else if data == "datatype"  return tkDATATYPE
        else if data == "fun"       return tkFUN
        else if data == "if"        return tkIF
        else if data == "else"      return tkELSE
        else if data == "false"     return tkFALSE
        else if data == "finally"   return tkFINALLY
        else if data == "for"       return tkFOR
        else if data == "import"    return tkIMPORT
        else if data == "module"    return tkMODULE
        else if data == "null"      return tkNULLCT
        else if data == "package"   return tkPACKAGE
        else if data == "return"    return tkRETURN
        else if data == "this"      return tkTHIS
        else if data == "throw"     return tkTHROW
        else if data == "true"      return tkTRUE
        else if data == "try"       return tkTRY
        else if data == "using"     return tkUSING
        else if data == "var"       return tkVAR
        else if data == "while"     return tkWHILE
        else                        return tkIDENTIFIER

    /// Parse a numeric constant (decimal, octal, hex, binary, floating)
    fun parseNumeric(s: @_OurScanner): TokenType
        var isLong = false
        var isUnsigned = false
        var isFloating = false
        var type = 0    // 0=decimal, 1=hex, 2=binary, 3=octal, 4=floating

        var ch = *s._src
        var ch2 = toLower(s peekChar)
        var ch3 = toLower(s peekChar 2)

        // Do the main parsing of all the digits (until the decimal part)
        if ch == '0'.char && ch2 == 'x'.char
            s._src advance 2
            s._curToken.intData = consumeDigits(s._src, 16, s._curToken.data)
        else if ch == '0'.char && ch2 == 'b'.char
            s._src advance 2
            s._curToken.intData = consumeDigits(s._src, 2, s._curToken.data)
        else if ch == '0'.char && ch2 == 'o'.char
            s._src advance 1
            s._curToken.intData = consumeDigits(s._src, 8, s._curToken.data)
        else
            // At this point we assume we are not parsing a floating point number
            // Consume digits as much as possible
            s._curToken.intData = consumeDigits(s._src, 10, s._curToken.data)

            // We are now at the first non-digit; we can check for floating numbers
            if !!s._src
                ch = toLower(*s._src)

                // If we started as a decimal, and encountered a fractional or an exponential part,
                // or a float suffix, make this a float
                if (ch == '.'.char && !isOpCharDot(s peekChar)) || ch == 'e'.char || ch == 'f'.char || ch == 'd'.char
                    isFloating = true

                    // Do we have fractional part?
                    if ch == '.'.char
                        s advanceAndCapture1    // past the dot
                        s advanceAndCaptureDigit \isDigit

                    // consume exponential part, if any
                    if !!s._src
                        ch = toLower(*s._src)
                        if ch == 'e'.char
                            s advanceAndCapture1
                            s advanceAndCaptureDigit \isDigit

                    // Suffix for floats -- don't capture these
                    if !!s._src
                        isLong = true   // by default double
                        ch = toLower(*s._src)
                        if ch == 'f'.char
                            isLong = false
                            s._src popFront
                        else if ch == 'd'.char
                            s._src popFront

        // Check if the number has enough digits
        if s._curToken.data isEmpty
            s reportError "Invalid numeric literal"
            return tkEND

        // Suffix for integers
        if !isFloating
            if !!s._src && toLower(*s._src) == 'u'.char
                isUnsigned = true
                s._src popFront
            if !!s._src && toLower(*s._src) == 'l'.char
                isLong = true
                s._src popFront

        // Compute the value and return the token type
        if isFloating
            s._curToken.data += Char(0)
            s._curToken.floatData = (s._curToken.data.asStringRef asDouble)
            s._curToken.data popBack
            return ife(isLong, tkDOUBLE_LITERAL, tkFLOAT_LITERAL)

        if isUnsigned
            return ife(isLong, tkULONG_LITERAL, tkUINT_LITERAL)
        else
            return ife(isLong, tkLONG_LITERAL, tkINT_LITERAL)

    fun getDigitVal(c: Char) = (Int(c) - Int('0'.char))
    fun getXdigitVal(c: Char) = ife(isDigit(c), Int(c) - Int('0'.char), 10 + Int(toLower(c)) - Int('a'.char))

    fun consumeDigits(r: @Range, base: ULong, capture: @String): ULong
        var res: ULong = 0
        if base == 16
            while !!r && (isXdigit(*r) || *r == '_'.char) ; r popFront
                if *r != '_'.char
                    capture += *r
                    res *= base
                    res += getXdigitVal(*r)
        else
            while !!r && (isXdigit(*r) || *r == '_'.char) ; r popFront
                if *r != '_'.char
                    capture += *r
                    res *= base
                    res += getDigitVal(*r)
        return res

    fun checkEscapeChar(s: @_OurScanner): Bool
        var ch = *s._src
        if ch == '\\'.char
            ch = ++s._src
            if ch == 'r'.char
                s._curToken.data += '\r'.char
            else if ch == 'n'.char
                s._curToken.data += '\n'.char
            else if ch == 'b'.char
                s._curToken.data += '\b'.char
            else if ch == 'f'.char
                s._curToken.data += '\f'.char
            else if ch == 't'.char
                s._curToken.data += '\t'.char
            else if ch == '\\'.char
                s._curToken.data += '\\'.char
            else if ch == "'".char
                s._curToken.data += "'".char
            else if ch == '\"'.char
                s._curToken.data += '\"'.char
            else if ch == 'x'.char || ch == 'X'.char
                if s hasLessThan 2
                    s reportError "Not enough digits for character code"
                    return true
                var charVal: Int = 16*getXdigitVal(++s._src)
                charVal += getXdigitVal(++s._src)
                s._curToken.data += Char(charVal)
            else
                // Just use the next character
                s._curToken.data += ++s._src
            s._src popFront  // Advance past the escape sequence
            return true
        return false

    fun parseString(s: @_OurScanner, endChar: Char): TokenType
        s._src popFront
        if s hasLessThan 1
            s reportError "End of file found inside string literal"
            return tkEND

        // Get all the characters from the string
        while !!s._src && *s._src != endChar
            if !checkEscapeChar(s)
                s advanceAndCapture1

        // Now expect closing quote
        // We shouldn't be at the end of the scope
        if !s._src
            s reportError "End of file found inside string literal"
            return tkEND
        s._src popFront

        return tkSTRING_LITERAL

    fun parseStringNE(s: @_OurScanner): TokenType
        s._src advance 2

        // Get all the characters from the string
        while !!s._src && !(*s._src == '}'.char && (s peekChar) == '>'.char)
            s advanceAndCapture1

        if !s._src
            s reportError "End of file found inside string literal"
            return tkEND
        s._src advance 2
        return tkSTRING_LITERAL
