/// Interface between the scanner and the Sparrow compiler
module sparrowc.spr.grammar.scannerIf;

import scanner;
import parserDefs;
import os;
import std.newDelete;

// Defined in the compiler
fun[native("comp_scannerIf_reportError")] reportErrorExternal(loc: Location, msg: StringRef);

class ExternalErrorReporter {
    fun reportError(loc: Location, msg: @String) {
        reportErrorExternal(loc, msg.asStringRef());
    }
}


class ScannerContext {
    using FileScannerType = SparrowScanner(FileRange, ExternalErrorReporter);
    using StringScannerType = SparrowScanner(StringRef, ExternalErrorReporter);

    private var file: File;
    private var fileScanner: FileScannerType;
    private var stringScanner: StringScannerType;

    fun ctor(filename, code: StringRef, loc: Location) {
        var reporter = ExternalErrorReporter();

        if ( code isEmpty ) {
            // Open the file, and create a scanner on top of the file
            file ctor filename;
            fileScanner.ctor(file.all, reporter, loc);
            stringScanner ctor;

            if ( !file.isOpen )
                reporter.reportError(loc, toString("Cannot open file: ", filename));
        }
        else {
            // Use the code as a the input
            file;
            fileScanner ctor;
            stringScanner.ctor(code, reporter, loc);
        }

    }
}

// Used by the compiler
fun[native("spr_scannerIf_createScanner"), noInline] createScanner(filename, code: StringRef, loc: @Location): @ScannerContext {
    return new(ScannerContext, filename, code, loc);
}

fun[native("spr_scannerIf_destroyScanner"), noInline] destroyScanner(ctx: @ScannerContext) {
    delete(ctx);
}

fun[native("spr_scannerIf_nextToken"), noInline] nextToken(ctx: @ScannerContext, outToken: @Token) {
    if ( ctx.file isOpen )
        outToken = (ctx.fileScanner++);
    else
        outToken = (ctx.stringScanner++);
}
