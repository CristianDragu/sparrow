module sparrowc.spr.grammar.token;

import meta.location;
import std.string;

/// A token type; identifies the type of the token
datatype TokenType = Int;

/// The actual token; holds all the information needed for a token
datatype Token { loc: Location, type: TokenType, data: String, intData: ULong, floatData: Double }

/// Concept modeling the output of the scanner
/// It's basically a range of tokens
concept TokenRange(x: Range)
    if -@(x.RetType) == Token
    ;

// The list of all tokens used by the parser/scanner
using tkEND             = TokenType(0);
using tkEOL             = TokenType(1);
using tkINDENT          = TokenType(2);
using tkDEDENT          = TokenType(3);
using tkMODULE          = TokenType(4);
using tkIMPORT          = TokenType(5);
using tkCLASS           = TokenType(6);
using tkCONCEPT         = TokenType(7);
using tkDATATYPE        = TokenType(8);
using tkFUN             = TokenType(9);
using tkPACKAGE         = TokenType(10);
using tkUSING           = TokenType(11);
using tkVAR             = TokenType(12);
using tkBREAK           = TokenType(13);
using tkCATCH           = TokenType(14);
using tkCONTINUE        = TokenType(15);
using tkFINALLY         = TokenType(16);
using tkFOR             = TokenType(17);
using tkIF              = TokenType(18);
using tkRETURN          = TokenType(19);
using tkTHROW           = TokenType(20);
using tkTRY             = TokenType(21);
using tkWHILE           = TokenType(22);
using tkFALSE           = TokenType(23);
using tkNULLCT          = TokenType(24);
using tkTHIS            = TokenType(25);
using tkTRUE            = TokenType(26);
using tkTHEN_CLAUSE     = TokenType(27);
using tkELSE            = TokenType(28);
using tkLCURLY          = TokenType(29);
using tkRCURLY          = TokenType(30);
using tkLBRACKET        = TokenType(31);
using tkRBRACKET        = TokenType(32);
using tkLPAREN          = TokenType(33);
using tkRPAREN          = TokenType(34);
using tkCOLON           = TokenType(35);
using tkSEMICOLON       = TokenType(36);
using tkCOMMA           = TokenType(37);
using tkDOT             = TokenType(38);
using tkBACKSQUOTE      = TokenType(39);
using tkEQUAL           = TokenType(40);
using tkIDENTIFIER      = TokenType(41);
using tkOPERATOR        = TokenType(42);
using tkCHAR_LITERAL    = TokenType(43);
using tkSTRING_LITERAL  = TokenType(44);
using tkINT_LITERAL     = TokenType(45);
using tkLONG_LITERAL    = TokenType(46);
using tkUINT_LITERAL    = TokenType(47);
using tkULONG_LITERAL   = TokenType(48);
using tkFLOAT_LITERAL   = TokenType(49);
using tkDOUBLE_LITERAL  = TokenType(50);

private fun asString(t: TokenType): String {
    if ( t == tkEND )                   return "end-of-file";
    else if ( t == tkEOL )              return "new-line";
    else if ( t == tkINDENT )           return "indentation";
    else if ( t == tkDEDENT )           return "de-indentation";
    else if ( t == tkMODULE )           return "'module'";
    else if ( t == tkIMPORT )           return "'import'";
    else if ( t == tkCLASS )            return "'class'";
    else if ( t == tkCONCEPT )          return "'concept'";
    else if ( t == tkDATATYPE )         return "'datatype'";
    else if ( t == tkFUN )              return "'fun'";
    else if ( t == tkPACKAGE )          return "'package'";
    else if ( t == tkUSING )            return "'using'";
    else if ( t == tkVAR )              return "'var'";
    else if ( t == tkBREAK )            return "'break'";
    else if ( t == tkCATCH )            return "'catch'";
    else if ( t == tkCONTINUE )         return "'continue'";
    else if ( t == tkFINALLY )          return "'finally'";
    else if ( t == tkFOR )              return "'for'";
    else if ( t == tkIF )               return "'if'";
    else if ( t == tkRETURN )           return "'return'";
    else if ( t == tkTHROW )            return "'throw'";
    else if ( t == tkTRY )              return "'try'";
    else if ( t == tkWHILE )            return "'while'";
    else if ( t == tkFALSE )            return "'false'";
    else if ( t == tkNULLCT )           return "'null'";
    else if ( t == tkTHIS )             return "'this'";
    else if ( t == tkTRUE )             return "'true'";
    else if ( t == tkTHEN_CLAUSE )      return "then clause";   // !!!
    else if ( t == tkELSE )             return "'else'";
    else if ( t == tkLCURLY )           return "'{'";
    else if ( t == tkRCURLY )           return "'}'";
    else if ( t == tkLBRACKET )         return "'['";
    else if ( t == tkRBRACKET )         return "']'";
    else if ( t == tkLPAREN )           return "'('";
    else if ( t == tkRPAREN )           return "')'";
    else if ( t == tkCOLON )            return "':'";
    else if ( t == tkSEMICOLON )        return "';'";
    else if ( t == tkCOMMA )            return "','";
    else if ( t == tkDOT )              return "'.'";
    else if ( t == tkBACKSQUOTE )       return "'`'";
    else if ( t == tkEQUAL )            return "'='";
    else if ( t == tkIDENTIFIER )       return "identifier";
    else if ( t == tkOPERATOR )         return "operator";
    else if ( t == tkCHAR_LITERAL )     return "char literal";
    else if ( t == tkSTRING_LITERAL )   return "string literal";
    else if ( t == tkINT_LITERAL )      return "int literal";
    else if ( t == tkLONG_LITERAL )     return "long literal";
    else if ( t == tkUINT_LITERAL )     return "uint literal";
    else if ( t == tkULONG_LITERAL )    return "ulong literal";
    else if ( t == tkFLOAT_LITERAL )    return "float literal";
    else if ( t == tkDOUBLE_LITERAL )   return "double literal";
}

fun >>(t: TokenType, os: @OutStream) {
    os << (t asString);
}

