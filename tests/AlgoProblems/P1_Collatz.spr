//!! -O2
import std.vector;
import std.ranges;
import std.algorithms;

var vecSize: ULong = 2^28;

fun seqNext(n: ULong): ULong
{
    if ( n%2 == 0 )
        return n/2;
    else
        return 3*n+1;
}

fun lenOfSeq(n: ULong): Short
{
    var res: Short = 1;
    while n != 1
    {
        n = seqNext(n);
        ++res;
    }
    return res;
}

class Result
{
    var len: Short;
    var pos: ULong;

    fun ctor(this: @Result) { len = Short(1); pos = 1; }
    fun ctor(this: @Result, l: Short, p: ULong) { len = l; pos = p; }
    //fun ctor(other: Result) { ctor(other); }
    //fun =(other: Result) { len = other.len; pos = other.pos; }

    fun checkUpdate(l: Short, p: ULong)
    {
        if ( len<l )
        {
            len = l;
            pos = p;
        }
    }
}

fun checkUpdate2(res, prevRes: @Result, curLen: Short, curPos: ULong)
{
    if ( curLen >= prevRes.len )
    {
        if ( curLen >= res.len )
        {
            prevRes = res;
            res = Result(curLen, curPos);
        }
        else
        {
             prevRes = Result(curLen, curPos);
        }
    }
}


fun buildCacheVector(size: ULong, v: @Vector(Short), res: @Result)
{
    for i = 1..size
    {
        var len: Short = 1;
        var n = i;
        var lastCached = min(i, size);
        while n != 1
        {
            if ( n % 2 == 0 )
            {
                n = n/2;
                if ( n<lastCached )
                {
                    len += v(n);
                    break;
                }
            }
            else
                n = 3*n + 1;

            ++len;
        }
        v(i) = len;
        res.checkUpdate(len, i);
    }
}

fun updateNextLevelCache(limit, size: ULong, v: @Vector(Short), res: @Result)
{
    var size2 = size*2;
    for i = size..limit
    {
        var len: Short = 1;
        var n = i;
        while n != 1
        {
            if ( n % 2 == 0 )
            {
                n = n/2;
                if ( n<i )
                {
                    if ( n < size )
                        len += v(n);
                    else
                        len += v(n - size);
                    break;
                }
            }
            else
                n = 3*n + 1;

            ++len;
        }
        v(i-size) = len;
        res.checkUpdate(len, i);
    }
}

fun searchAfterNextLevelCache(start, limit, size: ULong, v: @Vector(Short), res: @Result)
{
    var size2 = size*2;
    for i = start..limit
    {
        var len: Short = 1;
        var n = i;
        while n != 1
        {
            if ( n % 2 == 0 )
            {
                n = n/2;
                if ( n<size2 )
                {
                    len += v(n - size);
                    break;
                }
            }
            else
                n = 3*n + 1;

            ++len;
        }
        res.checkUpdate(len, i);
    }
}

fun searchAfterNextLevelCacheWithCutoff(start, limit, size: ULong, v: @Vector(Short), res, prevRes: @Result)
{
    var size2 = size*2;
    for i = start..limit
    {
        var len: Short = 1;
        var n = i;
        while n != 1
        {
            if ( n % 2 == 0 )
            {
                n = n/2;
                if ( n<size2 )
                {
                    len += v(n - size);
                    break;
                }
                if ( n < i && len+prevRes.len < res.len )
                    break;
            }
            else
                n = 3*n + 1;

            ++len;
        }
        checkUpdate2(res, prevRes, len, i);
    }
}






fun naiveSearch(n: ULong): ULong
{
    var res: Result;
    for i = 1 .. n
    {
        var len = i lenOfSeq;
        res.checkUpdate(len, i);
    }
    return res.pos;
}

fun cutoffSearch(n: ULong): ULong
{
    var res, prevRes: Result;
    for i = 1 .. n
    {
        var len = Short(1);
        var n = i;
        while n != 1
        {
            if ( n % 2 == 0 )
            {
                n = n/2;
                if ( n <= i && len + prevRes.len < res.len )
                    break;
            }
            else
                n = 3*n+1;
            ++len;
        }
        checkUpdate2(res, prevRes, len, i);
    }
    return res.pos;
}

fun stagedSearch(limit: ULong): ULong
{
    ++limit;
    var size = min(limit, vecSize);
    var size2 = min(limit, 2*size);
    var res, prevRes: Result;
    var v: Vector(Short);
    v.resize(size);
    buildCacheVector(size, v, res);
    updateNextLevelCache(size2, size, v, res);
    prevRes = res;
    searchAfterNextLevelCacheWithCutoff(size2, limit, size, v, res, prevRes);
    return res.pos;
}


fun bestSearch(n: ULong) = stagedSearch(n);

fun resetTimer(timer: @Timer, write: Bool)
{
    var duration = timer elapsed;
    if ( write )
        cout << ", " << duration;
    timer restart;
}

fun checkResult(expected, got: ULong, test: Int)
{
    if ( got != 0 && got != expected )
        cout << "BUG, test " << test << " - expected " << expected << ", got " << got << endl;
}

fun measure(start, end, step: ULong, measureSlowOnes: Bool)
{
    cout << "count, best";
    if ( measureSlowOnes )
        cout << ", naive, cutoff";
    cout << ", stagedSearch";
    cout << endl;

    for n = start .. end ../ step
    {
        var r1, r2, r3, r4, r5, r6, r7: ULong = 0;
        var timer: Timer;

        cout << n;
        resetTimer(timer, false);   r1 = bestSearch(n);
        if ( measureSlowOnes )
        {
            resetTimer(timer, true);    r2 = naiveSearch(n);
            resetTimer(timer, true);    r3 = cutoffSearch(n);
        }
        //resetTimer(timer, true);    r4 = dynamicSearch(n);
        //resetTimer(timer, true);    r7 = dynamicSearch_p(n);
        //resetTimer(timer, true);    r5 = dynamicSearch2(n);
        //resetTimer(timer, true);    r6 = dynamicSearch2WithCuttoff(n);
        resetTimer(timer, true);    r7 = stagedSearch(n);
        resetTimer(timer, true);    cout << endl;

        checkResult(r1, r2, 2);
        checkResult(r1, r3, 3);
        checkResult(r1, r4, 4);
        checkResult(r1, r5, 5);
        checkResult(r1, r6, 6);
        checkResult(r1, r7, 7);
    }

}



fun sprMain
{
    if ( programArgs.size() < 2 ) return;
    var n = ULong.fromString(programArgs(1));

    //var nt = 2^29;
    //measure(nt, nt+1, 1, false);

    cout << bestSearch(n) << endl;
}

/*<<<Test 1 mil (1000000)
837799
>>>*/

/*<<<Test 100k (100000)
77031
>>>*/
