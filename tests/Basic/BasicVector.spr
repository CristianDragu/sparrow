//!! -t "SparrowImplicitLib.spr" -fno-main
//-keep-intermediate-files -dump-assembly -dump-ct-assembly

concept AnyType(x); // Always true

fun assert(condition: Bool)
{
    if ( !condition )
        writeLn("Assertion failure!");
}

class ContinousMemoryRange(type: Type)
{
    [static] var ValueType = type;

    var begin, end: @ValueType;

    fun ctor()
    {
        assert(this.size() == intToSizeType(0));
    }

    fun ctor(begin,end: @ValueType)
    {
        this.begin := begin;
        this.end := end;
    }

    fun ctor(other: ContinousMemoryRange)
    {
        begin := other.begin;
        end := other.end;
    }

    fun swap(other: @ContinousMemoryRange)
    {
        var tmp: @AnyType = begin;
        begin := other.begin;
        other.begin := tmp;
        tmp := end;
        end := other.end;
        other.end := tmp;
    }

    fun isEmpty(): Bool
    {
        return begin === end;
    }

    fun size(): SizeType
    {
        return ptrDiff(toPtr(end), toPtr(begin)) / sizeOf(ValueType);
    }

    fun popFront()
    {
        begin := inc(begin);
    }

    fun popBack()
    {
        end := dec(end);
    }

    fun popFront(n: SizeType)
    {
        begin := inc(begin, n);
    }

    fun popBack(n: SizeType)
    {
        end := dec(end, n);
    }

    fun popFront(n: Int)
    {
        begin := inc(begin, intToSizeType(n));
    }

    fun popBack(n: Int)
    {
        end := dec(end, intToSizeType(n));
    }

    fun front(): @ValueType
    {
        return begin;
    }

    fun back(): @ValueType
    {
        return dec(end);
    }

    fun peekFront(n: SizeType): @ValueType
    {
        return inc(begin, n);
    }

    fun peekBack(n: SizeType): @ValueType
    {
        return dec(end, n+intToSizeType(1));
    }


    [static] fun toPtr(p: @ValueType): @Byte
    {
        return reinterpretCast(@Byte, p);
    }
    [static] fun toValue(p: @Byte): @ValueType
    {
        return reinterpretCast(@ValueType, p);
    }

    [static] fun inc(p: @ValueType): @ValueType
    {
        return toValue(ptrAdd(toPtr(p), sizeOf(ValueType)));
    }
    [static] fun inc(p: @ValueType, n: SizeType): @ValueType
    {
        return toValue(ptrAdd(toPtr(p), n*sizeOf(ValueType)));
    }
    [static] fun dec(p: @ValueType): @ValueType
    {
        return toValue(ptrSub(toPtr(p), sizeOf(ValueType)));
    }
    [static] fun dec(p: @ValueType, n: SizeType): @ValueType
    {
        return toValue(ptrSub(toPtr(p), n*sizeOf(ValueType)));
    }
}

class Vector(type: Type)
{
    [static] var ValueType = type;

    var begin, end, endOfStore: @ValueType;

    [static, ct] var initialCapacity: SizeType = intToSizeType(16);
    [static, ct] var growthFactor = 1.5;

    fun ctor()
    {
        assert(this.size() == intToSizeType(0));
    }

    fun ctor(other: @Vector)
    {
        var size = other.size();

        begin := toValue(malloc(size*sizeOf(ValueType)));
        end := inc(begin, size);
        endOfStore := end;

        var dst: @AnyType = begin;
        var src: @AnyType = other.begin;

        while ( dst !== end )
        {
            dst = src;
            // TODO: Call ctor here
            dst := inc(dst);
            src := inc(src);
        }
        assert(this.size() == other.size());
    }

    fun ctor(r: ContinousMemoryRange(ValueType))
    {
        begin := null;
        end := null;
        endOfStore := null;
        this.reserve(r.size());
        while ( !r.isEmpty() ; r.popFront(); )
        {
            this.pushBack(r.front());
        }
    }

    // TODO: ctor from range (with or without reserve)

    fun dtor
    {
        var p: @AnyType = begin;

        // TODO: call dtor on an object
        //while ( p !== end ; p := inc(p); )
        //    p.dtor();
        free(toPtr(begin));
    }


    fun size(): SizeType
    {
        return diff(end, begin);
    }

    fun isEmpty(): Bool
    {
        return begin === end;
    }

    fun capacity(): SizeType
    {
        return diff(endOfStore, begin);
    }

    fun reserve(n: SizeType)
    {
        var curCapacity: SizeType = this.capacity();

        if ( n <= curCapacity )
            return;

        if ( n < initialCapacity )
            n = initialCapacity;
        //if ( n < SizeType(growthFactor * curCapacity) )
        //    n = SizeType(growthFactor * curCapacity);
        // TODO: Type casts between Double and SizeType
        if ( n < curCapacity+curCapacity )
            n = curCapacity+curCapacity;

        var curSize = this.size();
        // TODO: Call methods with this parameter

        var src: @AnyType = begin;

        begin := toValue(malloc(n*sizeOf(ValueType)));
        end := inc(begin, curSize);
        endOfStore := inc(begin, n);
        var dst: @AnyType = begin;

        // TODO: Call ctors/dtors when reallocating
        while ( dst !== end )
        {
            dst = src;
            // TODO: Call ctor here
            dst := inc(dst);
            src := inc(src);
        }
        //this.debugDumpThis("After malloc");

        assert(this.capacity() >= n);
    }

    // TODO: swap function

    fun at(index: SizeType): @ValueType
    {
        assert(index < this.size());
        return inc(begin, index);
    }
    fun at(index: Int): @ValueType
    {
        return this.at(intToSizeType(index));
    }

    fun front(): @ValueType
    {
        assert(!this.isEmpty());
        return begin;
    }

    fun back(): @ValueType
    {
        assert(!this.isEmpty());
        return dec(end);
    }

    fun all(): ContinousMemoryRange(ValueType)
    {
        return ContinousMemoryRange(ValueType)(begin, end);
    }

    fun subrange(index: SizeType, num: SizeType): ContinousMemoryRange(ValueType)
    {
        return ContinousMemoryRange(ValueType)(inc(begin, index), inc(begin, index + num));
    }
    fun subrange(index: Int, num: Int): ContinousMemoryRange(ValueType)
    {
        return this.subrange(intToSizeType(index), intToSizeType(num));
    }

    fun insertBefore(value: @ValueType, pos: ContinousMemoryRange(ValueType))
    {
        var posCount = diff(pos.front(), begin);
        this.reserve(this.size() + intToSizeType(1));

        var p: @AnyType = inc(begin, posCount);

        // TODO: Call ctors/dtors
        move(p, end, inc(begin, posCount+intToSizeType(1)));
        p = value;
        end := inc(end);
    }
    fun insertBefore(range: ContinousMemoryRange(ValueType), pos: ContinousMemoryRange(ValueType))
    {
        var n = range.size();
        var index = diff(pos.front(), begin);

        this.reserve(this.size() + n);

        var p: @AnyType = inc(begin, index);

        move(p, end, inc(begin, index + n));
        while ( p !== inc(begin, index + n) ; p := inc(p); )
        {
            p = range.front();
            range.popFront();
        }
        end := inc(end, n);
    }

    fun insertAfter(value: @ValueType, pos: ContinousMemoryRange(ValueType))
    {
        var posCount = intToSizeType(1) + diff(pos.back(), begin);

        this.reserve(this.size() + intToSizeType(1));

        var p: @AnyType = inc(begin, posCount);

        move(p, end, inc(begin, posCount + intToSizeType(1)));
        p = value;
        end := inc(end);
    }
    fun insertAfter(range: ContinousMemoryRange(ValueType), pos: ContinousMemoryRange(ValueType))
    {
        var n = range.size();
        var index = intToSizeType(1) + diff(pos.back(), begin);

        this.reserve(this.size() + n);

        var p: @AnyType = inc(begin, index);

        move(p, end, inc(begin, index + n));
        while ( p !== inc(begin, index + n) ; p := inc(p); )
        {
            p = range.front();
            range.popFront();
        }
        end := inc(end, n);
    }

    fun pushBack(value: @ValueType)
    {
        if ( end === endOfStore )
        {
            var c = this.capacity();
            c += c;
            if ( c < initialCapacity )
                c = initialCapacity;
            this.reserve(c);
        }

        end ctor value;
        end := inc(end);

        //assert(this.back() == value);
    }

    fun popBack()
    {
        end := dec(end);
        //end.@dtor();
        // TODO: call dtor
    }

    fun remove(range: ContinousMemoryRange(ValueType))
    {
        var rSize = range.size();
        var rBegin: @ValueType = range.front();
        var rEnd: @ValueType = inc(rBegin, rSize);

        while ( rEnd !== end )
        {
            rBegin = rEnd;
            rBegin := inc(rBegin);
            rEnd := inc(rEnd);
        }
        end := rBegin;
    }
    fun remove(index: SizeType)
    {
        var r = this.all();

        r.popFront(index);
        r.popBack(this.size() - index - intToSizeType(1));
        this.remove(r);
    }

    fun resize(n: SizeType)
    {
        var oldSize = this.size();

        if ( n == oldSize )
            return;

        if ( n < oldSize )
        {
            var newEnd: @AnyType = inc(begin, n);

            while ( end !== newEnd )
            {
                end := dec(end);
                //end.@dtor();
                // TODO: call dtor
            }
        }
        else
        {
            this.reserve(n);
            var newEnd: @AnyType = inc(begin, n);
            while ( end !== newEnd )
            {
                //end.@ctor();
                // TODO: call default ctor inplace
                end := inc(end);
            }
        }

        assert(this.size() == n);
    }
    fun resize(n: Int)
    {
        this.resize(intToSizeType(n));
    }

    fun assign(r: ContinousMemoryRange(ValueType))
    {
        this.clear();
        this.reserve(r.size());
        while ( !r.isEmpty() ; r.popFront(); )
        {
            this.pushBack(r.front());
        }
    }

    fun clear()
    {
        end := begin;
        // TODO
        //remove(RangeType(begin, end));

        assert(this.isEmpty());
    }

    fun swap(other: @Vector)
    {
        var tmp: @AnyType = begin;
        begin := other.begin;
        other.begin := tmp;
        tmp := end;
        end := other.end;
        other.end := tmp;
        tmp := endOfStore;
        endOfStore := other.endOfStore;
        other.endOfStore := tmp;
    }


    fun debugDumpThis(desc: StringRef)
    {
        writeLn("<<<");
        write("  "); write(desc); writeLn(": ");
        write("  Begin: "); writeLnRef(toPtr(begin));
        write("  End: "); writeLnRef(toPtr(end));
        write("  End-of-store: "); writeLnRef(toPtr(endOfStore));
        write("  Size-of-elem: "); writeLn(sizeOf(ValueType));
        write("  Size: "); writeLn(this.size());
        write("  Capacity: "); writeLn(this.capacity());
        writeLn(">>>");
        flushOutput();
    }

    [static] fun toPtr(p: @ValueType): @Byte
    {
        return reinterpretCast(@Byte, p);
    }
    [static] fun toValue(p: @Byte): @ValueType
    {
        return reinterpretCast(@ValueType, p);
    }

    [static] fun inc(p: @ValueType): @ValueType
    {
        return toValue(ptrAdd(toPtr(p), sizeOf(ValueType)));
    }
    [static] fun inc(p: @ValueType, n: SizeType): @ValueType
    {
        return toValue(ptrAdd(toPtr(p), n*sizeOf(ValueType)));
    }
    [static] fun dec(p: @ValueType): @ValueType
    {
        return toValue(ptrSub(toPtr(p), sizeOf(ValueType)));
    }
    [static] fun dec(p: @ValueType, n: SizeType): @ValueType
    {
        return toValue(ptrSub(toPtr(p), n*sizeOf(ValueType)));
    }
    [static] fun diff(p,q: @ValueType): SizeType
    {
        return ptrDiff(toPtr(p), toPtr(q)) / sizeOf(ValueType);
    }
    [static] fun move(pBegin, pEnd, destBegin: @ValueType)
    {
        var size = diff(pEnd, pBegin);
        var destEnd: @AnyType = inc(destBegin, size);

        while ( pEnd !== pBegin )
        {
            destEnd := dec(destEnd);
            pEnd := dec(pEnd);
            destEnd = pEnd;
        }
    }
}

fun createRange(t: Type, n: Int): ContinousMemoryRange(t)
{
    var sizeToAlloc = intToSizeType(n) * sizeOf(t);
    var begin,end: @Byte;
    begin := malloc(sizeToAlloc);
    end := ptrAdd(begin, sizeToAlloc);
    var res = ContinousMemoryRange(t)(reinterpretCast(@t, begin), reinterpretCast(@t, end));
    var i = 0;
    while ( i<n ; i=i+1; )
    {
        res.peekFront(intToSizeType(i)) = i;
    }
    return res;
}

class MyObj
{
    fun ctor(xx: Int) { x = xx; write("ctor("); write(x); writeLn(')'); }
    fun ctor(other: @MyObj) { x = other.x; write("copy ctor MyObj("); write(x); writeLn(")"); }
    fun dtor { write("dtor("); write(x); writeLn(')'); }

    var x: Int;
}

fun write1(obj: MyObj)
{
    write("MyObj("); write(obj.x); write(")");
}


// Prints the elements in the vector on one line.
fun printVector(v: AnyType)
{
	var i = intToSizeType(0);

	while ( i < v.size() ; i = i + intToSizeType(1); )
	{
		write(v.at(i));
		if ( i < v.size() - intToSizeType(1) )
		{
			write(", ");
		}
		else
		{
			writeLn("");
		}
	}
}

fun printRange(r: AnyType)
{
    while ( !r.isEmpty() ; r.popFront(); )
    {
        write(r.front());
		if ( r.size() > intToSizeType(1) )
		{
			write(", ");
		}
		else
		{
			writeLn("");
		}
    }
}

// Prints whether the vector is empty or not, the vector's size and its capacity,
// each on a different line.
fun printSizeInfo(v: AnyType) if isValid(v.isEmpty()) && isValid(v.size())
{
    if ( v.isEmpty() ) writeLn("empty");
    else writeLn("not empty");
	writeLn(v.size());
}



[native("test")] fun test(n: Int)
{
    if      ( n == 1 ) test1();
    else if ( n == 2 ) test2();
    else if ( n == 3 ) test3();
    else if ( n == 4 ) test4();
    else if ( n == 5 ) test5();
    else if ( n == 6 ) test6();
    else if ( n == 7 ) test7();
    else if ( n == 8 ) test8();
    else if ( n == 9 ) test9();
    else if ( n == 10 ) test10();
    else if ( n == 11 ) test11();
    else if ( n == 12 ) test12();
    else if ( n == 13 ) test13();
    else if ( n == 14 ) test14();
    else if ( n == 15 ) test15();
    else if ( n == 16 ) test16();
    else if ( n == 17 ) test17();
    else if ( n == 18 ) test18();
    else if ( n == 19 ) test19();
    else if ( n == 20 ) test20();
    else if ( n == 21 ) test21();
}

fun test1()
{
    var v: Vector(Int);
    writeLn(v.size());
    v.pushBack(10);
    v.pushBack(20);
    //v.debugDumpThis("After pushBack");
    writeLn(v.size());
    writeLn(v.at(intToSizeType(0)));
    writeLn(v.at(intToSizeType(1)));
    writeLn("---");
    printSizeInfo(v);
    printVector(v);
    writeLn("---");
	v.popBack();
	printSizeInfo(v);
	printVector(v);
    writeLn("---");
	v.popBack();
	printSizeInfo(v);
	printVector(v);
}
/*<<<Basic test(1)
0
2
10
20
---
not empty
2
10, 20
---
not empty
1
10
---
empty
0
>>>*/

fun test2()
{
    var r = createRange(Int, 10);
    writeLn(r.size());
    printRange(r);
}
/*<<<Range test(2)
10
0, 1, 2, 3, 4, 5, 6, 7, 8, 9
>>>*/

fun test3()
{
    var v: Vector(Int) = createRange(Int, 4);

    printSizeInfo(v);
    printVector(v);
    v.popBack();
    printSizeInfo(v);
    printVector(v);
    v.pushBack(42);
    printSizeInfo(v);
    printVector(v);
}
/*<<<Range constructor(3)
not empty
4
0, 1, 2, 3
not empty
3
0, 1, 2
not empty
4
0, 1, 2, 42
>>>*/

fun test4()
{
    var v1: Vector(Int);
    var v2: Vector(Int) = createRange(Int, 4);
    var v3: Vector(Int) = v1;
    var v4 = v2;

	printSizeInfo(v3);
	printSizeInfo(v4);
	printVector(v4);
}
/*<<<Copy constructor(4)
empty
0
not empty
4
0, 1, 2, 3
>>>*/

fun test5()
{
    writeLn("start");
    {
        var v: Vector(MyObj);
        v.pushBack(MyObj(1));
        v.pushBack(MyObj(2));
        writeLn("prepare to exit...");
    }
    writeLn("done");
}
/*<<<Destructor(5)
start
ctor(1)
copy ctor MyObj(1)
dtor(1)
ctor(2)
copy ctor MyObj(2)
dtor(2)
prepare to exit...
done
>>>*/

fun test6()
{
	var v1: Vector(Int);

	v1.reserve(intToSizeType(42));
	printSizeInfo(v1);
	writeLn(v1.capacity());

	var v2: Vector(Int) = createRange(Int, 4);

	v2.reserve(intToSizeType(100));
	printSizeInfo(v2);
	writeLn(v2.capacity());
	printVector(v2);
	v2.reserve(intToSizeType(10));
	printSizeInfo(v2);
	writeLn(v2.capacity());
	printVector(v2);

	var v3: Vector(Int) = createRange(Int, 1024);

    if ( v3.capacity() < intToSizeType(1024) ) writeLn("Test failed");
    v3.pushBack(0);
    if ( v3.capacity() < intToSizeType(1024) ) writeLn("Test failed");
}
/*<<<Reserve(6)
empty
0
42
not empty
4
100
0, 1, 2, 3
not empty
4
100
0, 1, 2, 3
>>>*/

fun test7()
{
    var v1: Vector(Int);
    var v2: Vector(Int) = createRange(Int, 8);

    v1.assign(createRange(Int, 5));
    printSizeInfo(v1);
    printVector(v1);
    v2.assign(createRange(Int, 4));
    printSizeInfo(v2);
    printVector(v2);
}
/*<<<Range assignment(7)
not empty
5
0, 1, 2, 3, 4
not empty
4
0, 1, 2, 3
>>>*/

fun test8()
{
    var v1: Vector(Int);
    var v2: Vector(Int) = createRange(Int, 4);

    v1.swap(v2);
    printSizeInfo(v1);
    printVector(v1);
    printSizeInfo(v2);
    v1.swap(v1);
    printSizeInfo(v1);
    printVector(v1);
}
/*<<<Swapping(8)
not empty
4
0, 1, 2, 3
empty
0
not empty
4
0, 1, 2, 3
>>>*/

fun test9()
{
    var v: Vector(Int) = createRange(Int, 8);

    v.at(intToSizeType(1)) = 111;
    v.at(intToSizeType(5)) = 555;
    printVector(v);
    v.front() = 42;
    v.back() = 84;
    printVector(v);
}
/*<<<Element access(9)
0, 111, 2, 3, 4, 555, 6, 7
42, 111, 2, 3, 4, 555, 6, 84
>>>*/

fun test10()
{
    var v: Vector(Int);

    v.pushBack(3);
    v.pushBack(2);
    v.pushBack(1);
    v.pushBack(0);

    var r = v.all();

    while ( !r.isEmpty() ; r.popFront(); )
    {
        writeLn(r.front());
    }

    r = ContinousMemoryRange(Int)(v.all());
    while ( !r.isEmpty() ; r.popFront(); )
    {
        r.front() = r.front() + 1;
    }
    printSizeInfo(v);
    printVector(v);
}
/*<<<Range access(10)
3
2
1
0
not empty
4
4, 3, 2, 1
>>>*/

fun test11()
{
    var v: Vector(Int);
    var i = 0;

    while ( i < 4 ; i=i+1; )
    {
        v.pushBack(i);
    }
    printSizeInfo(v);
    printVector(v);
    v.popBack();
    v.popBack();
    printSizeInfo(v);
    printVector(v);
    v.popBack();
    v.popBack();
    printSizeInfo(v);
    v.pushBack(42);
    v.pushBack(43);
    printSizeInfo(v);
    printVector(v);
    v.popBack();
    v.popBack();
    i = 0;
    while ( i < 20 ; i=i+1; )
    {
        v.pushBack(i);
    }
    printSizeInfo(v);
    printVector(v);
}
/*<<<Pushing & popping(11)
not empty
4
0, 1, 2, 3
not empty
2
0, 1
empty
0
not empty
2
42, 43
not empty
20
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19
>>>*/

fun test12()
{
    var v: Vector(Int) = createRange(Int, 4);

    v.resize(4);
    printSizeInfo(v);
    printVector(v);
    v.resize(2);
    printSizeInfo(v);
    printVector(v);
    v.resize(6);
    printSizeInfo(v);
    //printVector(v);

    var vv: Vector(Int);

    vv.resize(6);
    printSizeInfo(vv);
    //printVector(vv);
}
/*<<<Resizing(12)
not empty
4
0, 1, 2, 3
not empty
2
0, 1
not empty
6
not empty
6
>>>*/

fun test13()
{
    var v: Vector(Int) = createRange(Int, 4);

    v.clear();
    printSizeInfo(v);
    v.pushBack(42);
    v.pushBack(43);
    printSizeInfo(v);
    printVector(v);
    v.clear();
    printSizeInfo(v);

    var vv: Vector(Int);
    vv.clear();
    printSizeInfo(v);
}
/*<<<Clear(13)
empty
0
not empty
2
42, 43
empty
0
empty
0
>>>*/

fun test14()
{
    //var v1: Vector(Int) = createRange(Int, 4);
    //var v2: Vector(Int) = createRange(Int, 6);
    //var v3: Vector(Int);

    //v2 = v1;
    //printSizeInfo(v2);
    //printVector(v2);
    //printSizeInfo(v1 = v2 = v3);
}
/*---<<<Assignment operator(14)
not empty
4
0 1 2 3
empty
0
>>>*/

fun test15()
{
    var v: Vector(Int) = createRange(Int, 4);
    var r = v.all();

    v.insertBefore(42, v.all());
    printSizeInfo(v);
    printVector(v);
    v.insertAfter(43, v.all());
    printSizeInfo(v);
    printVector(v);
    r = v.all();
    r.popFront();
    r.popFront();
    v.insertBefore(11, r);
    printSizeInfo(v);
    printVector(v);
    r = v.all();
    r.popBack();
    r.popBack();
    v.insertAfter(22, r);
    printSizeInfo(v);
    printVector(v);
}
/*<<<Element insertions(15)
not empty
5
42, 0, 1, 2, 3
not empty
6
42, 0, 1, 2, 3, 43
not empty
7
42, 0, 11, 1, 2, 3, 43
not empty
8
42, 0, 11, 1, 2, 22, 3, 43
>>>*/

fun test16()
{
    var v: Vector(Int) = createRange(Int, 4);
    var r = v.all();

    v.insertBefore(createRange(Int, 2), v.all());
    printSizeInfo(v);
    printVector(v);
    v.insertAfter(createRange(Int, 2), v.all());
    printSizeInfo(v);
    printVector(v);
    v.insertBefore(createRange(Int, 1), v.all());
    printSizeInfo(v);
    printVector(v);
    v.insertAfter(createRange(Int, 1), v.all());
    printSizeInfo(v);
    printVector(v);
    v.insertBefore(createRange(Int, 0), v.all());
    printSizeInfo(v);
    printVector(v);
    v.insertAfter(createRange(Int, 0), v.all());
    printSizeInfo(v);
    printVector(v);
    r = v.all();
    r.popFront();
    r.popFront();
    v.insertBefore(createRange(Int, 2), r);
    printSizeInfo(v);
    printVector(v);
    r = v.all();
    r.popBack();
    r.popBack();
    v.insertAfter(createRange(Int, 2), r);
    printSizeInfo(v);
    printVector(v);
    r = v.all();
    r.popFront();
    r.popFront();
    v.insertBefore(createRange(Int, 1), r);
    printSizeInfo(v);
    printVector(v);
    r = v.all();
    r.popBack();
    r.popBack();
    v.insertAfter(createRange(Int, 1), r);
    printSizeInfo(v);
    printVector(v);
    r = v.all();
    r.popFront();
    r.popFront();
    v.insertBefore(createRange(Int, 0), r);
    printSizeInfo(v);
    printVector(v);
    r = v.all();
    r.popBack();
    r.popBack();
    v.insertAfter(createRange(Int, 0), r);
    printSizeInfo(v);
    printVector(v);
}
/*<<<Range insertions(16)
not empty
6
0, 1, 0, 1, 2, 3
not empty
8
0, 1, 0, 1, 2, 3, 0, 1
not empty
9
0, 0, 1, 0, 1, 2, 3, 0, 1
not empty
10
0, 0, 1, 0, 1, 2, 3, 0, 1, 0
not empty
10
0, 0, 1, 0, 1, 2, 3, 0, 1, 0
not empty
10
0, 0, 1, 0, 1, 2, 3, 0, 1, 0
not empty
12
0, 0, 0, 1, 1, 0, 1, 2, 3, 0, 1, 0
not empty
14
0, 0, 0, 1, 1, 0, 1, 2, 3, 0, 0, 1, 1, 0
not empty
15
0, 0, 0, 0, 1, 1, 0, 1, 2, 3, 0, 0, 1, 1, 0
not empty
16
0, 0, 0, 0, 1, 1, 0, 1, 2, 3, 0, 0, 1, 0, 1, 0
not empty
16
0, 0, 0, 0, 1, 1, 0, 1, 2, 3, 0, 0, 1, 0, 1, 0
not empty
16
0, 0, 0, 0, 1, 1, 0, 1, 2, 3, 0, 0, 1, 0, 1, 0
>>>*/

fun test17()
{
    var v: Vector(Int) = createRange(Int, 6);
    var r = v.all();

    v.remove(v.all());
    printSizeInfo(v);
    v.swap(Vector(Int)(createRange(Int, 6)));
    r = v.all();
    r.popBack();
    v.remove(r);
    printSizeInfo(v);
    printVector(v);
    v.swap(Vector(Int)(createRange(Int, 6)));
    r = v.all();
    r.popFront();
    v.remove(r);
    printSizeInfo(v);
    printVector(v);
    v.swap(Vector(Int)(createRange(Int, 6)));
    r = v.all();
    r.popFront();
    r.popFront();
    r.popBack();
    v.remove(r);
    printSizeInfo(v);
    printVector(v);
    v.swap(Vector(Int)(createRange(Int, 6)));
    r = v.all();
    r.popFront(2);
    r.popBack(3);
    v.remove(r);
    printSizeInfo(v);
    printVector(v);
    v.swap(Vector(Int)(createRange(Int, 6)));
    r = v.all();
    r.popFront(3);
    r.popBack(3);
    v.remove(r);
    printSizeInfo(v);
    printVector(v);
}
/*<<<Range removal(17)
empty
0
not empty
1
5
not empty
1
0
not empty
3
0, 1, 5
not empty
5
0, 1, 3, 4, 5
not empty
6
0, 1, 2, 3, 4, 5
>>>*/

fun test18()
{
    var v1: Vector(Int) = createRange(Int, 4);
    var v2: Vector(Int) = createRange(Int, 4);
    var v3: Vector(Int) = createRange(Int, 6);

    // TODO
    //if ( v1 == v2 ) writeLn("true"); else writeLn("false");
    //if ( v1 == v3 ) writeLn("true"); else writeLn("false");
    //writeLn(v1 == ife(v2, "true", "false"));
    //writeLn(v1 == ife(v3, "true", "false"));
}
/*---<<<Equality operator(18)
true
false
>>>*/

fun test19()
{
    var v: Vector(Int) = createRange(Int, 1000);
    var i = 0;

    printSizeInfo(v);
    while ( intToSizeType(i) < v.size() ; i = i + 1; )
    {
        if ( v.at(i) != i )
        {
            writeLn("test failed");
        }
    }

    var vv = v;

    i = 0;
    printSizeInfo(vv);
    while ( intToSizeType(i) < vv.size() ; i = i + 1; )
    {
        if ( vv.at(i) != i )
        {
            writeLn("test failed");
        }
    }

    var vvv: Vector(Int);

    vvv.assign(createRange(Int, 1000));
    i = 0;
    printSizeInfo(vvv);
    while ( intToSizeType(i) < vvv.size() ; i = i + 1; )
    {
        if ( vvv.at(i) != i )
        {
            writeLn("test failed");
        }
    }
}
/*<<<Large vectors(19)
not empty
1000
not empty
1000
not empty
1000
>>>*/

fun test20()
{
    var v: Vector(Int) = createRange(Int, 8);

    v.remove(intToSizeType(1));
    printVector(v);
    v.remove(intToSizeType(0));
    printVector(v);
    v.remove(intToSizeType(5));
    printVector(v);
    v.remove(intToSizeType(3));
    printVector(v);
}
/*<<<Element removal(20)
0, 2, 3, 4, 5, 6, 7
2, 3, 4, 5, 6, 7
2, 3, 4, 5, 6
2, 3, 4, 6
>>>*/

fun test21()
{
    var v: Vector(Int) = createRange(Int, 8);
    var r = v.subrange(intToSizeType(0), intToSizeType(0));

    while ( !r.isEmpty() ; r.popFront(); )
    {
        writeLn(r.front());
    }
    r = v.subrange(0, 1);
    while ( !r.isEmpty() ; r.popFront(); )
    {
        writeLn(r.front());
    }
    r = v.subrange(2, 3);
    while ( !r.isEmpty() ; r.popFront(); )
    {
        writeLn(r.front());
    }
    r = v.subrange(intToSizeType(0), v.size());
    while ( !r.isEmpty() ; r.popFront(); )
    {
        writeLn(r.front());
    }
    v.remove(v.subrange(intToSizeType(2), intToSizeType(3)));
    printVector(v);
}
/*<<<Subrange(21)
0
2
3
4
0
1
2
3
4
5
6
7
0, 1, 5, 6, 7
>>>*/
