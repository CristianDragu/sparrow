//package Test;

fun[ct, native("$injectBackendCodeRt")] injectBackendCodeRt(code: StringRef);
fun[ct, native("$injectBackendCodeCt")] injectBackendCodeCt(code: StringRef);
fun[ct, native("$injectBackendCodeRtCt")] injectBackendCodeRtCt(code: StringRef);

injectBackendCodeRtCt(
"
@.fmtIntN = private unnamed_addr constant [4 x i8] c\"%d\\0A\\00\", align 1
@.fmtUIntN = private unnamed_addr constant [4 x i8] c\"%u\\0A\\00\", align 1
@.fmtCharN = private unnamed_addr constant [4 x i8] c\"%c\\0A\\00\", align 1
@.fmtDoubleN = private unnamed_addr constant [4 x i8] c\"%g\\0A\\00\", align 1
@.fmtStringN = private unnamed_addr constant [4 x i8] c\"%s\\0A\\00\", align 1
@.fmtPointerN = private unnamed_addr constant [4 x i8] c\"%p\\0A\\00\", align 1
@.fmtInt = private unnamed_addr constant [3 x i8] c\"%d\\00\", align 1
@.fmtUInt = private unnamed_addr constant [3 x i8] c\"%u\\00\", align 1
@.fmtChar = private unnamed_addr constant [3 x i8] c\"%c\\00\", align 1
@.fmtDouble = private unnamed_addr constant [3 x i8] c\"%g\\00\", align 1
@.fmtString = private unnamed_addr constant [3 x i8] c\"%s\\00\", align 1
@.fmtPointer = private unnamed_addr constant [3 x i8] c\"%p\\00\", align 1


define i32 @mulInt(i32 %x, i32 %y) {
  %1 = mul i32 %x,%y
  ret i32 %1
}

define double @mulDouble(double %x, double %y) {
  %1 = fmul double %x,%y
  ret double %1
}

define i32 @divInt(i32 %x, i32 %y) {
  %1 = sdiv i32 %x,%y
  ret i32 %1
}

define i32 @modInt(i32 %x, i32 %y) {
  %1 = srem i32 %x,%y
  ret i32 %1
}

define i32 @addInt(i32 %x, i32 %y) {
  %1 = add i32 %x,%y
  ret i32 %1
}

define i32 @subInt(i32 %x, i32 %y) {
  %1 = sub i32 %x,%y
  ret i32 %1
}

define double @addDouble(double %x, double %y) {
  %1 = fadd double %x,%y
  ret double %1
}

define double @subDouble(double %x, double %y) {
  %1 = fsub double %x,%y
  ret double %1
}

define i1 @equalInt(i32 %x, i32 %y) {
  %1 = icmp eq i32 %x,%y
  ret i1 %1
}

define i1 @leInt(i32 %x, i32 %y) {
  %1 = icmp sle i32 %x,%y
  ret i1 %1
}

define void @assignInt(i32* %ptr, i32 %val)
{
    store i32 %val, i32* %ptr
    ret void
}

define void @assignRefByte(i8** %ptr, i8* %val)
{
    store i8* %val, i8** %ptr
    ret void
}

define i8* @ptrAdd(i8* %p, i64 %n)
{
    %1 = getelementptr i8* %p, i64 %n
    ret i8* %1
}

define i8* @ptrSub(i8* %p, i64 %n)
{
    %1 = sub i64 0, %n 
    %2 = getelementptr i8* %p, i64 %1
    ret i8* %2
}

define i64 @ptrDiff(i8* %p1, i8* %p2)
{
    %1 = ptrtoint i8* %p1 to i64
    %2 = ptrtoint i8* %p2 to i64
    %3 = sub i64 %1, %2
    ret i64 %3
}

define i32 @main(i32 %argc, i8** %argv) nounwind uwtable {
  %1 = icmp sgt i32 %argc, 1
  br i1 %1, label %trueBranch, label %falseBranch

trueBranch:
  %2 = getelementptr inbounds i8** %argv, i64 1
  %3 = load i8** %2
  %4 = call i32 @atoi(i8* %3) nounwind readonly
  call void @test(i32 %4)
  br label %end

falseBranch:
  call void @test(i32 0)
  br label %end

end:
  ret i32 0
}

%Type = type { i8* }

%struct._IO_FILE = type opaque
declare i32 @fflush(%struct._IO_FILE*) nounwind readonly

declare i32 @atoi(i8*) nounwind readonly
declare i32 @printf(i8*, ...)
declare void @test(i32)
declare double @llvm.pow.f64(double,double)
declare i8* @malloc(i64) nounwind
declare i8* @realloc(i8*, i64) nounwind
declare void @free(i8*) nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture, i8* nocapture, i64, i32, i1) nounwind

define void @memcpyimpl(i8* %dest, i8* %src, i64 %size)
{
    call void @llvm.memcpy.p0i8.p0i8.i64(i8* %dest, i8* %src, i64 %size, i32 1, i1 false)
    ret void
}

define void @flushOutput()
{
    call i32 @fflush(%struct._IO_FILE* null)
    ret void
}


; Same type assignments
define void @_ass_8_8(i8* %$this, i8 %src)
{
  store i8 %src, i8* %$this
  ret void
}
define void @_ass_16_16(i16* %$this, i16 %src)
{
  store i16 %src, i16* %$this
  ret void
}
define void @_ass_32_32(i32* %$this, i32 %src)
{
  store i32 %src, i32* %$this
  ret void
}
define void @_ass_64_64(i64* %$this, i64 %src)
{
  store i64 %src, i64* %$this
  ret void
}
define void @_ass_f_f(float* %$this, float %src)
{
  store float %src, float* %$this
  ret void
}
define void @_ass_d_d(double* %$this, double %src)
{
  store double %src, double* %$this
  ret void
}

; Truncates
define void @_ass_8_16(i8* %$this, i16 %src)
{
  %1 = trunc i16 %src to i8
  store i8 %1, i8* %$this
  ret void
}
define void @_ass_8_32(i8* %$this, i32 %src)
{
  %1 = trunc i32 %src to i8
  store i8 %1, i8* %$this
  ret void
}
define void @_ass_8_64(i8* %$this, i64 %src)
{
  %1 = trunc i64 %src to i8
  store i8 %1, i8* %$this
  ret void
}
define void @_ass_16_32(i16* %$this, i32 %src)
{
  %1 = trunc i32 %src to i16
  store i16 %1, i16* %$this
  ret void
}
define void @_ass_16_64(i16* %$this, i64 %src)
{
  %1 = trunc i64 %src to i16
  store i16 %1, i16* %$this
  ret void
}
define void @_ass_32_64(i32* %$this, i64 %src)
{
  %1 = trunc i64 %src to i32
  store i32 %1, i32* %$this
  ret void
}

; Extends
define void @_ass_16_8s(i16* %$this, i8 %src)
{
  %1 = sext i8 %src to i16
  store i16 %1, i16* %$this
  ret void
}
define void @_ass_16_8z(i16* %$this, i8 %src)
{
  %1 = zext i8 %src to i16
  store i16 %1, i16* %$this
  ret void
}
define void @_ass_32_8s(i32* %$this, i8 %src)
{
  %1 = sext i8 %src to i32
  store i32 %1, i32* %$this
  ret void
}
define void @_ass_32_8z(i32* %$this, i8 %src)
{
  %1 = zext i8 %src to i32
  store i32 %1, i32* %$this
  ret void
}
define void @_ass_32_16s(i32* %$this, i16 %src)
{
  %1 = sext i16 %src to i32
  store i32 %1, i32* %$this
  ret void
}
define void @_ass_32_16z(i32* %$this, i16 %src)
{
  %1 = zext i16 %src to i32
  store i32 %1, i32* %$this
  ret void
}
define void @_ass_64_8s(i64* %$this, i8 %src)
{
  %1 = sext i8 %src to i64
  store i64 %1, i64* %$this
  ret void
}
define void @_ass_64_8z(i64* %$this, i8 %src)
{
  %1 = zext i8 %src to i64
  store i64 %1, i64* %$this
  ret void
}
define void @_ass_64_16s(i64* %$this, i16 %src)
{
  %1 = sext i16 %src to i64
  store i64 %1, i64* %$this
  ret void
}
define void @_ass_64_16z(i64* %$this, i16 %src)
{
  %1 = zext i16 %src to i64
  store i64 %1, i64* %$this
  ret void
}
define void @_ass_64_32s(i64* %$this, i32 %src)
{
  %1 = sext i32 %src to i64
  store i64 %1, i64* %$this
  ret void
}
define void @_ass_64_32z(i64* %$this, i32 %src)
{
  %1 = zext i32 %src to i64
  store i64 %1, i64* %$this
  ret void
}

; Floating to integral
define void @_ass_i8_f(i8* %$this, float %src)
{
  %1 = fptosi float %src to i8
  store i8 %1, i8* %$this
  ret void
}
define void @_ass_i8_d(i8* %$this, double %src)
{
  %1 = fptosi double %src to i8
  store i8 %1, i8* %$this
  ret void
}
define void @_ass_u8_f(i8* %$this, float %src)
{
  %1 = fptoui float %src to i8
  store i8 %1, i8* %$this
  ret void
}
define void @_ass_u8_d(i8* %$this, double %src)
{
  %1 = fptoui double %src to i8
  store i8 %1, i8* %$this
  ret void
}
define void @_ass_i16_f(i16* %$this, float %src)
{
  %1 = fptosi float %src to i16
  store i16 %1, i16* %$this
  ret void
}
define void @_ass_i16_d(i16* %$this, double %src)
{
  %1 = fptosi double %src to i16
  store i16 %1, i16* %$this
  ret void
}
define void @_ass_u16_f(i16* %$this, float %src)
{
  %1 = fptoui float %src to i16
  store i16 %1, i16* %$this
  ret void
}
define void @_ass_u16_d(i16* %$this, double %src)
{
  %1 = fptoui double %src to i16
  store i16 %1, i16* %$this
  ret void
}
define void @_ass_i32_f(i32* %$this, float %src)
{
  %1 = fptosi float %src to i32
  store i32 %1, i32* %$this
  ret void
}
define void @_ass_i32_d(i32* %$this, double %src)
{
  %1 = fptosi double %src to i32
  store i32 %1, i32* %$this
  ret void
}
define void @_ass_u32_f(i32* %$this, float %src)
{
  %1 = fptoui float %src to i32
  store i32 %1, i32* %$this
  ret void
}
define void @_ass_u32_d(i32* %$this, double %src)
{
  %1 = fptoui double %src to i32
  store i32 %1, i32* %$this
  ret void
}
define void @_ass_i64_f(i64* %$this, float %src)
{
  %1 = fptosi float %src to i64
  store i64 %1, i64* %$this
  ret void
}
define void @_ass_i64_d(i64* %$this, double %src)
{
  %1 = fptosi double %src to i64
  store i64 %1, i64* %$this
  ret void
}
define void @_ass_u64_f(i64* %$this, float %src)
{
  %1 = fptoui float %src to i64
  store i64 %1, i64* %$this
  ret void
}
define void @_ass_u64_d(i64* %$this, double %src)
{
  %1 = fptoui double %src to i64
  store i64 %1, i64* %$this
  ret void
}

; Something to floating
define void @_ass_f_i8(float* %$this, i8 %src)
{
  %1 = sitofp i8 %src to float
  store float %1, float* %$this
  ret void
}
define void @_ass_f_u8(float* %$this, i8 %src)
{
  %1 = uitofp i8 %src to float
  store float %1, float* %$this
  ret void
}
define void @_ass_f_i16(float* %$this, i16 %src)
{
  %1 = sitofp i16 %src to float
  store float %1, float* %$this
  ret void
}
define void @_ass_f_u16(float* %$this, i16 %src)
{
  %1 = uitofp i16 %src to float
  store float %1, float* %$this
  ret void
}
define void @_ass_f_i32(float* %$this, i32 %src)
{
  %1 = sitofp i32 %src to float
  store float %1, float* %$this
  ret void
}
define void @_ass_f_u32(float* %$this, i32 %src)
{
  %1 = uitofp i32 %src to float
  store float %1, float* %$this
  ret void
}
define void @_ass_f_i64(float* %$this, i64 %src)
{
  %1 = sitofp i64 %src to float
  store float %1, float* %$this
  ret void
}
define void @_ass_f_u64(float* %$this, i64 %src)
{
  %1 = uitofp i64 %src to float
  store float %1, float* %$this
  ret void
}
define void @_ass_f_d(float* %$this, double %src)
{
  %1 = fptrunc double %src to float
  store float %1, float* %$this
  ret void
}

define void @_ass_d_i8(double* %$this, i8 %src)
{
  %1 = sitofp i8 %src to double
  store double %1, double* %$this
  ret void
}
define void @_ass_d_u8(double* %$this, i8 %src)
{
  %1 = uitofp i8 %src to double
  store double %1, double* %$this
  ret void
}
define void @_ass_d_i16(double* %$this, i16 %src)
{
  %1 = sitofp i16 %src to double
  store double %1, double* %$this
  ret void
}
define void @_ass_d_u16(double* %$this, i16 %src)
{
  %1 = uitofp i16 %src to double
  store double %1, double* %$this
  ret void
}
define void @_ass_d_i32(double* %$this, i32 %src)
{
  %1 = sitofp i32 %src to double
  store double %1, double* %$this
  ret void
}
define void @_ass_d_u32(double* %$this, i32 %src)
{
  %1 = uitofp i32 %src to double
  store double %1, double* %$this
  ret void
}
define void @_ass_d_i64(double* %$this, i64 %src)
{
  %1 = sitofp i64 %src to double
  store double %1, double* %$this
  ret void
}
define void @_ass_d_u64(double* %$this, i64 %src)
{
  %1 = uitofp i64 %src to double
  store double %1, double* %$this
  ret void
}
define void @_ass_d_f(double* %$this, float %src)
{
  %1 = fpext float %src to double
  store double %1, double* %$this
  ret void
}



define i1 @_Bool_opAssign(i1* %x, i1 %y)        {\n  store i1 %y, i1* %x\n  ret i1 %y\n}
define i1 @_Bool_opOr(i1 %x, i1 %y)             {\n  %1 = or i1 %x, %y\n  ret i1 %1\n}
define i1 @_Bool_opXor(i1 %x, i1 %y)            {\n  %1 = xor i1 %x, %y\n  ret i1 %1\n}
define i1 @_Bool_opAnd(i1 %x, i1 %y)            {\n  %1 = and i1 %x, %y\n  ret i1 %1\n}
define i1 @_Bool_opEQ(i1 %x, i1 %y)             {\n  %1 = icmp eq i1 %x, %y\n  ret i1 %1\n}
define i1 @_Bool_opNE(i1 %x, i1 %y)             {\n  %1 = icmp ne i1 %x, %y\n  ret i1 %1\n}
define i1 @_Bool_opNeg(i1 %x)                   {\n  %1 = xor i1 %x, 1\n  ret i1 %1\n}

define i8 @_Byte_opAssign(i8* %x, i8 %y)        {\n  store i8 %y, i8* %x\n  ret i8 %y\n}
define i1 @_Byte_opEQ(i8 %x, i8 %y)             {\n  %1 = icmp eq i8 %x, %y\n  ret i1 %1\n}
define i1 @_Byte_opNE(i8 %x, i8 %y)             {\n  %1 = icmp ne i8 %x, %y\n  ret i1 %1\n}
define i1 @_Byte_opLT(i8 %x, i8 %y)             {\n  %1 = icmp slt i8 %x, %y\n  ret i1 %1\n}
define i1 @_Byte_opGT(i8 %x, i8 %y)             {\n  %1 = icmp sgt i8 %x, %y\n  ret i1 %1\n}
define i1 @_Byte_opLE(i8 %x, i8 %y)             {\n  %1 = icmp sle i8 %x, %y\n  ret i1 %1\n}
define i1 @_Byte_opGE(i8 %x, i8 %y)             {\n  %1 = icmp sge i8 %x, %y\n  ret i1 %1\n}
define i8 @_Byte_opPlus(i8 %x, i8 %y)           {\n  %1 = add i8 %x, %y\n  ret i8 %1\n}
define i8 @_Byte_opMinus(i8 %x, i8 %y)          {\n  %1 = sub i8 %x, %y\n  ret i8 %1\n}
define i8 @_Byte_opMul(i8 %x, i8 %y)            {\n  %1 = mul i8 %x, %y\n  ret i8 %1\n}
define i8 @_Byte_opDiv(i8 %x, i8 %y)            {\n  %1 = sdiv i8 %x, %y\n  ret i8 %1\n}
define i8 @_Byte_opMod(i8 %x, i8 %y)            {\n  %1 = srem i8 %x, %y\n  ret i8 %1\n}
define i8 @_Byte_opPlus1(i8 %x)                 {\n  ret i8 %x\n}
define i8 @_Byte_opMinus1(i8 %x)                {\n  %1 = sub i8 0, %x\n  ret i8 %1\n}

define i8 @_UByte_opAssign(i8* %x, i8 %y)       {\n  store i8 %y, i8* %x\n  ret i8 %y\n}
define i1 @_UByte_opEQ(i8 %x, i8 %y)            {\n  %1 = icmp eq i8 %x, %y\n  ret i1 %1\n}
define i1 @_UByte_opNE(i8 %x, i8 %y)            {\n  %1 = icmp ne i8 %x, %y\n  ret i1 %1\n}
define i1 @_UByte_opLT(i8 %x, i8 %y)            {\n  %1 = icmp ult i8 %x, %y\n  ret i1 %1\n}
define i1 @_UByte_opGT(i8 %x, i8 %y)            {\n  %1 = icmp ugt i8 %x, %y\n  ret i1 %1\n}
define i1 @_UByte_opLE(i8 %x, i8 %y)            {\n  %1 = icmp ule i8 %x, %y\n  ret i1 %1\n}
define i1 @_UByte_opGE(i8 %x, i8 %y)            {\n  %1 = icmp uge i8 %x, %y\n  ret i1 %1\n}
define i8 @_UByte_opPlus(i8 %x, i8 %y)          {\n  %1 = add i8 %x, %y\n  ret i8 %1\n}
define i8 @_UByte_opMinus(i8 %x, i8 %y)         {\n  %1 = sub i8 %x, %y\n  ret i8 %1\n}
define i8 @_UByte_opMul(i8 %x, i8 %y)           {\n  %1 = mul i8 %x, %y\n  ret i8 %1\n}
define i8 @_UByte_opDiv(i8 %x, i8 %y)           {\n  %1 = sdiv i8 %x, %y\n  ret i8 %1\n}
define i8 @_UByte_opMod(i8 %x, i8 %y)           {\n  %1 = srem i8 %x, %y\n  ret i8 %1\n}
define i8 @_UByte_opPlus1(i8 %x)                {\n  ret i8 %x\n}

define i16 @_Short_opAssign(i16* %x, i16 %y)    {\n  store i16 %y, i16* %x\n  ret i16 %y\n}
define i1 @_Short_opEQ(i16 %x, i16 %y)          {\n  %1 = icmp eq i16 %x, %y\n  ret i1 %1\n}
define i1 @_Short_opNE(i16 %x, i16 %y)          {\n  %1 = icmp ne i16 %x, %y\n  ret i1 %1\n}
define i1 @_Short_opLT(i16 %x, i16 %y)          {\n  %1 = icmp slt i16 %x, %y\n  ret i1 %1\n}
define i1 @_Short_opGT(i16 %x, i16 %y)          {\n  %1 = icmp sgt i16 %x, %y\n  ret i1 %1\n}
define i1 @_Short_opLE(i16 %x, i16 %y)          {\n  %1 = icmp sle i16 %x, %y\n  ret i1 %1\n}
define i1 @_Short_opGE(i16 %x, i16 %y)          {\n  %1 = icmp sge i16 %x, %y\n  ret i1 %1\n}
define i16 @_Short_opPlus(i16 %x, i16 %y)       {\n  %1 = add i16 %x, %y\n  ret i16 %1\n}
define i16 @_Short_opMinus(i16 %x, i16 %y)      {\n  %1 = sub i16 %x, %y\n  ret i16 %1\n}
define i16 @_Short_opMul(i16 %x, i16 %y)        {\n  %1 = mul i16 %x, %y\n  ret i16 %1\n}
define i16 @_Short_opDiv(i16 %x, i16 %y)        {\n  %1 = sdiv i16 %x, %y\n  ret i16 %1\n}
define i16 @_Short_opMod(i16 %x, i16 %y)        {\n  %1 = srem i16 %x, %y\n  ret i16 %1\n}
define i16 @_Short_opPlus1(i16 %x)              {\n  ret i16 %x\n}
define i16 @_Short_opMinus1(i16 %x)             {\n  %1 = sub i16 0, %x\n  ret i16 %1\n}

define i16 @_UShort_opAssign(i16* %x, i16 %y)   {\n  store i16 %y, i16* %x\n  ret i16 %y\n}
define i1 @_UShort_opEQ(i16 %x, i16 %y)         {\n  %1 = icmp eq i16 %x, %y\n  ret i1 %1\n}
define i1 @_UShort_opNE(i16 %x, i16 %y)         {\n  %1 = icmp ne i16 %x, %y\n  ret i1 %1\n}
define i1 @_UShort_opLT(i16 %x, i16 %y)         {\n  %1 = icmp ult i16 %x, %y\n  ret i1 %1\n}
define i1 @_UShort_opGT(i16 %x, i16 %y)         {\n  %1 = icmp ugt i16 %x, %y\n  ret i1 %1\n}
define i1 @_UShort_opLE(i16 %x, i16 %y)         {\n  %1 = icmp ule i16 %x, %y\n  ret i1 %1\n}
define i1 @_UShort_opGE(i16 %x, i16 %y)         {\n  %1 = icmp uge i16 %x, %y\n  ret i1 %1\n}
define i16 @_UShort_opPlus(i16 %x, i16 %y)      {\n  %1 = add i16 %x, %y\n  ret i16 %1\n}
define i16 @_UShort_opMinus(i16 %x, i16 %y)     {\n  %1 = sub i16 %x, %y\n  ret i16 %1\n}
define i16 @_UShort_opMul(i16 %x, i16 %y)       {\n  %1 = mul i16 %x, %y\n  ret i16 %1\n}
define i16 @_UShort_opDiv(i16 %x, i16 %y)       {\n  %1 = sdiv i16 %x, %y\n  ret i16 %1\n}
define i16 @_UShort_opMod(i16 %x, i16 %y)       {\n  %1 = srem i16 %x, %y\n  ret i16 %1\n}
define i16 @_UShort_opPlus1(i16 %x)             {\n  ret i16 %x\n}

define i32 @_Int_opAssign(i32* %x, i32 %y)      {\n  store i32 %y, i32* %x\n  ret i32 %y\n}
define i1 @_Int_opEQ(i32 %x, i32 %y)            {\n  %1 = icmp eq i32 %x, %y\n  ret i1 %1\n}
define i1 @_Int_opNE(i32 %x, i32 %y)            {\n  %1 = icmp ne i32 %x, %y\n  ret i1 %1\n}
define i1 @_Int_opLT(i32 %x, i32 %y)            {\n  %1 = icmp slt i32 %x, %y\n  ret i1 %1\n}
define i1 @_Int_opGT(i32 %x, i32 %y)            {\n  %1 = icmp sgt i32 %x, %y\n  ret i1 %1\n}
define i1 @_Int_opLE(i32 %x, i32 %y)            {\n  %1 = icmp sle i32 %x, %y\n  ret i1 %1\n}
define i1 @_Int_opGE(i32 %x, i32 %y)            {\n  %1 = icmp sge i32 %x, %y\n  ret i1 %1\n}
define i32 @_Int_opPlus(i32 %x, i32 %y)         {\n  %1 = add i32 %x, %y\n  ret i32 %1\n}
define i32 @_Int_opMinus(i32 %x, i32 %y)        {\n  %1 = sub i32 %x, %y\n  ret i32 %1\n}
define i32 @_Int_opMul(i32 %x, i32 %y)          {\n  %1 = mul i32 %x, %y\n  ret i32 %1\n}
define i32 @_Int_opDiv(i32 %x, i32 %y)          {\n  %1 = sdiv i32 %x, %y\n  ret i32 %1\n}
define i32 @_Int_opMod(i32 %x, i32 %y)          {\n  %1 = srem i32 %x, %y\n  ret i32 %1\n}
define i32 @_Int_opPlus1(i32 %x)                {\n  ret i32 %x\n}
define i32 @_Int_opMinus1(i32 %x)               {\n  %1 = sub i32 0, %x\n  ret i32 %1\n}

define i32 @_UInt_opAssign(i32* %x, i32 %y)     {\n  store i32 %y, i32* %x\n  ret i32 %y\n}
define i1 @_UInt_opEQ(i32 %x, i32 %y)           {\n  %1 = icmp eq i32 %x, %y\n  ret i1 %1\n}
define i1 @_UInt_opNE(i32 %x, i32 %y)           {\n  %1 = icmp ne i32 %x, %y\n  ret i1 %1\n}
define i1 @_UInt_opLT(i32 %x, i32 %y)           {\n  %1 = icmp ult i32 %x, %y\n  ret i1 %1\n}
define i1 @_UInt_opGT(i32 %x, i32 %y)           {\n  %1 = icmp ugt i32 %x, %y\n  ret i1 %1\n}
define i1 @_UInt_opLE(i32 %x, i32 %y)           {\n  %1 = icmp ule i32 %x, %y\n  ret i1 %1\n}
define i1 @_UInt_opGE(i32 %x, i32 %y)           {\n  %1 = icmp uge i32 %x, %y\n  ret i1 %1\n}
define i32 @_UInt_opPlus(i32 %x, i32 %y)        {\n  %1 = add i32 %x, %y\n  ret i32 %1\n}
define i32 @_UInt_opMinus(i32 %x, i32 %y)       {\n  %1 = sub i32 %x, %y\n  ret i32 %1\n}
define i32 @_UInt_opMul(i32 %x, i32 %y)         {\n  %1 = mul i32 %x, %y\n  ret i32 %1\n}
define i32 @_UInt_opDiv(i32 %x, i32 %y)         {\n  %1 = sdiv i32 %x, %y\n  ret i32 %1\n}
define i32 @_UInt_opMod(i32 %x, i32 %y)         {\n  %1 = srem i32 %x, %y\n  ret i32 %1\n}
define i32 @_UInt_opPlus1(i32 %x)               {\n  ret i32 %x\n}

define i64 @_Long_opAssign(i64* %x, i64 %y)     {\n  store i64 %y, i64* %x\n  ret i64 %y\n}
define i1 @_Long_opEQ(i64 %x, i64 %y)           {\n  %1 = icmp eq i64 %x, %y\n  ret i1 %1\n}
define i1 @_Long_opNE(i64 %x, i64 %y)           {\n  %1 = icmp ne i64 %x, %y\n  ret i1 %1\n}
define i1 @_Long_opLT(i64 %x, i64 %y)           {\n  %1 = icmp slt i64 %x, %y\n  ret i1 %1\n}
define i1 @_Long_opGT(i64 %x, i64 %y)           {\n  %1 = icmp sgt i64 %x, %y\n  ret i1 %1\n}
define i1 @_Long_opLE(i64 %x, i64 %y)           {\n  %1 = icmp sle i64 %x, %y\n  ret i1 %1\n}
define i1 @_Long_opGE(i64 %x, i64 %y)           {\n  %1 = icmp sge i64 %x, %y\n  ret i1 %1\n}
define i64 @_Long_opPlus(i64 %x, i64 %y)        {\n  %1 = add i64 %x, %y\n  ret i64 %1\n}
define i64 @_Long_opMinus(i64 %x, i64 %y)       {\n  %1 = sub i64 %x, %y\n  ret i64 %1\n}
define i64 @_Long_opMul(i64 %x, i64 %y)         {\n  %1 = mul i64 %x, %y\n  ret i64 %1\n}
define i64 @_Long_opDiv(i64 %x, i64 %y)         {\n  %1 = sdiv i64 %x, %y\n  ret i64 %1\n}
define i64 @_Long_opMod(i64 %x, i64 %y)         {\n  %1 = srem i64 %x, %y\n  ret i64 %1\n}
define i64 @_Long_opPlus1(i64 %x)               {\n  ret i64 %x\n}
define i64 @_Long_opMinus1(i64 %x)              {\n  %1 = sub i64 0, %x\n  ret i64 %1\n}

define i64 @_ULong_opAssign(i64* %x, i64 %y)    {\n  store i64 %y, i64* %x\n  ret i64 %y\n}
define i1 @_ULong_opEQ(i64 %x, i64 %y)          {\n  %1 = icmp eq i64 %x, %y\n  ret i1 %1\n}
define i1 @_ULong_opNE(i64 %x, i64 %y)          {\n  %1 = icmp ne i64 %x, %y\n  ret i1 %1\n}
define i1 @_ULong_opLT(i64 %x, i64 %y)          {\n  %1 = icmp ult i64 %x, %y\n  ret i1 %1\n}
define i1 @_ULong_opGT(i64 %x, i64 %y)          {\n  %1 = icmp ugt i64 %x, %y\n  ret i1 %1\n}
define i1 @_ULong_opLE(i64 %x, i64 %y)          {\n  %1 = icmp ule i64 %x, %y\n  ret i1 %1\n}
define i1 @_ULong_opGE(i64 %x, i64 %y)          {\n  %1 = icmp uge i64 %x, %y\n  ret i1 %1\n}
define i64 @_ULong_opPlus(i64 %x, i64 %y)       {\n  %1 = add i64 %x, %y\n  ret i64 %1\n}
define i64 @_ULong_opMinus(i64 %x, i64 %y)      {\n  %1 = sub i64 %x, %y\n  ret i64 %1\n}
define i64 @_ULong_opMul(i64 %x, i64 %y)        {\n  %1 = mul i64 %x, %y\n  ret i64 %1\n}
define i64 @_ULong_opDiv(i64 %x, i64 %y)        {\n  %1 = sdiv i64 %x, %y\n  ret i64 %1\n}
define i64 @_ULong_opMod(i64 %x, i64 %y)        {\n  %1 = srem i64 %x, %y\n  ret i64 %1\n}
define i64 @_ULong_opPlus1(i64 %x)              {\n  ret i64 %x\n}

define float @_Float_opAssign(float* %x, float %y)      {\n  store float %y, float* %x\n  ret float %y\n}
define i1 @_Float_opEQ(float %x, float %y)              {\n  %1 = fcmp oeq float %x, %y\n  ret i1 %1\n}
define i1 @_Float_opNE(float %x, float %y)              {\n  %1 = fcmp one float %x, %y\n  ret i1 %1\n}
define i1 @_Float_opLT(float %x, float %y)              {\n  %1 = fcmp olt float %x, %y\n  ret i1 %1\n}
define i1 @_Float_opGT(float %x, float %y)              {\n  %1 = fcmp ogt float %x, %y\n  ret i1 %1\n}
define i1 @_Float_opLE(float %x, float %y)              {\n  %1 = fcmp ole float %x, %y\n  ret i1 %1\n}
define i1 @_Float_opGE(float %x, float %y)              {\n  %1 = fcmp oge float %x, %y\n  ret i1 %1\n}
define float @_Float_opPlus(float %x, float %y)         {\n  %1 = fadd float %x, %y\n  ret float %1\n}
define float @_Float_opMinus(float %x, float %y)        {\n  %1 = fsub float %x, %y\n  ret float %1\n}
define float @_Float_opMul(float %x, float %y)          {\n  %1 = fmul float %x, %y\n  ret float %1\n}
define float @_Float_opDiv(float %x, float %y)          {\n  %1 = fdiv float %x, %y\n  ret float %1\n}
define float @_Float_opPlus1(float %x)                  {\n  ret float %x\n}
define float @_Float_opMinus1(float %x)                 {\n  %1 = fsub float 0.0, %x\n  ret float %1\n}

define double @_Double_opAssign(double* %x, double %y)  {\n  store double %y, double* %x\n  ret double %y\n}
define i1 @_Double_opEQ(double %x, double %y)           {\n  %1 = fcmp oeq double %x, %y\n  ret i1 %1\n}
define i1 @_Double_opNE(double %x, double %y)           {\n  %1 = fcmp one double %x, %y\n  ret i1 %1\n}
define i1 @_Double_opLT(double %x, double %y)           {\n  %1 = fcmp olt double %x, %y\n  ret i1 %1\n}
define i1 @_Double_opGT(double %x, double %y)           {\n  %1 = fcmp ogt double %x, %y\n  ret i1 %1\n}
define i1 @_Double_opLE(double %x, double %y)           {\n  %1 = fcmp ole double %x, %y\n  ret i1 %1\n}
define i1 @_Double_opGE(double %x, double %y)           {\n  %1 = fcmp oge double %x, %y\n  ret i1 %1\n}
define double @_Double_opPlus(double %x, double %y)     {\n  %1 = fadd double %x, %y\n  ret double %1\n}
define double @_Double_opMinus(double %x, double %y)    {\n  %1 = fsub double %x, %y\n  ret double %1\n}
define double @_Double_opMul(double %x, double %y)      {\n  %1 = fmul double %x, %y\n  ret double %1\n}
define double @_Double_opDiv(double %x, double %y)      {\n  %1 = fdiv double %x, %y\n  ret double %1\n}
define double @_Double_opPlus1(double %x)               {\n  ret double %x\n}
define double @_Double_opMinus1(double %x)              {\n  %1 = fsub double 0.0, %x\n  ret double %1\n}

define i8 @_Char_opAssign(i8* %x, i8 %y)        {\n  store i8 %y, i8* %x\n  ret i8 %y\n}
define i1 @_Char_opEQ(i8 %x, i8 %y)             {\n  %1 = icmp eq i8 %x, %y\n  ret i1 %1\n}
define i1 @_Char_opNE(i8 %x, i8 %y)             {\n  %1 = icmp ne i8 %x, %y\n  ret i1 %1\n}
define i1 @_Char_opLT(i8 %x, i8 %y)             {\n  %1 = icmp slt i8 %x, %y\n  ret i1 %1\n}
define i1 @_Char_opGT(i8 %x, i8 %y)             {\n  %1 = icmp sgt i8 %x, %y\n  ret i1 %1\n}
define i1 @_Char_opLE(i8 %x, i8 %y)             {\n  %1 = icmp sle i8 %x, %y\n  ret i1 %1\n}
define i1 @_Char_opGE(i8 %x, i8 %y)             {\n  %1 = icmp sge i8 %x, %y\n  ret i1 %1\n}

define i1 @_opRefEQ(i8* %x, i8* %y)             {\n  %1 = icmp eq i8* %x, %y\n  ret i1 %1\n}
define i1 @_opRefNE(i8* %x, i8* %y)              {\n  %1 = icmp ne i8* %x, %y\n  ret i1 %1\n}

define i64 @_SizeType_opAssign(i64* %x, i64 %y)     {\n  store i64 %y, i64* %x\n  ret i64 %y\n}
define i1 @_SizeType_opEQ(i64 %x, i64 %y)           {\n  %1 = icmp eq i64 %x, %y\n  ret i1 %1\n}
define i1 @_SizeType_opNE(i64 %x, i64 %y)           {\n  %1 = icmp ne i64 %x, %y\n  ret i1 %1\n}
define i1 @_SizeType_opLT(i64 %x, i64 %y)           {\n  %1 = icmp ult i64 %x, %y\n  ret i1 %1\n}
define i1 @_SizeType_opGT(i64 %x, i64 %y)           {\n  %1 = icmp ugt i64 %x, %y\n  ret i1 %1\n}
define i1 @_SizeType_opLE(i64 %x, i64 %y)           {\n  %1 = icmp ule i64 %x, %y\n  ret i1 %1\n}
define i1 @_SizeType_opGE(i64 %x, i64 %y)           {\n  %1 = icmp uge i64 %x, %y\n  ret i1 %1\n}
define i64 @_SizeType_opPlus(i64 %x, i64 %y)        {\n  %1 = add i64 %x, %y\n  ret i64 %1\n}
define i64 @_SizeType_opMinus(i64 %x, i64 %y)       {\n  %1 = sub i64 %x, %y\n  ret i64 %1\n}
define i64 @_SizeType_opMul(i64 %x, i64 %y)         {\n  %1 = mul i64 %x, %y\n  ret i64 %1\n}
define i64 @_SizeType_opDiv(i64 %x, i64 %y)         {\n  %1 = sdiv i64 %x, %y\n  ret i64 %1\n}
define i64 @_SizeType_opMod(i64 %x, i64 %y)         {\n  %1 = srem i64 %x, %y\n  ret i64 %1\n}
define i64 @_SizeType_opPlus1(i64 %x)               {\n  ret i64 %x\n}


define i64 @intToSizeType(i32 %n) {
    %1 = sext i32 %n to i64
    ret i64 %1
}

define i8 @intToByte(i32 %n) {
    %1 = trunc i32 %n to i8
    ret i8 %1
}


define void @writeLnByte(i8 %val) {
  %1 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.fmtIntN, i32 0, i32 0), i8 %val)
  ret void
}

define void @writeLnShort(i16 %val) {
  %1 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.fmtIntN, i32 0, i32 0), i16 %val)
  ret void
}

define void @writeLnInt(i32 %val) {
  %1 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.fmtIntN, i32 0, i32 0), i32 %val)
  ret void
}

define void @writeLnUInt(i32 %val) {
  %1 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.fmtIntN, i32 0, i32 0), i32 %val)
  ret void
}

define void @writeLnSizeType(i64 %val) {
  %1 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.fmtIntN, i32 0, i32 0), i64 %val)
  ret void
}

define void @writeLnFloat(float %val) {
  %1 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.fmtDoubleN, i32 0, i32 0), float %val)
  ret void
}

define void @writeLnDouble(double %val) {
  %1 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.fmtDoubleN, i32 0, i32 0), double %val)
  ret void
}

define void @writeLnChar(i8 %val) {
  %1 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.fmtCharN, i32 0, i32 0), i8 %val)
  ret void
}

define void @writeLnStringImpl(i8* %val) {
  %1 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.fmtStringN, i32 0, i32 0), i8* %val)
  ret void
}

define void @writeLnPointer(i8* %val) {
  %1 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.fmtPointerN, i32 0, i32 0), i8* %val)
  ret void
}

define void @writeByte(i8 %val) {
  %1 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([3 x i8]* @.fmtInt, i32 0, i32 0), i8 %val)
  ret void
}

define void @writeShort(i16 %val) {
  %1 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([3 x i8]* @.fmtInt, i32 0, i32 0), i16 %val)
  ret void
}

define void @writeInt(i32 %val) {
  %1 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([3 x i8]* @.fmtInt, i32 0, i32 0), i32 %val)
  ret void
}

define void @writeSizeType(i64 %val) {
  %1 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([3 x i8]* @.fmtInt, i32 0, i32 0), i64 %val)
  ret void
}

define void @writeDouble(double %val) {
  %1 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([3 x i8]* @.fmtDouble, i32 0, i32 0), double %val)
  ret void
}

define void @writeChar(i8 %val) {
  %1 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([3 x i8]* @.fmtChar, i32 0, i32 0), i8 %val)
  ret void
}

define void @writeStringImpl(i8* %val) {
  %1 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([3 x i8]* @.fmtString, i32 0, i32 0), i8* %val)
  ret void
}

define void @writePointer(i8* %val) {
  %1 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([3 x i8]* @.fmtPointer, i32 0, i32 0), i8* %val)
  ret void
}

define void @_Type_ctor(i8** %$this)
{
  store i8* null, i8** %$this
  ret void
}

define void @_Type_copy_ctor(i8** %$this, i8* %other)
{
  store i8* %other, i8** %$this
  ret void
}

"
);

class[native("Type"), noDefault, ct] Type
{
    fun[native("_Type_ctor")] ctor;
    fun[native("_Type_copy_ctor")] ctor(other: Type);
    fun dtor {}
}

class[noDefault, rtct] Uninitialized
{
    fun ctor() {}
    fun ctor(other: Uninitialized) {}
    fun dtor {}

    fun[rt] ctorFromCt(src: Uninitialized ct) {}
}

class[rtct, noDefault, native("Null")] Null
{
    fun ctor() {}
    fun ctor(other: Uninitialized) {}
    fun ctor(other: Null) {}
    fun dtor {}
}

class[native("i1"), noDefault, rtct] Bool
{
    fun ctor() { this = false; }
    fun ctor(other: Uninitialized) {}
    fun ctor(other: Bool) { this = other; }
    fun dtor {} 
}

class[native("i8"), noDefault, rtct] Byte
{
    fun ctor() { this = Byte(0); }
    fun ctor(other: Uninitialized) {}
    fun[native("_ass_8_8")] ctor(src: Byte);
    fun[native("_ass_8_8"), convert] ctor(src: UByte);
    fun[native("_ass_8_16")] ctor(src: Short);
    fun[native("_ass_8_16")] ctor(src: UShort);
    fun[native("_ass_8_32")] ctor(src: Int);
    fun[native("_ass_8_32")] ctor(src: UInt);
    fun[native("_ass_8_64")] ctor(src: Long);
    fun[native("_ass_8_64")] ctor(src: ULong);
    fun[native("_ass_8_64")] ctor(src: SizeType);
    fun[native("_ass_i8_f")] ctor(src: Float);
    fun[native("_ass_i8_d")] ctor(src: Double);
    fun dtor {}
}

class[native("u8"), noDefault, rtct] UByte
{
    fun ctor() { this = UByte(0); }
    fun ctor(other: Uninitialized) {}
    fun[native("_ass_8_8"), convert] ctor(src: Byte);
    fun[native("_ass_8_8")] ctor(src: UByte);
    fun[native("_ass_8_16")] ctor(src: Short);
    fun[native("_ass_8_16")] ctor(src: UShort);
    fun[native("_ass_8_32")] ctor(src: Int);
    fun[native("_ass_8_32")] ctor(src: UInt);
    fun[native("_ass_8_64")] ctor(src: Long);
    fun[native("_ass_8_64")] ctor(src: ULong);
    fun[native("_ass_8_64")] ctor(src: SizeType);
    fun[native("_ass_u8_f")] ctor(src: Float);
    fun[native("_ass_u8_d")] ctor(src: Double);
    fun dtor {} 
}

class[native("i16"), noDefault, rtct] Short
{
    fun ctor() { this = Short(0); }
    fun ctor(other: Uninitialized) {}
    fun[native("_ass_16_8s"), convert] ctor(src: Byte);
    fun[native("_ass_16_8z"), convert] ctor(src: UByte);
    fun[native("_ass_16_16")] ctor(src: Short);
    fun[native("_ass_16_16"), convert] ctor(src: UShort);
    fun[native("_ass_16_32")] ctor(src: Int);
    fun[native("_ass_16_32")] ctor(src: UInt);
    fun[native("_ass_16_64")] ctor(src: Long);
    fun[native("_ass_16_64")] ctor(src: ULong);
    fun[native("_ass_16_64")] ctor(src: SizeType);
    fun[native("_ass_i16_f")] ctor(src: Float);
    fun[native("_ass_i16_d")] ctor(src: Double);
    fun dtor {}
}

class[native("i16"), noDefault, rtct] UShort
{
    fun ctor() { this = UShort(0); }
    fun ctor(other: Uninitialized) {}
    fun[native("_ass_16_8z"), convert] ctor(src: Byte);
    fun[native("_ass_16_8z"), convert] ctor(src: UByte);
    fun[native("_ass_16_16"), convert] ctor(src: Short);
    fun[native("_ass_16_16")] ctor(src: UShort);
    fun[native("_ass_16_32")] ctor(src: Int);
    fun[native("_ass_16_32")] ctor(src: UInt);
    fun[native("_ass_16_64")] ctor(src: Long);
    fun[native("_ass_16_64")] ctor(src: ULong);
    fun[native("_ass_16_64")] ctor(src: SizeType);
    fun[native("_ass_u16_f")] ctor(src: Float);
    fun[native("_ass_u16_d")] ctor(src: Double);
    fun dtor {}
}

class[native("i32"), noDefault, rtct] Int
{
    fun ctor() { this = 0; }
    fun ctor(other: Uninitialized) {}
    fun[native("_ass_32_8s"), convert] ctor(src: Byte);
    fun[native("_ass_32_8z"), convert] ctor(src: UByte);
    fun[native("_ass_32_16s"), convert] ctor(src: Short);
    fun[native("_ass_32_16z"), convert] ctor(src: UShort);
    fun[native("_ass_32_32")] ctor(src: Int);
    fun[native("_ass_32_32"), convert] ctor(src: UInt);
    fun[native("_ass_32_64")] ctor(src: Long);
    fun[native("_ass_32_64")] ctor(src: ULong);
    fun[native("_ass_32_64")] ctor(src: SizeType);
    fun[native("_ass_i32_f")] ctor(src: Float);
    fun[native("_ass_i32_d")] ctor(src: Double);
    fun dtor {}
}

class[native("u32"), noDefault, rtct] UInt
{
    fun ctor() { this = 0; }
    fun ctor(other: Uninitialized) {}
    fun[native("_ass_32_8z"), convert] ctor(src: Byte);
    fun[native("_ass_32_8z"), convert] ctor(src: UByte);
    fun[native("_ass_32_16z"), convert] ctor(src: Short);
    fun[native("_ass_32_16z"), convert] ctor(src: UShort);
    fun[native("_ass_32_32"), convert] ctor(src: Int);
    fun[native("_ass_32_32")] ctor(src: UInt);
    fun[native("_ass_32_64")] ctor(src: Long);
    fun[native("_ass_32_64")] ctor(src: ULong);
    fun[native("_ass_32_64")] ctor(src: SizeType);
    fun[native("_ass_u32_f")] ctor(src: Float);
    fun[native("_ass_u32_d")] ctor(src: Double);
    fun dtor {}
}

class[native("i64"), noDefault, rtct] Long
{
    fun ctor() { this = 0; }
    fun ctor(other: Uninitialized) {}
    fun[native("_ass_64_8s"), convert] ctor(src: Byte);
    fun[native("_ass_64_8z"), convert] ctor(src: UByte);
    fun[native("_ass_64_16s"), convert] ctor(src: Short);
    fun[native("_ass_64_16z"), convert] ctor(src: UShort);
    fun[native("_ass_64_32s"), convert] ctor(src: Int);
    fun[native("_ass_64_32z"), convert] ctor(src: UInt);
    fun[native("_ass_64_64")] ctor(src: Long);
    fun[native("_ass_64_64"), convert] ctor(src: ULong);
    fun[native("_ass_64_64"), convert] ctor(src: SizeType);
    fun[native("_ass_i64_f")] ctor(src: Float);
    fun[native("_ass_i64_d")] ctor(src: Double);
    fun dtor {}
}

class[native("u64"), noDefault, rtct] ULong
{
    fun ctor() { this = 0; }
    fun ctor(other: Uninitialized) {}
    fun[native("_ass_64_8z"), convert] ctor(src: Byte);
    fun[native("_ass_64_8z"), convert] ctor(src: UByte);
    fun[native("_ass_64_16z"), convert] ctor(src: Short);
    fun[native("_ass_64_16z"), convert] ctor(src: UShort);
    fun[native("_ass_64_32z"), convert] ctor(src: Int);
    fun[native("_ass_64_32z"), convert] ctor(src: UInt);
    fun[native("_ass_64_64"), convert] ctor(src: Long);
    fun[native("_ass_64_64")] ctor(src: ULong);
    fun[native("_ass_64_64"), convert] ctor(src: SizeType);
    fun[native("_ass_u64_f")] ctor(src: Float);
    fun[native("_ass_u64_d")] ctor(src: Double);
    fun dtor {}
}

class[native("float"), noDefault, rtct] Float
{
    fun ctor() { this = 0.0f; }
    fun ctor(other: Uninitialized) {}
    fun[native("_ass_f_i8"), convert] ctor(src: Byte);
    fun[native("_ass_f_u8"), convert] ctor(src: UByte);
    fun[native("_ass_f_i16"), convert] ctor(src: Short);
    fun[native("_ass_f_u16"), convert] ctor(src: UShort);
    fun[native("_ass_f_i32"), convert] ctor(src: Int);
    fun[native("_ass_f_u32"), convert] ctor(src: UInt);
    fun[native("_ass_f_i64"), convert] ctor(src: Long);
    fun[native("_ass_f_u64"), convert] ctor(src: ULong);
    fun[native("_ass_f_i64")] ctor(src: SizeType);
    fun[native("_ass_f_f")] ctor(src: Float);
    fun[native("_ass_f_d")] ctor(src: Double);
    fun dtor {}
}

class[native("double"), noDefault, rtct] Double
{
    fun ctor() { this = 0.0; }
    fun ctor(other: Uninitialized) {}
    fun[native("_ass_d_i8"), convert] ctor(src: Byte);
    fun[native("_ass_d_u8"), convert] ctor(src: UByte);
    fun[native("_ass_d_i16"), convert] ctor(src: Short);
    fun[native("_ass_d_u16"), convert] ctor(src: UShort);
    fun[native("_ass_d_i32"), convert] ctor(src: Int);
    fun[native("_ass_d_u32"), convert] ctor(src: UInt);
    fun[native("_ass_d_i64"), convert] ctor(src: Long);
    fun[native("_ass_d_u64"), convert] ctor(src: ULong);
    fun[native("_ass_d_i64")] ctor(src: SizeType);
    fun[native("_ass_d_f"), convert] ctor(src: Float);
    fun[native("_ass_d_d")] ctor(src: Double);
    fun dtor {}
}

class[native("i8"), noDefault, rtct] Char
{
    fun ctor() { this = Char(0); }
    fun ctor(other: Uninitialized) {}
    fun[native("_ass_8_8")] ctor(src: Char);
    fun[native("_ass_8_8")] ctor(src: Byte);
    fun[native("_ass_8_8")] ctor(src: UByte);
    fun[native("_ass_8_16")] ctor(src: Short);
    fun[native("_ass_8_16")] ctor(src: UShort);
    fun[native("_ass_8_32")] ctor(src: Int);
    fun[native("_ass_8_32")] ctor(src: UInt);
    fun[native("_ass_8_64")] ctor(src: Long);
    fun[native("_ass_8_64")] ctor(src: ULong);
    fun[native("_ass_8_64")] ctor(src: SizeType);
    fun dtor {}
}

class[native("u64"), noDefault, rtct] SizeType
{
    fun ctor() { this = 0; }
    fun ctor(other: Uninitialized) {}
    fun[native("_ass_64_8z"), convert] ctor(src: Byte);
    fun[native("_ass_64_8z"), convert] ctor(src: UByte);
    fun[native("_ass_64_16z"), convert] ctor(src: Short);
    fun[native("_ass_64_16z"), convert] ctor(src: UShort);
    fun[native("_ass_64_32z"), convert] ctor(src: Int);
    fun[native("_ass_64_32z"), convert] ctor(src: UInt);
    fun[native("_ass_64_64"), convert] ctor(src: Long);
    fun[native("_ass_64_64"), convert] ctor(src: ULong);
    fun[native("_ass_64_64")] ctor(src: SizeType);
    fun[native("_ass_u64_f")] ctor(src: Float);
    fun[native("_ass_u64_d")] ctor(src: Double);
    fun dtor {}
}

class[rtct, noDefault, native("StringRef")] StringRef
{
    var begin: @Byte;
    var end: @Byte;

    fun ctor()
    {
        begin := null;
        end := null;
    }
    fun ctor(other: Uninitialized) {}
    fun ctor(size: SizeType)
    {
        begin := malloc(size + intToSizeType(1));
        end := ptrAdd(begin, size);
        end = intToByte(0);
    }
    fun ctor(other: StringRef)
    {
        begin := other.begin;
        end := other.end;
    }
    fun dtor {}

    fun size(): SizeType
    {
        return ptrDiff(end, begin);
    }

    fun getChar(i: SizeType): Char
    {
        return reinterpretCast(@Char, ptrAdd(begin, i));
    }
}

fun[autoCt] = (dest: @StringRef, src: StringRef): @StringRef
{
    dest.begin := src.begin;
    dest.end := src.end;
}

fun + (x,y: StringRef): StringRef
{
    var sz1 = x.size();
    var sz2 = y.size();
    var res: StringRef = sz1 + sz2;
    memcpy(res.begin, x.begin, sz1);
    memcpy(ptrAdd(res.begin, sz1), y.begin, sz2);
    return res;
}

/*fun ctToRt(s: StringRef[ct]): StringRef
{
    var res: StringRef;
    res = s;
    return res;
}*/

fun[autoCt, native("_Bool_opAssign")] = (x: Bool@, y: Bool): Bool;
fun[autoCt, native("_Bool_opOr")] || (x, y: Bool): Bool;
fun[autoCt, native("_Bool_opXor")] ^^ (x, y: Bool): Bool;
fun[autoCt, native("_Bool_opAnd")] && (x, y: Bool): Bool;
fun[autoCt, native("_Bool_opEQ")] == (x, y: Bool): Bool;
fun[autoCt, native("_Bool_opNE")] != (x, y: Bool): Bool;
fun[autoCt, native("_Bool_opNeg")] ! (x: Bool): Bool;

fun[autoCt, native("_Byte_opAssign")] = (x: @Byte, y: Byte): Byte;
fun[autoCt, native("_Byte_opEQ")] == (x, y: Byte): Bool;
fun[autoCt, native("_Byte_opNE")] != (x, y: Byte): Bool;
fun[autoCt, native("_Byte_opLT")] < (x, y: Byte): Bool;
fun[autoCt, native("_Byte_opGT")] > (x, y: Byte): Bool;
fun[autoCt, native("_Byte_opLE")] <= (x, y: Byte): Bool;
fun[autoCt, native("_Byte_opGE")] >= (x, y: Byte): Bool;
fun[autoCt, native("_Byte_opPlus")] + (x, y: Byte): Byte;
fun[autoCt, native("_Byte_opMinus")] - (x, y: Byte): Byte;
fun[autoCt, native("_Byte_opMul")] * (x, y: Byte): Byte;
fun[autoCt, native("_Byte_opDiv")] / (x, y: Byte): Byte;
fun[autoCt, native("_Byte_opMod")] % (x, y: Byte): Byte;
fun[autoCt, native("_Byte_opPlus1")] + (x: Byte): Byte;
fun[autoCt, native("_Byte_opMinus1")] - (x: Byte): Byte;

fun[autoCt, native("_UByte_opAssign")] = (x: @UByte, y: UByte): UByte;
fun[autoCt, native("_UByte_opEQ")] == (x, y: UByte): Bool;
fun[autoCt, native("_UByte_opNE")] != (x, y: UByte): Bool;
fun[autoCt, native("_UByte_opLT")] < (x, y: UByte): Bool;
fun[autoCt, native("_UByte_opGT")] > (x, y: UByte): Bool;
fun[autoCt, native("_UByte_opLE")] <= (x, y: UByte): Bool;
fun[autoCt, native("_UByte_opGE")] >= (x, y: UByte): Bool;
fun[autoCt, native("_UByte_opPlus")] + (x, y: UByte): UByte;
fun[autoCt, native("_UByte_opMinus")] - (x, y: UByte): UByte;
fun[autoCt, native("_UByte_opMul")] * (x, y: UByte): UByte;
fun[autoCt, native("_UByte_opDiv")] / (x, y: UByte): UByte;
fun[autoCt, native("_UByte_opMod")] % (x, y: UByte): UByte;
fun[autoCt, native("_UByte_opPlus1")] + (x: UByte): UByte;

fun[autoCt, native("_Short_opAssign")] = (x: Short@, y: Short): Short;
fun[autoCt, native("_Short_opEQ")] == (x, y: Short): Bool;
fun[autoCt, native("_Short_opNE")] != (x, y: Short): Bool;
fun[autoCt, native("_Short_opLT")] < (x, y: Short): Bool;
fun[autoCt, native("_Short_opGT")] > (x, y: Short): Bool;
fun[autoCt, native("_Short_opLE")] <= (x, y: Short): Bool;
fun[autoCt, native("_Short_opGE")] >= (x, y: Short): Bool;
fun[autoCt, native("_Short_opPlus")] + (x, y: Short): Short;
fun[autoCt, native("_Short_opMinus")] - (x, y: Short): Short;
fun[autoCt, native("_Short_opMul")] * (x, y: Short): Short;
fun[autoCt, native("_Short_opDiv")] / (x, y: Short): Short;
fun[autoCt, native("_Short_opMod")] % (x, y: Short): Short;
fun[autoCt, native("_Short_opPlus1")] + (x: Short): Short;
fun[autoCt, native("_Short_opMinus1")] - (x: Short): Short;

fun[autoCt, native("_UShort_opAssign")] = (x: UShort@, y: UShort): UShort;
fun[autoCt, native("_UShort_opEQ")] == (x, y: UShort): Bool;
fun[autoCt, native("_UShort_opNE")] != (x, y: UShort): Bool;
fun[autoCt, native("_UShort_opLT")] < (x, y: UShort): Bool;
fun[autoCt, native("_UShort_opGT")] > (x, y: UShort): Bool;
fun[autoCt, native("_UShort_opLE")] <= (x, y: UShort): Bool;
fun[autoCt, native("_UShort_opGE")] >= (x, y: UShort): Bool;
fun[autoCt, native("_UShort_opPlus")] + (x, y: UShort): UShort;
fun[autoCt, native("_UShort_opMinus")] - (x, y: UShort): UShort;
fun[autoCt, native("_UShort_opMul")] * (x, y: UShort): UShort;
fun[autoCt, native("_UShort_opDiv")] / (x, y: UShort): UShort;
fun[autoCt, native("_UShort_opMod")] % (x, y: UShort): UShort;
fun[autoCt, native("_UShort_opPlus1")] + (x: UShort): UShort;

fun[autoCt, native("_Int_opAssign")] = (x: Int@, y: Int): Int;
fun[autoCt, native("_Int_opEQ")] == (x, y: Int): Bool;
fun[autoCt, native("_Int_opNE")] != (x, y: Int): Bool;
fun[autoCt, native("_Int_opLT")] < (x, y: Int): Bool;
fun[autoCt, native("_Int_opGT")] > (x, y: Int): Bool;
fun[autoCt, native("_Int_opLE")] <= (x, y: Int): Bool;
fun[autoCt, native("_Int_opGE")] >= (x, y: Int): Bool;
fun[autoCt, native("_Int_opPlus")] + (x, y: Int): Int;
fun[autoCt, native("_Int_opMinus")] - (x, y: Int): Int;
fun[autoCt, native("_Int_opMul")] * (x, y: Int): Int;
fun[autoCt, native("_Int_opDiv")] / (x, y: Int): Int;
fun[autoCt, native("_Int_opMod")] % (x, y: Int): Int;
fun[autoCt, native("_Int_opPlus1")] + (x: Int): Int;
fun[autoCt, native("_Int_opMinus1")] - (x: Int): Int;

fun[autoCt, native("_UInt_opAssign")] = (x: UInt@, y: UInt): UInt;
fun[autoCt, native("_UInt_opEQ")] == (x, y: UInt): Bool;
fun[autoCt, native("_UInt_opNE")] != (x, y: UInt): Bool;
fun[autoCt, native("_UInt_opLT")] < (x, y: UInt): Bool;
fun[autoCt, native("_UInt_opGT")] > (x, y: UInt): Bool;
fun[autoCt, native("_UInt_opLE")] <= (x, y: UInt): Bool;
fun[autoCt, native("_UInt_opGE")] >= (x, y: UInt): Bool;
fun[autoCt, native("_UInt_opPlus")] + (x, y: UInt): UInt;
fun[autoCt, native("_UInt_opMinus")] - (x, y: UInt): UInt;
fun[autoCt, native("_UInt_opMul")] * (x, y: UInt): UInt;
fun[autoCt, native("_UInt_opDiv")] / (x, y: UInt): UInt;
fun[autoCt, native("_UInt_opMod")] % (x, y: UInt): UInt;
fun[autoCt, native("_UInt_opPlus1")] + (x: UInt): UInt;

fun[autoCt, native("_Long_opAssign")] = (x: Long@, y: Long): Long;
fun[autoCt, native("_Long_opEQ")] == (x, y: Long): Bool;
fun[autoCt, native("_Long_opNE")] != (x, y: Long): Bool;
fun[autoCt, native("_Long_opLT")] < (x, y: Long): Bool;
fun[autoCt, native("_Long_opGT")] > (x, y: Long): Bool;
fun[autoCt, native("_Long_opLE")] <= (x, y: Long): Bool;
fun[autoCt, native("_Long_opGE")] >= (x, y: Long): Bool;
fun[autoCt, native("_Long_opPlus")] + (x, y: Long): Long;
fun[autoCt, native("_Long_opMinus")] - (x, y: Long): Long;
fun[autoCt, native("_Long_opMul")] * (x, y: Long): Long;
fun[autoCt, native("_Long_opDiv")] / (x, y: Long): Long;
fun[autoCt, native("_Long_opMod")] % (x, y: Long): Long;
fun[autoCt, native("_Long_opPlus1")] + (x: Long): Long;
fun[autoCt, native("_Long_opMinus1")] - (x: Long): Long;

fun[autoCt, native("_ULong_opAssign")] = (x: ULong@, y: ULong): ULong;
fun[autoCt, native("_ULong_opEQ")] == (x, y: ULong): Bool;
fun[autoCt, native("_ULong_opNE")] != (x, y: ULong): Bool;
fun[autoCt, native("_ULong_opLT")] < (x, y: ULong): Bool;
fun[autoCt, native("_ULong_opGT")] > (x, y: ULong): Bool;
fun[autoCt, native("_ULong_opLE")] <= (x, y: ULong): Bool;
fun[autoCt, native("_ULong_opGE")] >= (x, y: ULong): Bool;
fun[autoCt, native("_ULong_opPlus")] + (x, y: ULong): ULong;
fun[autoCt, native("_ULong_opMinus")] - (x, y: ULong): ULong;
fun[autoCt, native("_ULong_opMul")] * (x, y: ULong): ULong;
fun[autoCt, native("_ULong_opDiv")] / (x, y: ULong): ULong;
fun[autoCt, native("_ULong_opMod")] % (x, y: ULong): ULong;
fun[autoCt, native("_ULong_opPlus1")] + (x: ULong): ULong;

fun[autoCt, native("_Float_opAssign")] = (x: Float@, y: Float): Float;
fun[autoCt, native("_Float_opEQ")] == (x, y: Float): Bool;
fun[autoCt, native("_Float_opNE")] != (x, y: Float): Bool;
fun[autoCt, native("_Float_opLT")] < (x, y: Float): Bool;
fun[autoCt, native("_Float_opGT")] > (x, y: Float): Bool;
fun[autoCt, native("_Float_opLE")] <= (x, y: Float): Bool;
fun[autoCt, native("_Float_opGE")] >= (x, y: Float): Bool;
fun[autoCt, native("_Float_opPlus")] + (x, y: Float): Float;
fun[autoCt, native("_Float_opMinus")] - (x, y: Float): Float;
fun[autoCt, native("_Float_opMul")] * (x, y: Float): Float;
fun[autoCt, native("_Float_opDiv")] / (x, y: Float): Float;
fun[autoCt, native("_Float_opPlus1")] + (x: Float): Float;
fun[autoCt, native("_Float_opMinus1")] - (x: Float): Float;

fun[autoCt, native("_Double_opAssign")] = (x: Double@, y: Double): Double;
fun[autoCt, native("_Double_opEQ")] == (x, y: Double): Bool;
fun[autoCt, native("_Double_opNE")] != (x, y: Double): Bool;
fun[autoCt, native("_Double_opLT")] < (x, y: Double): Bool;
fun[autoCt, native("_Double_opGT")] > (x, y: Double): Bool;
fun[autoCt, native("_Double_opLE")] <= (x, y: Double): Bool;
fun[autoCt, native("_Double_opGE")] >= (x, y: Double): Bool;
fun[autoCt, native("_Double_opPlus")] + (x, y: Double): Double;
fun[autoCt, native("_Double_opMinus")] - (x, y: Double): Double;
fun[autoCt, native("_Double_opMul")] * (x, y: Double): Double;
fun[autoCt, native("_Double_opDiv")] / (x, y: Double): Double;
fun[autoCt, native("_Double_opPlus1")] + (x: Double): Double;
fun[autoCt, native("_Double_opMinus1")] - (x: Double): Double;

fun[autoCt, native("_Char_opAssign")] = (x: @Char, y: Char): Char;
fun[autoCt, native("_Char_opEQ")] == (x, y: Char): Bool;
fun[autoCt, native("_Char_opNE")] != (x, y: Char): Bool;
fun[autoCt, native("_Char_opLT")] < (x, y: Char): Bool;
fun[autoCt, native("_Char_opGT")] > (x, y: Char): Bool;
fun[autoCt, native("_Char_opLE")] <= (x, y: Char): Bool;
fun[autoCt, native("_Char_opGE")] >= (x, y: Char): Bool;

fun[autoCt, native("_SizeType_opAssign")] = (x: SizeType@, y: SizeType): SizeType;
fun[autoCt, native("_SizeType_opEQ")] == (x, y: SizeType): Bool;
fun[autoCt, native("_SizeType_opNE")] != (x, y: SizeType): Bool;
fun[autoCt, native("_SizeType_opLT")] < (x, y: SizeType): Bool;
fun[autoCt, native("_SizeType_opGT")] > (x, y: SizeType): Bool;
fun[autoCt, native("_SizeType_opLE")] <= (x, y: SizeType): Bool;
fun[autoCt, native("_SizeType_opGE")] >= (x, y: SizeType): Bool;
fun[autoCt, native("_SizeType_opPlus")] + (x, y: SizeType): SizeType;
fun[autoCt, native("_SizeType_opMinus")] - (x, y: SizeType): SizeType;
fun[autoCt, native("_SizeType_opMul")] * (x, y: SizeType): SizeType;
fun[autoCt, native("_SizeType_opDiv")] / (x, y: SizeType): SizeType;
fun[autoCt, native("_SizeType_opMod")] % (x, y: SizeType): SizeType;
fun[autoCt, native("_SizeType_opPlus1")] + (x: SizeType): SizeType;

fun[ct, native("$ct")] ct(t: Type): Type;
fun[ct, native("$rt")] rt(t: Type): Type;

fun[autoCt, native("_opRefEQ")] _opRefEQ(x,y: @Byte): Bool;
fun[autoCt, native("_opRefNE")] _opRefNE(x,y: @Byte): Bool;


fun[ct, native("$typeEQ")] == (x, y: Type): Bool;
fun[ct, native("$typeAddRef")] @ (t: Type): Type;



fun[native("writeLnByte")] writeLn(x: Byte);
fun[native("writeLnByte")] writeLn(x: UByte);
fun[native("writeLnShort")] writeLn(x: Short);
fun[native("writeLnShort")] writeLn(x: UShort);
fun[native("writeLnInt")] writeLn(x: Int);
fun[native("writeLnUInt")] writeLn(x: UInt);
fun[native("writeLnSizeType")] writeLn(x: Long);
fun[native("writeLnSizeType")] writeLn(x: ULong);
fun[native("writeLnFloat")] writeLn(x: Float);
fun[native("writeLnDouble")] writeLn(x: Double);
fun[native("writeLnChar")] writeLn(x: Char);
fun[native("writeLnSizeType")] writeLn(x: SizeType);

fun[native("writeByte")] write(x: Byte);
fun[native("writeByte")] write(x: UByte);
fun[native("writeShort")] write(x: Short);
fun[native("writeShort")] write(x: UShort);
fun[native("writeInt")] write(x: Int);
fun[native("writeUInt")] write(x: UInt);
fun[native("writeLong")] write(x: Long);
fun[native("writeULong")] write(x: ULong);
fun[native("writeFloat")] write(x: Float);
fun[native("writeDouble")] write(x: Double);
fun[native("writeChar")] write(x: Char);
fun[native("writeSizeType")] write(x: SizeType);

fun writeLn(x: StringRef) { writeLnStringImpl(reinterpretCast(@Char, x.begin)); }
fun write(x: StringRef) { writeStringImpl(reinterpretCast(@Char, x.begin)); }
fun[native("writeLnStringImpl")] writeLnStringImpl(x: @Char);
fun[native("writeStringImpl")] writeStringImpl(x: @Char);

fun[native("writeLnPointer")] writeLnRef(x: @Byte);
fun[native("writePointer")] writeRef(x: @Byte);

fun[native("writeLnInt"), rt] writeLnInt(x: Int);
fun[native("writeLnDouble"), rt] writeLnDouble(x: Double);

fun[native("intToSizeType"), autoCt] intToSizeType(n: Int): SizeType;
fun[native("intToByte"), autoCt] intToByte(n: Int): Byte;


fun[native("mulInt"), autoCt] mul(x,y: Int): Int;
fun[native("mulDouble"), autoCt] mul(x,y: Double): Double;
fun[native("divInt"), autoCt] div(x,y: Int): Int;
fun[native("modInt"), autoCt] mod(x,y: Int): Int;
fun[native("addInt"), autoCt] add(x,y: Int): Int;
fun[native("subInt"), autoCt] sub(x,y: Int): Int;
fun[native("addDouble"), autoCt] add(x,y: Double): Double;
fun[native("subDouble"), autoCt] sub(x,y: Double): Double;
fun[native("equalInt"), autoCt] equal(x,y: Int): Bool;
fun[native("leInt"), autoCt] le(x,y: Int): Bool;
fun[native("assignInt"), autoCt] assignInt(x: Int@, y: Int);
fun[native("assignRefByte"), autoCt] assignRef(x: (@Byte)@, y: @Byte);

fun[native("llvm.pow.f64"), rt] mathPow(x,y: Double): Double;

fun[native("malloc"), rtct] malloc(size: SizeType): @Byte;
fun[native("malloc")] mallocRt(size: SizeType): @Byte;
fun[native("realloc"), rtct] realloc(p: @Byte, size: SizeType): @Byte;
fun[native("free"), rtct] free(p: @Byte);
fun[native("ptrAdd"), autoCt] ptrAdd(p: @Byte, n: SizeType): @Byte;
fun[native("ptrSub"), autoCt] ptrSub(p: @Byte, n: SizeType): @Byte;
fun[native("ptrDiff"), autoCt] ptrDiff(p1, p2: @Byte): SizeType;
fun[native("memcpyimpl"), autoCt] memcpy(dest, src: @Byte, size: SizeType);
fun[native("flushOutput")] flushOutput();

fun[ct, native("$typeNumRef")] typeNumRef(t: Type): Int;

fun cast();
fun reinterpretCast();
fun[ct] sizeOf(): SizeType;
fun[ct] typeOf(): Type;
fun[ct] isValid(): Bool;

fun[ct, native("$convertsTo")] convertsTo(src, dest: Type): Bool;
fun[ct, native("$staticBuffer")] static_buffer(n: SizeType): Type;
fun[ct, native("$commonType")] commonType(t, u: Type): Type;

using oper_precedence_default   = 100;
using oper_precedence___dot__   = 10000;
using oper_precedence___fapp__  = 10000;
using oper_precedence___pre__   = 990;

using oper_precedence_=     = 50;
using oper_precedence_:=    = 50;
using oper_precedence_+=    = 50;
using oper_precedence_-=    = 50;
using oper_precedence_*=    = 50;
using oper_precedence_/=    = 50;
using oper_precedence_%=    = 50;

using oper_precedence_||    = 200;
using oper_precedence_^^    = 220;
using oper_precedence_&&    = 240;

using oper_precedence_<     = 300;
using oper_precedence_>     = 300;
using oper_precedence_<=    = 300;
using oper_precedence_>=    = 300;

using oper_precedence_==    = 400;
using oper_precedence_!=    = 400;
using oper_precedence_===   = 400;
using oper_precedence_!==   = 400;

using oper_precedence_+     = 500;
using oper_precedence_-     = 500;
using oper_precedence_*     = 550;
using oper_precedence_/     = 550;
using oper_precedence_%     = 550;

using oper_precedence_<<    = 50;
using oper_precedence_<<<   = 50;
using oper_precedence_>>    = 50;

using oper_assoc_=          = -1;
using oper_assoc_:=         = -1;

