//!! -t "SparrowImplicitLib.spr" --dump-assembly

concept AnyType(x);

fun writeLnBool(val: Bool) {
    if ( val )
        writeLn("true");
    else
        writeLn("false");
}

class Pair(t: Type) { var first, second: t; }

datatype Pair2(t:Type) { first, second: t }
datatype Pair3(t:Type) = Pair(t);

// Proper constructor, taking both the generic and the non-generic parameters
fun Pair(t: Type, first, second: AnyType): Pair(t) {
    var res: Pair(t) = Uninitialized();
    construct(res.first, first);
    construct(res.second, second);
    return res;
}

// Generic parameter is deduced from a non-generic parameter
fun Pair(first, second: AnyType): Pair(typeOf(first)) {
    var res: Pair(typeOf(first)) = Uninitialized();
    construct(res.first, first);
    construct(res.second, second);
    return res;
}

fun Pair2(first, second: AnyType): Pair2(typeOf(first)) {
    var res: Pair2(typeOf(first)) = Uninitialized();
    res.first construct first;
    res.second construct second;
    return res;
}

fun Pair3(first, second: AnyType): Pair3(typeOf(first)) {
    var res: Pair3(typeOf(first)) = Uninitialized();
    res._data.first construct first;
    res._data.second construct second;
    return res;
}

fun[native("test")] test(n: Int)
{
    var pi = Pair(Int, 1, 2);
    writeLn(pi.first);
    writeLn(pi.second);
    writeLn("---");
    var pd = Pair(Double, 1.1, 2.2);
    writeLn(pd.first);
    writeLn(pd.second);
    writeLn("---");
    var pb = Pair(false, true);
    writeLnBool(pb.first);
    writeLnBool(pb.second);

    writeLn("---");
    var p2 = Pair2(1, 2);
    var p3 = Pair3(3, 4);
    writeLn(p2.second);
    writeLn(p3._data.second);
}

/*<<<Running()
1
2
---
1.1
2.2
---
false
true
---
2
4
>>>*/
