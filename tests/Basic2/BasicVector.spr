//!!

import std.ranges;

fun assert(condition: Bool)
{
    if ( !condition )
        cout << "Assertion failure!" << endl;
}

class ContinousMemoryRange(type: Type)
{
    using RetType = @type;
    [static] var ValueType = type;

    var begin, end: @ValueType;

    fun ctor()
    {
        assert(this.size() == SizeType(0));
    }

    fun ctor(begin,end: @ValueType)
    {
        this.begin := begin;
        this.end := end;
    }

    fun ctor(other: ContinousMemoryRange)
    {
        begin := other.begin;
        end := other.end;
    }

    fun swap(other: @ContinousMemoryRange)
    {
        var tmp: @AnyType = begin;
        begin := other.begin;
        other.begin := tmp;
        tmp := end;
        end := other.end;
        other.end := tmp;
    }

    fun isEmpty(): Bool
    {
        return begin === end;
    }

    fun size(): SizeType
    {
        return ptrDiff(toPtr(end), toPtr(begin)) / sizeOf(ValueType);
    }

    fun popFront()
    {
        begin := inc(begin);
    }

    fun popBack()
    {
        end := dec(end);
    }

    fun popFront(n: SizeType)
    {
        begin := inc(begin, n);
    }

    fun popBack(n: SizeType)
    {
        end := dec(end, n);
    }

    fun popFront(n: Int)
    {
        begin := inc(begin, SizeType(n));
    }

    fun popBack(n: Int)
    {
        end := dec(end, SizeType(n));
    }

    fun front(): @ValueType
    {
        return begin;
    }

    fun back(): @ValueType
    {
        return dec(end);
    }

    fun peekFront(n: SizeType): @ValueType
    {
        return inc(begin, n);
    }

    fun peekBack(n: SizeType): @ValueType
    {
        return dec(end, n+SizeType(1));
    }


    [static] fun toPtr(p: @ValueType): @Byte
    {
        return reinterpretCast(@Byte, p);
    }
    [static] fun toValue(p: @Byte): @ValueType
    {
        return reinterpretCast(@ValueType, p);
    }

    [static] fun inc(p: @ValueType): @ValueType
    {
        return toValue(ptrAdd(toPtr(p), sizeOf(ValueType)));
    }
    [static] fun inc(p: @ValueType, n: SizeType): @ValueType
    {
        return toValue(ptrAdd(toPtr(p), n*sizeOf(ValueType)));
    }
    [static] fun dec(p: @ValueType): @ValueType
    {
        return toValue(ptrSub(toPtr(p), sizeOf(ValueType)));
    }
    [static] fun dec(p: @ValueType, n: SizeType): @ValueType
    {
        return toValue(ptrSub(toPtr(p), n*sizeOf(ValueType)));
    }
}


class Vector(type: Type)
{
    [static] var ValueType = type;

    var begin, end, endOfStore: @ValueType;

    [static, ct] var initialCapacity: SizeType = SizeType(16);
    [static, ct] var growthFactor = 1.5;

    fun ctor()
    {
        assert(this.size() == SizeType(0));
    }

    fun ctor(other: @Vector)
    {
        var size = other.size();

        begin := toValue(malloc(size*sizeOf(ValueType)));
        end := inc(begin, size);
        endOfStore := end;

        var dst: @AnyType = begin;
        var src: @AnyType = other.begin;

        while dst !== end
        {
            dst = src;
            // TODO: Call ctor here
            dst := inc(dst);
            src := inc(src);
        }
        assert(this.size() == other.size());
    }

    fun ctor(r: ContinousMemoryRange(ValueType))
    {
        begin := null;
        end := null;
        endOfStore := null;
        this.reserve(r.size());
        while !r.isEmpty() ; r.popFront();
        {
            this.pushBack(r.front());
        }
    }

    // TODO: ctor from range (with or without reserve)

    fun dtor
    {
        var p: @AnyType = begin;

        // TODO: call dtor on an object
        //while p !== end ; p := inc(p);
        //    p.dtor();
        free(toPtr(begin));
    }


    fun size(): SizeType
    {
        return diff(end, begin);
    }

    fun isEmpty(): Bool
    {
        return begin === end;
    }

    fun capacity(): SizeType
    {
        return diff(endOfStore, begin);
    }

    fun reserve(n: SizeType)
    {
        var curCapacity: SizeType = this.capacity();

        if ( n <= curCapacity )
            return;

        if ( n < initialCapacity )
            n = initialCapacity;
        //if ( n < SizeType(growthFactor * curCapacity) )
        //    n = SizeType(growthFactor * curCapacity);
        // TODO: Type casts between Double and SizeType
        if ( n < curCapacity+curCapacity )
            n = curCapacity+curCapacity;

        var curSize = this.size();
        // TODO: Call methods with this parameter

        var src: @AnyType = begin;

        begin := toValue(malloc(n*sizeOf(ValueType)));
        end := inc(begin, curSize);
        endOfStore := inc(begin, n);
        var dst: @AnyType = begin;

        // TODO: Call ctors/dtors when reallocating
        while dst !== end
        {
            dst = src;
            // TODO: Call ctor here
            dst := inc(dst);
            src := inc(src);
        }
        //this.debugDumpThis("After malloc");

        assert(this.capacity() >= n);
    }

    // TODO: swap function

    fun at(index: SizeType): @ValueType
    {
        assert(index < this.size());
        return inc(begin, index);
    }
    fun at(index: Int): @ValueType
    {
        return this.at(SizeType(index));
    }

    fun front(): @ValueType
    {
        assert(!this.isEmpty());
        return begin;
    }

    fun back(): @ValueType
    {
        assert(!this.isEmpty());
        return dec(end);
    }

    fun all(): ContinousMemoryRange(ValueType)
    {
        return ContinousMemoryRange(ValueType)(begin, end);
    }

    fun subrange(index: SizeType, num: SizeType): ContinousMemoryRange(ValueType)
    {
        return ContinousMemoryRange(ValueType)(inc(begin, index), inc(begin, index + num));
    }
    fun subrange(index: Int, num: Int): ContinousMemoryRange(ValueType)
    {
        return this.subrange(SizeType(index), SizeType(num));
    }

    fun insertBefore(value: @ValueType, pos: ContinousMemoryRange(ValueType))
    {
        var posCount = diff(pos.front(), begin);
        this.reserve(this.size() + SizeType(1));

        var p: @AnyType = inc(begin, posCount);

        // TODO: Call ctors/dtors
        move(p, end, inc(begin, posCount+SizeType(1)));
        p = value;
        end := inc(end);
    }
    fun insertBefore(range: ContinousMemoryRange(ValueType), pos: ContinousMemoryRange(ValueType))
    {
        var n = range.size();
        var index = diff(pos.front(), begin);

        this.reserve(this.size() + n);

        var p: @AnyType = inc(begin, index);

        move(p, end, inc(begin, index + n));
        while p !== inc(begin, index + n) ; p := inc(p);
        {
            p = range.front();
            range.popFront();
        }
        end := inc(end, n);
    }

    fun insertAfter(value: @ValueType, pos: ContinousMemoryRange(ValueType))
    {
        var posCount = SizeType(1) + diff(pos.back(), begin);

        this.reserve(this.size() + SizeType(1));

        var p: @AnyType = inc(begin, posCount);

        move(p, end, inc(begin, posCount + SizeType(1)));
        p = value;
        end := inc(end);
    }
    fun insertAfter(range: ContinousMemoryRange(ValueType), pos: ContinousMemoryRange(ValueType))
    {
        var n = range.size();
        var index = SizeType(1) + diff(pos.back(), begin);

        this.reserve(this.size() + n);

        var p: @AnyType = inc(begin, index);

        move(p, end, inc(begin, index + n));
        while p !== inc(begin, index + n) ; p := inc(p);
        {
            p = range.front();
            range.popFront();
        }
        end := inc(end, n);
    }

    fun pushBack(value: @ValueType)
    {
        if ( end === endOfStore )
        {
            var c = this.capacity();
            c += c;
            if ( c < initialCapacity )
                c = initialCapacity;
            this.reserve(c);
        }

        //end.@ctor(value);
        // TODO: ctor copy
        end = value;
        end := inc(end);

        //assert(this.back() == value);
    }

    fun popBack()
    {
        end := dec(end);
        //end.@dtor();
        // TODO: call dtor
    }

    fun remove(range: ContinousMemoryRange(ValueType))
    {
        var rSize = range.size();
        var rBegin: @ValueType = range.front();
        var rEnd: @AnyType = inc(rBegin, rSize);

        while rEnd !== end
        {
            rBegin = rEnd;
            rBegin := inc(rBegin);
            rEnd := inc(rEnd);
        }
        end := rBegin;
    }
    fun remove(index: SizeType)
    {
        var r = this.all();

        r.popFront(index);
        r.popBack(this.size() - index - SizeType(1));
        this.remove(r);
    }

    fun resize(n: SizeType)
    {
        var oldSize = this.size();

        if ( n == oldSize )
            return;

        if ( n < oldSize )
        {
            var newEnd: @AnyType = inc(begin, n);

            while end !== newEnd
            {
                end := dec(end);
                //end.@dtor();
                // TODO: call dtor
            }
        }
        else
        {
            this.reserve(n);
            var newEnd: @AnyType = inc(begin, n);
            while end !== newEnd
            {
                //end.@ctor();
                // TODO: call default ctor inplace
                end := inc(end);
            }
        }

        assert(this.size() == n);
    }
    fun resize(n: Int)
    {
        this.resize(SizeType(n));
    }

    fun assign(r: ContinousMemoryRange(ValueType))
    {
        this.clear();
        this.reserve(r.size());
        while !r.isEmpty() ; r.popFront()
        {
            this.pushBack(r.front());
        }
    }

    fun clear()
    {
        end := begin;
        // TODO
        //remove(RangeType(begin, end));

        assert(this.isEmpty());
    }

    fun swap(other: @Vector)
    {
        var tmp: @AnyType = begin;
        begin := other.begin;
        other.begin := tmp;
        tmp := end;
        end := other.end;
        other.end := tmp;
        tmp := endOfStore;
        endOfStore := other.endOfStore;
        other.endOfStore := tmp;
    }


    fun debugDumpThis(desc: StringRef)
    {
        cout << "<<<" << endl;
        cout << "  " << desc << ": " << endl;
        cout << "  Begin: " << mkStreamRefWrapper(begin) << endl;
        cout << "  End: " << mkStreamRefWrapper(end) << endl;
        cout << "  End-of-store: " << mkStreamRefWrapper(endOfStore) << endl;
        cout << "  Size-of-elem: " << sizeOf(ValueType) << endl;
        cout << "  Size: " << this.size() << endl;
        cout << "  Capacity: " << this.capacity() << endl;
        cout << ">>>" << endl;
        cout << flush;
    }

    [static] fun toPtr(p: @ValueType): @Byte
    {
        return reinterpretCast(@Byte, p);
    }
    [static] fun toValue(p: @Byte): @ValueType
    {
        return reinterpretCast(@ValueType, p);
    }

    [static] fun inc(p: @ValueType): @ValueType
    {
        return toValue(ptrAdd(toPtr(p), sizeOf(ValueType)));
    }
    [static] fun inc(p: @ValueType, n: SizeType): @ValueType
    {
        return toValue(ptrAdd(toPtr(p), n*sizeOf(ValueType)));
    }
    [static] fun dec(p: @ValueType): @ValueType
    {
        return toValue(ptrSub(toPtr(p), sizeOf(ValueType)));
    }
    [static] fun dec(p: @ValueType, n: SizeType): @ValueType
    {
        return toValue(ptrSub(toPtr(p), n*sizeOf(ValueType)));
    }
    [static] fun diff(p,q: @ValueType): SizeType
    {
        return ptrDiff(toPtr(p), toPtr(q)) / sizeOf(ValueType);
    }
    [static] fun move(pBegin, pEnd, destBegin: @ValueType)
    {
        var size = diff(pEnd, pBegin);
        var destEnd: @AnyType = inc(destBegin, size);

        while pEnd !== pBegin
        {
            destEnd := dec(destEnd);
            pEnd := dec(pEnd);
            destEnd = pEnd;
        }
    }
}


fun createRange(t: Type, n: Int): ContinousMemoryRange(t)
{
    var sizeToAlloc = SizeType(n) * sizeOf(t);
    var begin,end: @Byte;
    begin := malloc(sizeToAlloc);
    end := ptrAdd(begin, sizeToAlloc);
    var res = ContinousMemoryRange(t)(reinterpretCast(@t, begin), reinterpretCast(@t, end));
    var i = 0;
    while i<n ; i++
    {
        res.peekFront(SizeType(i)) = i;
    }
    return res;
}

class MyObj
{
    fun ctor(xx: Int) { x = xx; cout << "ctor(" << x << ')' << endl; }
    fun ctor(other: @MyObj) { x = other.x; cout << "copy ctor(MyObj(" << x << "))" << endl; }
    fun dtor { cout << "dtor(" << x << ')' << endl; }

    var x: Int;
}

fun = (dest: @MyObj, src: MyObj)
{
    cout << "copy MyObj(" << src.x << ")" << endl;
    dest.x = src.x;
}

fun = (dest: @MyObj, src: Int)
{
    //cout << "copy MyObj(" << src << ")" << endl;
    dest.x = src;
}

fun write1(obj: MyObj)
{
    cout << "MyObj(" << obj.x << ")";
}


// Prints the elements in the vector on one line.
fun printVector(v: AnyType)
{
    var isFirst = true;
    for v = v.all
    {
        if ( isFirst )
            isFirst = false;
        else
            cout << ", ";

        cout << v;
    }
    if ( !v.isEmpty() )
        cout << endl;

    /*var i = SizeType(0);

    while i < v.size() ; i = i + SizeType(1);
    {
        cout << v.at(i);
        if ( i < v.size() - SizeType(1) )
        {
            cout << ", ";
        }
        else
        {
            cout << endl;
        }
    }*/
}

fun printRange(r: AnyType)
{
    var isFirst = true;
    for v = r
    {
        if ( isFirst )
            isFirst = false;
        else
            cout << ", ";

        cout << v;
    }
    cout << endl;
    /*while !r.isEmpty() ; r.popFront()
    {
        cout << r.front();
        if ( r.size() > SizeType(1) )
        {
            cout << ", ";
        }
        else
        {
            cout << endl;
        }
    }*/
}

// Prints whether the vector is empty or not, the vector's size and its capacity,
// each on a different line.
fun printSizeInfo(v: AnyType) if isValid(v.isEmpty()) && isValid(v.size())
{
    if v.isEmpty
        cout << "empty" << endl
    else cout << "not empty" << endl
    cout << v.size << endl;
}



fun sprMain
{
    if ( programArgs.size() < 2 )
        return;
    var n = programArgs(1) asInt;

    if      n == 1  ; test1
    else if n == 2  ; test2
    else if n == 3  ; test3
    else if n == 4  ; test4
    else if n == 5  ; test5
    else if n == 6  ; test6
    else if n == 7  ; test7
    else if n == 8  ; test8
    else if n == 9  ; test9
    else if n == 10 ; test10
    else if n == 11 ; test11
    else if n == 12 ; test12
    else if n == 13 ; test13
    else if n == 14 ; test14
    else if n == 15 ; test15
    else if n == 16 ; test16
    else if n == 17 ; test17
    else if n == 18 ; test18
    else if n == 19 ; test19
    else if n == 20 ; test20
    else if n == 21 ; test21
}

fun test1()
{
    var v: Vector(Int);
    cout << v.size() << endl;
    v.pushBack(10);
    v.pushBack(20);
    //v.debugDumpThis("After pushBack");
    cout << v.size() << endl;
    cout << v.at(SizeType(0)) << endl;
    cout << v.at(SizeType(1)) << endl;
    cout << "---" << endl;
    printSizeInfo(v);
    printVector(v);
    cout << "---" << endl;
    v.popBack();
    printSizeInfo(v);
    printVector(v);
    cout << "---" << endl;
    v.popBack();
    printSizeInfo(v);
    printVector(v);
}
/*<<<Basic test(1)
0
2
10
20
---
not empty
2
10, 20
---
not empty
1
10
---
empty
0
>>>*/

fun test2()
{
    var r = createRange(Int, 10);
    cout << r.size() << endl;
    printRange(r);
}
/*<<<Range test(2)
10
0, 1, 2, 3, 4, 5, 6, 7, 8, 9
>>>*/

fun test3()
{
    var v: Vector(Int) = createRange(Int, 4);

    printSizeInfo(v);
    printVector(v);
    v.popBack();
    printSizeInfo(v);
    printVector(v);
    v.pushBack(42);
    printSizeInfo(v);
    printVector(v);
}
/*<<<Range constructor(3)
not empty
4
0, 1, 2, 3
not empty
3
0, 1, 2
not empty
4
0, 1, 2, 42
>>>*/

fun test4()
{
    var v1: Vector(Int);
    var v2: Vector(Int) = createRange(Int, 4);
    var v3: Vector(Int) = v1;
    var v4 = v2;

    printSizeInfo(v3);
    printSizeInfo(v4);
    printVector(v4);
}
/*<<<Copy constructor(4)
empty
0
not empty
4
0, 1, 2, 3
>>>*/

fun test5()
{
    cout << "start" << endl;
    {
        var v: Vector(MyObj);
        v.pushBack(MyObj(1));
        v.pushBack(MyObj(2));
        cout << "prepare to exit..." << endl;
    }
    cout << "done" << endl;
}
/*---<<<Destructor(5)
start
ctor(1)
copy MyObj(1)
dtor(1)
ctor(2)
copy MyObj(2)
dtor(2)
prepare to exit...
dtor(1)
dtor(2)
done
>>>*/

fun test6()
{
    var v1: Vector(Int);

    v1.reserve(SizeType(42));
    printSizeInfo(v1);
    cout << v1.capacity() << endl;

    var v2: Vector(Int) = createRange(Int, 4);

    v2.reserve(SizeType(100));
    printSizeInfo(v2);
    cout << v2.capacity() << endl;
    printVector(v2);
    v2.reserve(SizeType(10));
    printSizeInfo(v2);
    cout << v2.capacity() << endl;
    printVector(v2);

    var v3: Vector(Int) = createRange(Int, 1024);

    if v3.capacity() < SizeType(1024)
        cout << "Test failed" << endl
    v3 pushBack 0
    if v3.capacity() < SizeType(1024)
        cout << "Test failed" << endl
}
/*<<<Reserve(6)
empty
0
42
not empty
4
100
0, 1, 2, 3
not empty
4
100
0, 1, 2, 3
>>>*/

fun test7()
{
    var v1: Vector(Int);
    var v2: Vector(Int) = createRange(Int, 8);

    v1.assign(createRange(Int, 5));
    printSizeInfo(v1);
    printVector(v1);
    v2.assign(createRange(Int, 4));
    printSizeInfo(v2);
    printVector(v2);
}
/*<<<Range assignment(7)
not empty
5
0, 1, 2, 3, 4
not empty
4
0, 1, 2, 3
>>>*/

fun test8()
{
    var v1: Vector(Int);
    var v2: Vector(Int) = createRange(Int, 4);

    v1.swap(v2);
    printSizeInfo(v1);
    printVector(v1);
    printSizeInfo(v2);
    v1.swap(v1);
    printSizeInfo(v1);
    printVector(v1);
}
/*<<<Swapping(8)
not empty
4
0, 1, 2, 3
empty
0
not empty
4
0, 1, 2, 3
>>>*/

fun test9()
{
    var v: Vector(Int) = createRange(Int, 8);

    v.at(SizeType(1)) = 111;
    v.at(SizeType(5)) = 555;
    printVector(v);
    v.front() = 42;
    v.back() = 84;
    printVector(v);
}
/*<<<Element access(9)
0, 111, 2, 3, 4, 555, 6, 7
42, 111, 2, 3, 4, 555, 6, 84
>>>*/

fun test10()
{
    var v: Vector(Int);

    v.pushBack(3);
    v.pushBack(2);
    v.pushBack(1);
    v.pushBack(0);

    var r = v.all();

    while !r.isEmpty() ; r.popFront()
    {
        cout << r.front() << endl;
    }

    r = ContinousMemoryRange(Int)(v.all());
    while !r.isEmpty() ; r.popFront()
    {
        r.front() = r.front() + 1;
    }
    printSizeInfo(v);
    printVector(v);
}
/*<<<Range access(10)
3
2
1
0
not empty
4
4, 3, 2, 1
>>>*/

fun test11()
{
    var v: Vector(Int);
    var i = 0;

    while i < 4 ; i++
    {
        v.pushBack(i);
    }
    printSizeInfo(v);
    printVector(v);
    v.popBack();
    v.popBack();
    printSizeInfo(v);
    printVector(v);
    v.popBack();
    v.popBack();
    printSizeInfo(v);
    v.pushBack(42);
    v.pushBack(43);
    printSizeInfo(v);
    printVector(v);
    v.popBack();
    v.popBack();
    i = 0;
    while i < 20 ; i=i+1
    {
        v.pushBack(i);
    }
    printSizeInfo(v);
    printVector(v);
}
/*<<<Pushing & popping(11)
not empty
4
0, 1, 2, 3
not empty
2
0, 1
empty
0
not empty
2
42, 43
not empty
20
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19
>>>*/

fun test12()
{
    var v: Vector(Int) = createRange(Int, 4);

    v.resize(4);
    printSizeInfo(v);
    printVector(v);
    v.resize(2);
    printSizeInfo(v);
    printVector(v);
    v.resize(6);
    printSizeInfo(v);
    //printVector(v);

    var vv: Vector(Int);

    vv.resize(6);
    printSizeInfo(vv);
    //printVector(vv);
}
/*<<<Resizing(12)
not empty
4
0, 1, 2, 3
not empty
2
0, 1
not empty
6
not empty
6
>>>*/

fun test13()
{
    var v: Vector(Int) = createRange(Int, 4);

    v.clear();
    printSizeInfo(v);
    v.pushBack(42);
    v.pushBack(43);
    printSizeInfo(v);
    printVector(v);
    v.clear();
    printSizeInfo(v);

    var vv: Vector(Int);
    vv.clear();
    printSizeInfo(v);
}
/*<<<Clear(13)
empty
0
not empty
2
42, 43
empty
0
empty
0
>>>*/

fun test14()
{
    //var v1: Vector(Int) = createRange(Int, 4);
    //var v2: Vector(Int) = createRange(Int, 6);
    //var v3: Vector(Int);

    //v2 = v1;
    //printSizeInfo(v2);
    //printVector(v2);
    //printSizeInfo(v1 = v2 = v3);
}
/*---<<<Assignment operator(14)
not empty
4
0 1 2 3
empty
0
>>>*/

fun test15()
{
    var v: Vector(Int) = createRange(Int, 4);
    var r = v.all();

    v.insertBefore(42, v.all());
    printSizeInfo(v);
    printVector(v);
    v.insertAfter(43, v.all());
    printSizeInfo(v);
    printVector(v);
    r = v.all();
    r.popFront();
    r.popFront();
    v.insertBefore(11, r);
    printSizeInfo(v);
    printVector(v);
    r = v.all();
    r.popBack();
    r.popBack();
    v.insertAfter(22, r);
    printSizeInfo(v);
    printVector(v);
}
/*<<<Element insertions(15)
not empty
5
42, 0, 1, 2, 3
not empty
6
42, 0, 1, 2, 3, 43
not empty
7
42, 0, 11, 1, 2, 3, 43
not empty
8
42, 0, 11, 1, 2, 22, 3, 43
>>>*/

fun test16()
{
    var v: Vector(Int) = createRange(Int, 4);
    var r = v.all();

    v.insertBefore(createRange(Int, 2), v.all());
    printSizeInfo(v);
    printVector(v);
    v.insertAfter(createRange(Int, 2), v.all());
    printSizeInfo(v);
    printVector(v);
    v.insertBefore(createRange(Int, 1), v.all());
    printSizeInfo(v);
    printVector(v);
    v.insertAfter(createRange(Int, 1), v.all());
    printSizeInfo(v);
    printVector(v);
    v.insertBefore(createRange(Int, 0), v.all());
    printSizeInfo(v);
    printVector(v);
    v.insertAfter(createRange(Int, 0), v.all());
    printSizeInfo(v);
    printVector(v);
    r = v.all();
    r.popFront();
    r.popFront();
    v.insertBefore(createRange(Int, 2), r);
    printSizeInfo(v);
    printVector(v);
    r = v.all();
    r.popBack();
    r.popBack();
    v.insertAfter(createRange(Int, 2), r);
    printSizeInfo(v);
    printVector(v);
    r = v.all();
    r.popFront();
    r.popFront();
    v.insertBefore(createRange(Int, 1), r);
    printSizeInfo(v);
    printVector(v);
    r = v.all();
    r.popBack();
    r.popBack();
    v.insertAfter(createRange(Int, 1), r);
    printSizeInfo(v);
    printVector(v);
    r = v.all();
    r.popFront();
    r.popFront();
    v.insertBefore(createRange(Int, 0), r);
    printSizeInfo(v);
    printVector(v);
    r = v.all();
    r.popBack();
    r.popBack();
    v.insertAfter(createRange(Int, 0), r);
    printSizeInfo(v);
    printVector(v);
}
/*<<<Range insertions(16)
not empty
6
0, 1, 0, 1, 2, 3
not empty
8
0, 1, 0, 1, 2, 3, 0, 1
not empty
9
0, 0, 1, 0, 1, 2, 3, 0, 1
not empty
10
0, 0, 1, 0, 1, 2, 3, 0, 1, 0
not empty
10
0, 0, 1, 0, 1, 2, 3, 0, 1, 0
not empty
10
0, 0, 1, 0, 1, 2, 3, 0, 1, 0
not empty
12
0, 0, 0, 1, 1, 0, 1, 2, 3, 0, 1, 0
not empty
14
0, 0, 0, 1, 1, 0, 1, 2, 3, 0, 0, 1, 1, 0
not empty
15
0, 0, 0, 0, 1, 1, 0, 1, 2, 3, 0, 0, 1, 1, 0
not empty
16
0, 0, 0, 0, 1, 1, 0, 1, 2, 3, 0, 0, 1, 0, 1, 0
not empty
16
0, 0, 0, 0, 1, 1, 0, 1, 2, 3, 0, 0, 1, 0, 1, 0
not empty
16
0, 0, 0, 0, 1, 1, 0, 1, 2, 3, 0, 0, 1, 0, 1, 0
>>>*/

fun test17()
{
    var v: Vector(Int) = createRange(Int, 6);
    var r = v.all();

    v.remove(v.all());
    printSizeInfo(v);
    v.swap(Vector(Int)(createRange(Int, 6)));
    r = v.all();
    r.popBack();
    v.remove(r);
    printSizeInfo(v);
    printVector(v);
    v.swap(Vector(Int)(createRange(Int, 6)));
    r = v.all();
    r.popFront();
    v.remove(r);
    printSizeInfo(v);
    printVector(v);
    v.swap(Vector(Int)(createRange(Int, 6)));
    r = v.all();
    r.popFront();
    r.popFront();
    r.popBack();
    v.remove(r);
    printSizeInfo(v);
    printVector(v);
    v.swap(Vector(Int)(createRange(Int, 6)));
    r = v.all();
    r.popFront(2);
    r.popBack(3);
    v.remove(r);
    printSizeInfo(v);
    printVector(v);
    v.swap(Vector(Int)(createRange(Int, 6)));
    r = v.all();
    r.popFront(3);
    r.popBack(3);
    v.remove(r);
    printSizeInfo(v);
    printVector(v);
}
/*<<<Range removal(17)
empty
0
not empty
1
5
not empty
1
0
not empty
3
0, 1, 5
not empty
5
0, 1, 3, 4, 5
not empty
6
0, 1, 2, 3, 4, 5
>>>*/

fun test18()
{
    var v1: Vector(Int) = createRange(Int, 4);
    var v2: Vector(Int) = createRange(Int, 4);
    var v3: Vector(Int) = createRange(Int, 6);

    // TODO
    //if ( v1 == v2 ) cout << "true" << endl; else cout << "false" << endl;
    //if ( v1 == v3 ) cout << "true" << endl; else cout << "false" << endl;
    //cout << (v1 == ife(v2, "true", "false")) << endl;
    //cout << (v1 == ife(v3, "true", "false")) << endl;
}
/*---<<<Equality operator(18)
true
false
>>>*/

fun test19()
{
    var v: Vector(Int) = createRange(Int, 1000);
    var i = 0;

    printSizeInfo(v);
    while SizeType(i) < v.size() ; i++
    {
        if ( v.at(i) != i )
        {
            cout << "test failed" << endl;
        }
    }

    var vv = v;

    i = 0;
    printSizeInfo(vv);
    while SizeType(i) < vv.size() ; i++
    {
        if ( vv.at(i) != i )
        {
            cout << "test failed" << endl;
        }
    }

    var vvv: Vector(Int);

    vvv.assign(createRange(Int, 1000));
    i = 0;
    printSizeInfo(vvv);
    while SizeType(i) < vvv.size() ; i++
    {
        if ( vvv.at(i) != i )
        {
            cout << "test failed" << endl;
        }
    }
}
/*<<<Large vectors(19)
not empty
1000
not empty
1000
not empty
1000
>>>*/

fun test20()
{
    var v: Vector(Int) = createRange(Int, 8);

    v.remove(SizeType(1));
    printVector(v);
    v.remove(SizeType(0));
    printVector(v);
    v.remove(SizeType(5));
    printVector(v);
    v.remove(SizeType(3));
    printVector(v);
}
/*<<<Element removal(20)
0, 2, 3, 4, 5, 6, 7
2, 3, 4, 5, 6, 7
2, 3, 4, 5, 6
2, 3, 4, 6
>>>*/

fun test21()
{
    var v: Vector(Int) = createRange(Int, 8);
    var r = v.subrange(SizeType(0), SizeType(0));

    while !r.isEmpty() ; r.popFront()
    {
        cout << r.front() << endl;
    }
    r = v.subrange(0, 1);
    while !r.isEmpty() ; r.popFront()
    {
        cout << r.front() << endl;
    }
    r = v.subrange(2, 3);
    while !r.isEmpty() ; r.popFront()
    {
        cout << r.front() << endl;
    }
    r = v.subrange(SizeType(0), v.size());
    while !r.isEmpty() ; r.popFront()
    {
        cout << r.front() << endl;
    }
    v.remove(v.subrange(SizeType(2), SizeType(3)));
    printVector(v);
}
/*<<<Subrange(21)
0
2
3
4
0
1
2
3
4
5
6
7
0, 1, 5, 6, 7
>>>*/
