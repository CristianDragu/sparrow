//!! -t ""
nodelist{

    backendcode{
"target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\""
""
"@.str = private unnamed_addr constant [4 x i8] c\"15\\0A\\00\", align 1"
"@.fmtInt = private unnamed_addr constant [4 x i8] c\"%x\\0A\\00\", align 1"
"@.fmtInt64 = private unnamed_addr constant [6 x i8] c\"%llx\\0A\\00\", align 1"
""
"define void @writeLnInt(i32 %val) {"
"  %1 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.fmtInt, i32 0, i32 0), i32 %val)"
"  ret void"
"}"
""
"define void @writeLnInt64(i64 %val) {"
"  %1 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([6 x i8]* @.fmtInt64, i32 0, i32 0), i64 %val)"
"  ret void"
"}"
""
"define void @writeLnUInt(i32 %val) {"
"  %1 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.fmtInt, i32 0, i32 0), i32 %val)"
"  ret void"
"}"
""
"define void @writeLnUInt64(i64 %val) {"
"  %1 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([6 x i8]* @.fmtInt64, i32 0, i32 0), i64 %val)"
"  ret void"
"}"
""
"define i32 @mul(i32 %x, i32 %y) {"
"  %1 = mul i32 %x,%y"
"  ret i32 %1"
"}"
""
"define i32 @sub(i32 %x, i32 %y) {"
"  %1 = sub i32 %x,%y"
"  ret i32 %1"
"}"
""
"define i1 @equal(i32 %x, i32 %y) {"
"  %1 = icmp eq i32 %x,%y"
"  ret i1 %1"
"}"
""
"define i32 @main(i32 %argc, i8** %argv) nounwind uwtable {"
"  %1 = alloca i32, align 4"
"  %2 = alloca i32, align 4"
"  %3 = alloca i8**, align 8"
"  store i32 0, i32* %1"
"  store i32 %argc, i32* %2, align 4"
"  store i8** %argv, i8*** %3, align 8"
"  %4 = load i8*** %3, align 8"
"  %5 = getelementptr inbounds i8** %4, i64 1"
"  %6 = load i8** %5"
"  %7 = call i32 @atoi(i8* %6) nounwind readonly"
"  call void @test(i32 %7)"
"  ret i32 0"
"}"
""
"declare i32 @atoi(i8*) nounwind readonly"
"declare i32 @printf(i8*, ...)"
"declare void @test(i32)"
    }
    
    class { Int
        autoct
        propStr("nativeName", "i32")
    }
    
    class { Int64
        autoct
        propStr("nativeName", "i64")
    }
    
    class { UInt
        autoct
        propStr("nativeName", "u32")
    }
    
    class { UInt64
        autoct
        propStr("nativeName", "u64")
    }
    
    class { EmptyClass
        autoct
    }
    
    class { Pair
        autoct
        field(x,Int)
        field(y,Int)
    }
    
    class { Pair2       // due to alignment, this will have size 16, instead of 12
        autoct
        field(x,Int64)
        field(y,Int)
    }
    
    class { RefInt
        autoct
        field(r, ref(Int))
    }
    
    class { RefInt64
        autoct
        field(r, ref(Int64))
    }
    
    /*class { RefVoid
        field(r, ref(void))
    }*/
    
    class { S1
        autoct
        field(x, Int)
    }
    
    function(writeLnInt, params(var(val,Int)), void)
    function(writeLnInt64, params(var(val,Int64)), void)
    function(writeLnUInt, params(var(val,UInt)), void)
    function(writeLnUInt64, params(var(val,UInt64)), void)
    
    function(test, params(var(x,Int)), void, localspace{
        funCall(writeLnInt, ctValueBin(Int, "0f 00 00 00"))
        
        // Create variables of each type
        localVar(v1, Int)
        localVar(v2, Int64)
        localVar(v3, UInt)
        localVar(v4, UInt64)
        localVar(v5, EmptyClass)
        localVar(v6, Pair)
        localVar(v7, Pair2)
        localVar(v8, RefInt)
        localVar(v9, RefInt64)
        //localVar(v10, RefVoid)
        localVar(v11, S1)
        
        
        ctValue(EmptyClass, "")
        ctValue(Pair, "12341234")
        
        // Now create literals of the correct size for each var. If we have an error, we have a size error
        memStore(ctValueBin(Int, "01 00 00 00"), varref(v1))
        memStore(ctValueBin(Int64, "ff de bc 9a 78 56 34 12"), varref(v2))
        memStore(ctValueBin(UInt, "03 00 00 00"), varref(v3))
        memStore(ctValueBin(UInt64, "04 00 00 00 00 00 00 00"), varref(v4))
        //memStore(ctValueBin(EmptyClass, ""), varref(v5))     // Zero size
        memStore(ctValueBin(Pair, "05 00 00 00 06 00 00 00"), varref(v6))
        memStore(ctValueBin(Pair2, "11 22 33 44 55 66 77 88 99 aa bb cc 00 00 00 00"), varref(v7))  // plus zero padding
        memStore(ctValueBin(RefInt, "01 00 00 00 00 00 00 00"), varref(v8))
        memStore(ctValueBin(RefInt64, "01 00 00 00 00 00 00 00"), varref(v9))
        //memStore(ctValueBin(RefVoid, "01 00 00 00 00 00 00 00"), varref(v10))
        memStore(ctValueBin(S1, "0a 00 00 00"), varref(v11))

        funCall(writeLnInt, memLoad(varRef(v1)))
        funCall(writeLnInt64, memLoad(varRef(v2)))
        funCall(writeLnUInt, memLoad(varRef(v3)))
        funCall(writeLnUInt64, memLoad(varRef(v4)))
        funCall(writeLnInt, memLoad(fieldref(varref(v6), Pair, x)))
        funCall(writeLnInt, memLoad(fieldref(varref(v6), Pair, y)))
        funCall(writeLnInt64, memLoad(fieldref(varref(v7), Pair2, x)))
        funCall(writeLnInt, memLoad(fieldref(varref(v7), Pair2, y)))
        funCall(writeLnInt, memLoad(fieldref(varref(v11), S1, x)))
        return
    })
}

/*<<<Running(5)
f
1
123456789abcdeff
3
4
5
6
8877665544332211
ccbbaa99
a
>>>*/
