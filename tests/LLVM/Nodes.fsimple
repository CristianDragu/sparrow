//!! -t ""
nodelist{

    nop
    
    class { Int
        autoct
        propStr("nativeName", "i32")
    }
    
    class { Bool
        autoct
        propStr("nativeName", "u1")
    }
    
    class { Pair
        field(x,Int)
        field(y,Int)
    }
    
    class { PairRef
        field(p, ref(Pair))
    }
    
    function(f, params(var(x,Int), var(y,Int)), void, localspace{})
    function(f2, params(var(x,Int,4), var(y,Int,4)), void)
    
    function(test, params(), void, localspace{
        tempDestructAction(nop)
        scopeDestructAction(nop)
        var(v, Int)
        var(v4, Int, 4)
        localspace{
            // Expression nodes
            ctValue(Int, "qwer")
            ctValueBin(Int, "00 00 00 00")
            memLoad(varRef(v))
            memLoad(varRef(v4), 4)
            memLoad(varRef(v4), 4, volatile)
            memLoad(varRef(v4), 4, unordered)
            memLoad(varRef(v4), 4, volatile,unordered)
            memLoad(varRef(v4), 4, volatile,unordered,singlethread)
            memLoad(varRef(v), 0, unordered)
            memLoad(varRef(v), 0, monotonic)
            memLoad(varRef(v), 0, acquire)
            memLoad(varRef(v), 0, release)
            memLoad(varRef(v), 0, acquirerelease)
            memLoad(varRef(v), 0, seqconsistent)
            memStore(ctValueBin(Int, "00 00 00 00"), varRef(v))
            memStore(ctValueBin(Int, "00 00 00 00"), varRef(v), 0)
            memStore(ctValueBin(Int, "00 00 00 00"), varRef(v), 0, volatile)
            memStore(ctValueBin(Int, "00 00 00 00"), varRef(v), 4, volatile, unordered)
            memStore(ctValueBin(Int, "00 00 00 00"), varRef(v), 4, volatile, unordered, singlethread)
            memStore(ctValueBin(Int, "00 00 00 00"), varRef(v), 4, singlethread, unordered,volatile)
        }

        if(ctValueBin(Bool, "01"), nop, nop)
        varRef(v)
        if(ctValueBin(Bool, "01"), localspace{varRef(v) nop}, localspace{varRef(v) nop})
        localspace{ nop }
        if(ctValueBin(Bool, "01"), varRef(v))
        localspace{ nop }
        if(ctValueBin(Bool, "00"), varRef(v))
        localspace{ nop }

        staticIf(ctValueBin(ct(Bool), "00"), varRef(v), varRef(v))
        staticIf(ctValueBin(ct(Bool), "00"), varRef(v))
        staticIf(ctValueBin(ct(Bool), "01"), varRef(v), varRef(v))
        staticIf(ctValueBin(ct(Bool), "01"), varRef(v))

        while(ctValueBin(ct(Bool), "00"), varRef(v))
        while(ctValueBin(ct(Bool), "00"), varRef(v), varRef(v))
        
        varRef(v)
        
        while(ctValueBin(ct(Bool), "01"), break)
        while(ctValueBin(ct(Bool), "01"), continue)
        while(ctValueBin(ct(Bool), "01"), localSpace{continue varRef(v)})
        while(ctValueBin(ct(Bool), "01"), localSpace{return varRef(v)})

        while(ctValueBin(ct(Bool), "01"), nop, break)
        while(ctValueBin(ct(Bool), "01"), nop, continue)
        while(ctValueBin(ct(Bool), "01"), nop, return)

        // label(someLabelName)
        // label(someLabelName2)
        // goto(someLabelName)
        //condGoto(ctValueBin(Bool, "00"), someLabelName)
        //condGoto(ctValueBin(Bool, "00"), someLabelName, someLabelName2)
        
        localVar(a, Int)
        varRef(a)
        memStore(ctValueBin(Int, "00 00 00 00"), varRef(a))
        
        localVar(p2, Pair)
        fieldRef(varRef(p2), Pair, x)

        localVar(three, Int)
        localVar(five, Int)
        memStore(ctValueBin(Int, "03 00 00 00"), varRef(three))
        memStore(ctValueBin(Int, "05 00 00 00"), varRef(five))
        funCall(f, memLoad(varRef(three)),memLoad(varRef(five)))
        return
    })

    backendcode{
"@.str = private unnamed_addr constant [4 x i8] c\"15\\0A\\00\", align 1"
""
"define i32 @main(i32 %argc, i8** %argv) nounwind uwtable {"
"  %1 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str, i32 0, i32 0))"
"  ret i32 0"
"}"
""
"declare i32 @printf(i8*, ...)"
    }
}
/*<<<Running()
15
>>>*/
