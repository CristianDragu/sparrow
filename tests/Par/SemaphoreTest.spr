//! ! --dump-assembly
import Par.Thread;
import Par.Atomic;
import Par.Semaphore;
import Test;

using Par.*;
using Test.*;

var numResources: Int;
var numUsers: Int Atomic = 0;
var numExecutions: Int Atomic = 0;

fun doJob(sem: @Par.Semaphore, waitTime: Int) {
    sem acquire;
    ++numUsers;
    //cout << (numUsers load) << ' ';
    Test.assertLe(numUsers load, numResources, "numUsers should be less or equal to the number of resources");
    ++numExecutions;
    Par.sleep(waitTime);
    --numUsers;
    sem release;
}

class[initCtor] Worker {
    private var sem: @Par.Semaphore;
    private var amountOfWork: Int;

    fun ()() {
        for ( i = 0..amountOfWork ) {
            doJob(sem, i % 5 + 1);
        }
        Test.assertGe(numExecutions load, amountOfWork, "all our job should be executed");
    }
}

class WorkManager {
    private var sem: @Par.Semaphore;
    private var amountOfWork, numWorkers: Int;
    private var threads: (Par.Thread Ptr) Vector;

    fun ctor(sem: @Par.Semaphore, amountOfWork, numWorkers: Int) {
        this.amountOfWork ctor amountOfWork;
        this.numWorkers ctor numWorkers;
        for ( i=0..numWorkers ) {
            var p: Par.Thread Ptr = new(Par.Thread, Worker(sem, amountOfWork));
            threads.pushBack(p);
        }
    }

    fun dtor {
        for ( t = threads.all ) {
            t.get join;
            t.release;
        }
        Test.assertEq(numExecutions load, amountOfWork*numWorkers, "numExecutions should be equal to the total amount of work");
    }
}

fun sprMain
{
    if ( programArgs.size() < 4 )
        return;
    numResources = (programArgs(1) asInt);
    var amountOfWork = programArgs(2) asInt;
    var numWorkers = programArgs(3) asInt;

    // Initialize the semaphore
    var sem: Par.Semaphore = numResources;

    // Do the work
    var work = WorkManager(sem, amountOfWork, numWorkers);
}

/*<<<Binary semaphore with 1 thread (1 20 1)
>>>*/

/*<<<Binary semaphore with 5 threads (1 20 5)
>>>*/

/*<<<5-slot semaphore with 7 threads (5 20 7)
>>>*/

