// !! -O2 --dump-assembly --dump-opt-assembly
import std.vector;
import std.list;
import std.map;
import std.set;
import std.utils;

// BasicBlockEdge only maintains two pointers to BasicBlocks.
//
class BasicBlockEdge {
    fun ctor(cfg: @MaoCFG, fromName, toName: Int) {
        from ctor cfg.createNode(fromName);
        to   ctor cfg.createNode(toName);

        from->addOutEdge(to);
        to->addInEdge(from);
        cfg.addEdge(this);
    }

    var from, to: BasicBlock Ptr;
}

// BasicBlock only maintains a vector of in-edges and
// a vector of out-edges.
//
class BasicBlock {
    fun ctor(name: Int) {
        this.name ctor name;
    }

    fun numPred = inEdges.size;
    fun numSucc = outEdges.size;

    fun addOutEdge(to: BasicBlock Ptr)  = outEdges += to;
    fun addInEdge(from: BasicBlock Ptr) = inEdges += from;

    fun inEdgesRange  = inEdges all;
    fun outEdgesRange = outEdges all;

    fun hash = name;

    private var inEdges, outEdges: Vector(BasicBlock Ptr);
    private var name: Int;
}

// MaoCFG maintains a list of nodes.
class MaoCFG
{
    fun dtor {
        basicBlockMap.values delete;
        edges.all delete;
    }

    fun createNode(name: Int): BasicBlock Ptr {
        var node: @Ptr(BasicBlock) = basicBlockMap(name);
        if ( !node ) {
            node = new(BasicBlock, name);
        }
        if ( basicBlockMap.size == 1 )
            startNode = node;
        return node;
    }

    fun addEdge(edge: BasicBlockEdge Ptr)   = edges += edge;
    fun getNumNodes                         = basicBlockMap.size;

    fun basicBlocksRange = basicBlockMap.values();

    var startNode: BasicBlock Ptr;
    private var basicBlockMap: Map(Int, BasicBlock Ptr);
    private var edges: List(BasicBlockEdge Ptr);
}

//
// SimpleLoop
//
// Basic representation of loops, a loop has an entry point,
// one or more exit edges, a set of basic blocks, and potentially
// an outer loop - a "parent" loop.
//
// Furthermore, it can have any set of properties, e.g.,
// it can be an irreducible loop, have control flow, be
// a candidate for transformations, and what not.
//
class SimpleLoop {
    fun addNode(bb: BasicBlock Ptr)         = basicBlocks += bb;
    fun addChildLoop(loop: SimpleLoop Ptr)  = children += loop;

    fun setParent(parent: SimpleLoop Ptr) {
        this.parent = parent;
        this.parent->addChildLoop(this);
    }
    fun setNestingLevel(level: Int) {
        nestingLevel = level;
        isRoot = (level == 0);
    }

    fun hash = counter;

    fun >>(os: @OutStream) {
        os << "loop-" << counter << ", nest: " << nestingLevel << ", depth: " << depthLevel << endl;
    }

    var children: Set(SimpleLoop Ptr);

    var isRoot: Bool;
    var nestingLevel: Int;
    var depthLevel: Int;
    var counter: Int;

    private var parent: SimpleLoop Ptr;
    private var basicBlocks: Set(BasicBlock Ptr);
}

//
// LoopStructureGraph
//
// Maintain loop structure for a given CFG.
//
// Two values are maintained for this loop graph, depth, and nesting level.
// For example:
//
// loop        nesting level    depth
//----------------------------------------
// loop-0      2                0
//   loop-1    1                1
//   loop-3    1                1
//     loop-2  0                2
//
class LoopStructureGraph {
    fun ctor {
        loopCounter ctor 1;
        root ctor new(SimpleLoop);
        root->counter = 0;
        root->setNestingLevel(0);
        loops += root;
    }

    fun dtor = killAll;

    fun killAll {
        for ( loop = loops.all )
            loop.release;
        loops.clear;
    }

    fun createNewLoop: SimpleLoop Ptr {
        var loop: SimpleLoop Ptr = new(SimpleLoop);
        loop->counter = (loopCounter++);
        return loop;
    }

    fun addLoop(loop: SimpleLoop Ptr)   = loops += loop;

    fun calculateNestingLevel {
        // link up all 1st level loops to artificial root node.
        for ( loop = loops.all )
            if ( !loop->isRoot && !loop->parent )
                loop->setParent(root);

        // recursively traverse the tree and assign levels.
        calculateNestingLevelRec(root, 0);
    }
    private fun calculateNestingLevelRec(loop: SimpleLoop Ptr, depth: Int) {
        loop->depthLevel = depth;
        for ( c = loop->children.all ) {
            calculateNestingLevelRec(c, depth+1);
            loop->setNestingLevel(max(loop->nestingLevel, 1+c->nestingLevel));
        }
    }

    fun numLoops = loops.size;

    fun >>(os: @OutStream)              = dumpRec(os, root, 0);

    private fun dumpRec(os: @OutStream, loop: SimpleLoop Ptr, indent: Int) {
        os << loop.get;
        for ( c = loop->children.all )
            dumpRec(os, c, indent+1);
    }

    private var root: SimpleLoop Ptr;
    private var loops: List(SimpleLoop Ptr);
    private var loopCounter: Int;
}

//
// Union/Find algorithm after Tarjan, R.E., 1983, Data Structures
// and Network Algorithms.
//
class UnionFindNode {
    // Initialize this node.
    //
    fun init(bb: BasicBlock Ptr, dfsNumber: Int) {
        this.parent     ctor this;
        this.bb         ctor bb;
        this.dfsNumber  ctor dfsNumber;
    }

    // Union/Find Algorithm - The find routine.
    //
    // Implemented with Path Compression (inner loops are only
    // visited and collapsed once, however, deep nests would still
    // result in significant traversals).
    //
    fun findSet: UnionFindNode Ptr {
        var nodeList: List(UnionFindNode Ptr);

        var node: UnionFindNode Ptr = this;
        while ( node != node->parent ; node = node->parent ) {
            if ( node->parent != node->parent->parent )
                nodeList += node;
        }

        for ( n = nodeList.all )
            n->parent = node->parent;

        return node;
    }

    // Union/Find Algorithm - The union routine.
    //
    // We rely on path compression.
    //
    fun union(b: UnionFindNode Ptr) {
        parent = b;
    }

    var bb: BasicBlock Ptr;
    var loop: SimpleLoop Ptr;
    var dfsNumber: Int;
    private var parent: UnionFindNode Ptr;
}

//------------------------------------------------------------------
// Loop Recognition
//
// based on:
//   Paul Havlak, Nesting of Reducible and Irreducible Loops,
//      Rice University.
//
//   We avoid doing tree balancing and instead use path compression
//   to avoid traversing parent pointers over and over.
//
//   Most of the variable names and identifiers are taken literally
//   from this paper (and the original Tarjan paper mentioned above).
//-------------------------------------------------------------------
class HavlakLoopFinder {
    //
    // Local types used for Havlak algorithm, all carefully
    // selected to guarantee minimal complexity.
    //
    using NodeVector = UnionFindNode Vector;
    using BasicBlockMap = Map(BasicBlock Ptr, Int);
    using IntList = Int List;
    using IntSet = Int Set;
    using NodeList = (UnionFindNode Ptr) List;
    using IntListVector = IntList Vector;
    using IntSetVector = IntSet Vector;
    using IntVector = Int Vector;
    using CharVector = Byte Vector;

    using BB_TOP            = Byte(0);  // uninitialized
    using BB_NONHEADER      = Byte(1);  // a regular BB
    using BB_REDUCIBLE      = Byte(2);  // reducible loop
    using BB_SELF           = Byte(3);  // single BB loop
    using BB_IRREDUCIBLE    = Byte(4);  // irreducible loop
    using BB_DEAD           = Byte(5);  // a dead BB
    using BB_LAST           = Byte(6);  // Sentinel

    using kUnvisited = -1;              // Marker for uninitialized nodes.
    using kMaxNonBackPreds = 32*1024;   // Safeguard against pathologic algorithm behavior.

    fun ctor(cfg: @MaoCFG, lsg: @LoopStructureGraph) {
        this.cfg := cfg;
        this.lsg := lsg;
    }

    //
    // IsAncestor
    //
    // As described in the paper, determine whether a node 'w' is a
    // "true" ancestor for node 'v'.
    //
    // Dominance can be tested quickly using a pre-order trick
    // for depth-first spanning trees. This is why DFS is the first
    // thing we run below.
    //
    fun isAncestor(w, v: SizeType, last: @IntVector) = (w <= v) && (v <= last(w));

    //
    // DFS - Depth-First-Search
    //
    // DESCRIPTION:
    // Simple depth first traversal along out edges with node numbering.
    //
    fun doDFS(currentNode: BasicBlock Ptr, nodes: @NodeVector, number: @BasicBlockMap, last: @IntVector, current: Int): Int {
        nodes(current).init(currentNode, current);
        number(currentNode) = current;

        var lastId = current;
        for ( target = currentNode->outEdgesRange ) {
            if ( number(target) == kUnvisited )
                lastId = doDFS(target, nodes, number, last, lastId+1);
        }
        last(number(currentNode)) = lastId;
        return lastId;
    }

    //
    // FindLoops
    //
    // Find loops and build loop forest using Havlak's algorithm, which
    // is derived from Tarjan. Variable names and step numbering has
    // been chosen to be identical to the nomenclature in Havlak's
    // paper (which is similar to the one used by Tarjan).
    //
    fun findLoops {
        if ( !cfg.startNode )
            return;

        var size = cfg.getNumNodes;

        var nonBackPreds: IntSetVector = size;
        var backPreds: IntListVector = size;
        var header: IntVector = size;
        var type: CharVector = size;
        var last: IntVector = size;
        var nodes: NodeVector = size;
        var number: BasicBlockMap;

        // Step a:
        //   - initialize all nodes as unvisited.
        //   - depth-first traversal and numbering.
        //   - unreached BB's are marked as dead.
        //
        for ( bb = cfg.basicBlocksRange )
            number.insert(bb, kUnvisited);

        doDFS(cfg.startNode, nodes, number, last, 0);

        // Step b:
        //   - iterate over all nodes.
        //
        //   A backedge comes from a descendant in the DFS tree, and non-backedges
        //   from non-descendants (following Tarjan).
        //
        //   - check incoming edges 'v' and add them to either
        //     - the list of backedges (backPreds) or
        //     - the list of non-backedges (nonBackPreds)
        //
        for ( w = 0..size ) {
            header(w) = 0;
            type(w) = BB_NONHEADER;

            var nodeW: BasicBlock Ptr = nodes(w).bb;
            if ( !nodeW ) {
                type(w) = BB_DEAD;
                continue;   // dead BB
            }

            if ( nodeW->numPred > 0 ) {
                for ( nodeV = nodeW->inEdgesRange ) {
                    var v = number(nodeV);
                    if ( v == kUnvisited )
                        continue;   // dead node

                    if ( isAncestor(w, v, last) )
                        backPreds(w) += v;
                    else
                        nonBackPreds(w) += v;
                }
            }
        }

        // Start node is root of all other loops.
        header(0) = 0;

        // Step c:
        //
        // The outer loop, unchanged from Tarjan. It does nothing except
        // for those nodes which are the destinations of backedges.
        // For a header node w, we chase backward from the sources of the
        // backedges adding nodes to the set P, representing the body of
        // the loop headed by w.
        //
        // By running through the nodes in reverse of the DFST preorder,
        // we ensure that inner loop headers will be processed before the
        // headers for surrounding loops.
        //
        for ( w = Int(size-1)...0 ../ (-1) ) {
            var nodePool: NodeList;       // this is 'P' in Havlak's paper
            var nodeW = nodes(w).bb;
            if ( !nodeW )
                continue;   // dead BB

            // Step d:
            for ( v = backPreds(w).all ) {
                if ( v != w )
                    nodePool += nodes(v).findSet;
                else
                    type(w) = BB_SELF;
            }

            // Copy node_pool to worklist.
            //
            //var workList: NodeList = nodePool;
            var workList: NodeList = nodePool.all;
            if ( nodePool.isEmpty )
                type(w) = BB_REDUCIBLE;

            // work the list...
            //
            while ( !workList.isEmpty ) {
                var x = workList.front;
                workList.popFront;

                // Step e:
                //
                // Step e represents the main difference from Tarjan's method.
                // Chasing upwards from the sources of a node w's backedges. If
                // there is a node y' that is not a descendant of w, w is marked
                // the header of an irreducible loop, there is another entry
                // into this loop that avoids w.

                // The algorithm has degenerated. Break and
                // return in this case.
                //
                var nonBackSize = nonBackPreds(x->dfsNumber).size;
                if ( nonBackSize > kMaxNonBackPreds ) {
                    lsg.killAll;
                    return;
                }

                for ( t = nonBackPreds(x->dfsNumber).all ) {
                    var y: @UnionFindNode = nodes(t);
                    var yDash = y.findSet;

                    if ( !isAncestor(w, yDash->dfsNumber, last) ) {
                        type(w) = BB_IRREDUCIBLE;
                        nonBackPreds(w).insert(yDash->dfsNumber);
                    } else {
                        if ( yDash->dfsNumber != w ) {
                            if ( find(nodePool.all, yDash).isEmpty ) {
                                workList += yDash;
                                nodePool += yDash;
                            }
                        }
                    }
                }
            }

            // Collapse/Unionize nodes in a SCC to a single node
            // For every SCC found, create a loop descriptor and link it in.
            //
            if ( !nodePool.isEmpty || type(w) == BB_SELF ) {
                var loop = lsg.createNewLoop;

                // At this point, one can set attributes to the loop, such as:
                //
                // the bottom node:
                //    IntList::iterator iter  = back_preds[w].begin;
                //    loop bottom is: nodes[*backp_iter].node);
                //
                // the number of backedges:
                //    back_preds[w].size
                //
                // whether this loop is reducible:
                //    type[w] != BB_IRREDUCIBLE
                //
                // TODO(rhundt): Define those interfaces in the Loop Forest.
                //
                nodes(w).loop = loop;

                for ( node = nodePool.all ) {
                    header(node->dfsNumber) = w;
                    node->union(nodes(w));

                    if ( node->loop.isSet )
                        node->loop->setParent(loop);
                    else
                        loop->addNode(node->bb);
                }
                lsg.addLoop(loop);
            }
        }
    }

    private var cfg: @MaoCFG;
    private var lsg: @LoopStructureGraph;
}

// External entry point.
fun findHavlakLoops(cfg: @MaoCFG, lsg: @LoopStructureGraph): SizeType {
    var finder = HavlakLoopFinder(cfg, lsg);
    finder.findLoops;
    return lsg.numLoops;
}

//--- TESTING CODE -------------------

fun buildDiamond(cfg: @MaoCFG, start: Int): Int {
    new(BasicBlockEdge, cfg, start  , start+1);
    new(BasicBlockEdge, cfg, start  , start+2);
    new(BasicBlockEdge, cfg, start+1, start+3);
    new(BasicBlockEdge, cfg, start+2, start+3);
    return start+3;
}

fun buildConnect(cfg: @MaoCFG, start, end: Int) {
    new(BasicBlockEdge, cfg, start, end);
}

fun buildStraight(cfg: @MaoCFG, start, n: Int): Int {
    for ( i = 0..n )
        buildConnect(cfg, start + i, start + i + 1);
    return start + n;
}

fun buildBaseLoop(cfg: @MaoCFG, from: Int): Int {
    var header   = buildStraight(cfg, from, 1);
    var diamond1 = buildDiamond(cfg, header);
    var d11      = buildStraight(cfg, diamond1, 1);
    var diamond2 = buildDiamond(cfg, d11);
    var footer   = buildStraight(cfg, diamond2, 1);
    buildConnect(cfg, diamond2, d11);
    buildConnect(cfg, diamond1, header);

    buildConnect(cfg, footer, from);
    footer = buildStraight(cfg, footer, 1);
    return footer;
}

fun sprMain {
    cout << "Welcome to LoopTesterApp, Sparrow edition" << endl;
    cout << "Constructing cfg..." << endl;
    var cfg: MaoCFG;
    cout << "Constructing lsg..." << endl;
    var lsg: LoopStructureGraph;

    cout << "Constructing Simple CFG..." << endl;
    cfg.createNode(0);  // top
    buildBaseLoop(cfg, 0);
    cfg.createNode(1);  // bottom
    new(BasicBlockEdge, cfg, 0, 2);

    cout << "15000 dummy loops" << endl;
    for ( dummyLoop = 0..15000 ) {
        findHavlakLoops(cfg, LoopStructureGraph());
    }

    cout << "Constructing CFG..." << endl;
    var n = 2;

    for ( parlooptrees = 0..10 ) {
        cfg.createNode(n + 1);
        buildConnect(cfg, 2, n + 1);
        ++n;

        for ( i = 0..100 ) {
            var top = n;
            n = buildStraight(cfg, n, 1);
            for ( j = 0..25 )
                n = buildBaseLoop(cfg, n);
            var bottom = buildStraight(cfg, n, 1);
            buildConnect(cfg, n, top);
            n = bottom;
        }
        buildConnect(cfg, n, 1);
    }

    cout << "Performing Loop Recognition\n1 Iteration" << endl;
    var numLoops = findHavlakLoops(cfg, lsg);

    cout << "Another 50 iterations..." << endl;
    var numIterations = programArgs(1) asInt;
    var sum: SizeType = 0;
    for ( i = 0..numIterations ) {
        cout << '.' << flush;
        sum += findHavlakLoops(cfg, LoopStructureGraph());
    }
    cout << endl << "Found " << numLoops << " loops (including artificial root node)(" << sum << ')' << endl;
    cout << lsg;
}
/*<<<Running(2)
Welcome to LoopTesterApp, Sparrow edition
Constructing cfg...
Constructing lsg...
Constructing Simple CFG...
15000 dummy loops
Constructing CFG...
Performing Loop Recognition
1 Iteration
Another 50 iterations...
..
Found 76002 loops (including artificial root node)(152004)
loop-0, nest: 0, depth: 0
>>>*/
