#!/usr/bin/python

"""
Description: Tool for getting the list of types present at a given location.
Reads .json AST dumps generated by the Sparrow Compiler as input

Copyright (c) 2016, Lucian Radu Teodorescu
"""

import os, subprocess, sys, json, argparse, cgi

def parseArgs():
    def str2bool(v):
      return v.lower() in ("yes", "true", "t", "1")

    parser = argparse.ArgumentParser(description='Generates dot trees from Sparrow json dumps')
    parser.register('type','bool',str2bool)
    parser.add_argument('jsonFile', metavar='jsonFile', type=str,
                       help='the .json file to process')
    parser.add_argument('line', type=int,
                       help='the line to look at')
    parser.add_argument('col', type=int,
                       help='the column to look at')
    return parser.parse_args()

class Location:
    ''' Class that represents a location '''
    def __init__(self, startLine, startCol, endLine, endCol):
        self.startLine = startLine
        self.startCol = startCol
        self.endLine = endLine
        self.endCol = endCol

    def __eq__(self, other):
        return self.startLine == other.startLine \
            and self.startCol == other.startCol \
            and self.endLine == other.endLine \
            and self.endCol == other.endCol

    def __repr__(self):
        return '%d:%d - %d:%d' % (self.startLine, self.startCol, self.endLine, self.endCol)

class Node:
    ''' Class that represents the data of the node (location & type & kind) '''
    def __init__(self, location, type, kind):
        self.location = location
        self.type = type
        self.kind = kind

    def __eq__(self, other):
        return self.location == other.location and self.type == other.type and self.kind == other.kind

    def __repr__(self):
        return '%s (%s) / %s' % (self.type, self.location, self.kind)

def readNodePtr(jsonNodePtr, allNodes):
    ''' Reads a node pointer json node. If filter is satisfied, add the node to our list '''
    ref = jsonNodePtr['ref'] if jsonNodePtr.get('ref') else None
    obj = jsonNodePtr['obj'] if jsonNodePtr.get('obj') else None

    if not ref or not obj:
        return

    # Read the location data
    loc = None
    if obj.get('location'):
        locData = obj['location']
        loc = Location(locData['start']['line'], locData['start']['col'], locData['end']['line'], locData['end']['col'])

    # Read the type
    typeDesc = None
    if obj.get('type'):
        typeData = obj['type']
        if typeData.get('desc'):
            typeDesc = typeData['desc']

    # Read the kind
    kind = obj['kind']

    # Add our node to the output
    if loc and typeDesc:
        allNodes.append(Node(loc, typeDesc, kind))

    # Check link to other nodes
    if obj.get('children'):
        for child in obj['children']:
            readNodePtr(child, allNodes)
    if obj.get('referredNodes'):
        for child in obj['referredNodes']:
            readNodePtr(child, allNodes)
    if obj.get('explanation'):
        readNodePtr(obj['explanation'], allNodes)
    if obj.get('properties'):
        for prop in obj['properties']:
            val = prop['val']
            kind = prop['kind']
            if kind == 2:
                readNodePtr(val, allNodes)

def filterNodes(nodes, line, col):
    def _isGood(node):
        if node.location.startLine > line or line > node.location.endLine:
            # print('%s is not good' % node)
            return False
        if node.location.startLine == line and node.location.startCol > col:
            return False
        if node.location.endLine == line and node.location.endCol < col:
            return False
        else:
            # print('%s is good' % node)
            return True
    return filter(_isGood, nodes)

def locCmp(n1, n2):
    l1 = n1.location
    l2 = n2.location
    c = -cmp((l1.startLine, l1.startCol), (l2.startLine, l2.startCol))
    if c == 0:
        c = cmp((l1.endLine, l1.endCol), (l2.endLine, l2.endCol))
    return c

def main():
    args = parseArgs()

    jsonContent = ''
    with open(args.jsonFile) as f:
        jsonContent = f.read().rstrip()
    jsonData = json.loads(jsonContent)
    # print jsonData

    # Read the nodes from the Json, and apply the filter
    allNodes = []
    readNodePtr(jsonData, allNodes)

    # Filter nodes by location
    nodes = filterNodes(allNodes, args.line, args.col)

    # Sort the locations
    nodes.sort(cmp=locCmp)

    # Remove every node that doesn't have the "tightest" location
    for i in range(1, len(nodes)):
        if not nodes[i].location == nodes[0].location:
            nodes = nodes[0:i]
            break

    # Remove duplicates
    i = 1
    while i < len(nodes):
        if nodes[i] == nodes[i-1]:
            del nodes[i]
        else:
            i += 1

    # Display the results
    for n in nodes:
        print(n)

if __name__ == "__main__":
    main()
